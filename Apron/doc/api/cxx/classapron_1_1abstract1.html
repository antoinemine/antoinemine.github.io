<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APRONXX: apron::abstract1 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">APRONXX
   &#160;<span id="projectnumber">0.9.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceapron.html">apron</a></li><li class="navelem"><a class="el" href="classapron_1_1abstract1.html">abstract1</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classapron_1_1abstract1-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">apron::abstract1 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Level 1 abstract value (ap_abstract1_t wrapper).  
 <a href="classapron_1_1abstract1.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="apxx__abstract1_8hh_source.html">apxx_abstract1.hh</a>&gt;</code></p>

<p>Inherits <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a04607bc2854b93283cd1994db4c4dbf6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a04607bc2854b93283cd1994db4c4dbf6">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1top.html">top</a> x)</td></tr>
<tr class="memdesc:a04607bc2854b93283cd1994db4c4dbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the whole space.  <a href="#a04607bc2854b93283cd1994db4c4dbf6">More...</a><br /></td></tr>
<tr class="separator:a04607bc2854b93283cd1994db4c4dbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd708dc2f4446bafea3d17e291f33af1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#afd708dc2f4446bafea3d17e291f33af1">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1bottom.html">bottom</a> x)</td></tr>
<tr class="memdesc:afd708dc2f4446bafea3d17e291f33af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the empty set.  <a href="#afd708dc2f4446bafea3d17e291f33af1">More...</a><br /></td></tr>
<tr class="separator:afd708dc2f4446bafea3d17e291f33af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5024cf04cdd6fe3fba1e97534893ae41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a5024cf04cdd6fe3fba1e97534893ae41">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;t)</td></tr>
<tr class="memdesc:a5024cf04cdd6fe3fba1e97534893ae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <a href="#a5024cf04cdd6fe3fba1e97534893ae41">More...</a><br /></td></tr>
<tr class="separator:a5024cf04cdd6fe3fba1e97534893ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc49a6b2b019a776860c266c94add2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a06bc49a6b2b019a776860c266c94add2">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a06bc49a6b2b019a776860c266c94add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element and associates an environment (reference count incremented).  <a href="#a06bc49a6b2b019a776860c266c94add2">More...</a><br /></td></tr>
<tr class="separator:a06bc49a6b2b019a776860c266c94add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a47774aefe36f6de2306ba55983bb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a17a47774aefe36f6de2306ba55983bb2">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a17a47774aefe36f6de2306ba55983bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a box.  <a href="#a17a47774aefe36f6de2306ba55983bb2">More...</a><br /></td></tr>
<tr class="separator:a17a47774aefe36f6de2306ba55983bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe83b8f8e90be8f60f6a743a4e920060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#abe83b8f8e90be8f60f6a743a4e920060">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:abe83b8f8e90be8f60f6a743a4e920060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a box.  <a href="#abe83b8f8e90be8f60f6a743a4e920060">More...</a><br /></td></tr>
<tr class="separator:abe83b8f8e90be8f60f6a743a4e920060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af38a4b59e58b87104a70d88ac044f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4af38a4b59e58b87104a70d88ac044f9">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a4af38a4b59e58b87104a70d88ac044f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of linear constraints.  <a href="#a4af38a4b59e58b87104a70d88ac044f9">More...</a><br /></td></tr>
<tr class="separator:a4af38a4b59e58b87104a70d88ac044f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78a788ac56604363ee6df87f1db8440"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ae78a788ac56604363ee6df87f1db8440">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:ae78a788ac56604363ee6df87f1db8440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of arbitrary constraints.  <a href="#ae78a788ac56604363ee6df87f1db8440">More...</a><br /></td></tr>
<tr class="separator:ae78a788ac56604363ee6df87f1db8440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5578abd8e6f47364d58d8f06a8dc6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4e5578abd8e6f47364d58d8f06a8dc6c">abstract1</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;t)</td></tr>
<tr class="memdesc:a4e5578abd8e6f47364d58d8f06a8dc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <a href="#a4e5578abd8e6f47364d58d8f06a8dc6c">More...</a><br /></td></tr>
<tr class="separator:a4e5578abd8e6f47364d58d8f06a8dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr class="memitem:a4f3e5e486b1a2139208b58b424418fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4f3e5e486b1a2139208b58b424418fd8">~abstract1</a> ()</td></tr>
<tr class="memdesc:a4f3e5e486b1a2139208b58b424418fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element.  <a href="#a4f3e5e486b1a2139208b58b424418fd8">More...</a><br /></td></tr>
<tr class="separator:a4f3e5e486b1a2139208b58b424418fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b80374409c75e5d1f3b4d1e91141ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#af1b80374409c75e5d1f3b4d1e91141ad">free</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:af1b80374409c75e5d1f3b4d1e91141ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element using the given manager.  <a href="#af1b80374409c75e5d1f3b4d1e91141ad">More...</a><br /></td></tr>
<tr class="separator:af1b80374409c75e5d1f3b4d1e91141ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Copies and conversions to abstract elements</div></td></tr>
<tr class="memitem:aa3eddc65033da59f2b8e3da88017d4c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aa3eddc65033da59f2b8e3da88017d4c4">operator=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;t)</td></tr>
<tr class="memdesc:aa3eddc65033da59f2b8e3da88017d4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a copy of t to *this.  <a href="#aa3eddc65033da59f2b8e3da88017d4c4">More...</a><br /></td></tr>
<tr class="separator:aa3eddc65033da59f2b8e3da88017d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7fd4292a248506462e5f75534896bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0f7fd4292a248506462e5f75534896bc">operator=</a> (<a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:a0f7fd4292a248506462e5f75534896bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the full space to *this.  <a href="#a0f7fd4292a248506462e5f75534896bc">More...</a><br /></td></tr>
<tr class="separator:a0f7fd4292a248506462e5f75534896bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d4d3d989bc573422ace03218c96beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a01d4d3d989bc573422ace03218c96beb">operator=</a> (<a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:a01d4d3d989bc573422ace03218c96beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the empty set to *this.  <a href="#a01d4d3d989bc573422ace03218c96beb">More...</a><br /></td></tr>
<tr class="separator:a01d4d3d989bc573422ace03218c96beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8592168b29edfe3d00fe264c26a2efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab8592168b29edfe3d00fe264c26a2efd">operator=</a> (const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:ab8592168b29edfe3d00fe264c26a2efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a box to *this.  <a href="#ab8592168b29edfe3d00fe264c26a2efd">More...</a><br /></td></tr>
<tr class="separator:ab8592168b29edfe3d00fe264c26a2efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab47317ca450263be9b245b3007016f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8ab47317ca450263be9b245b3007016f">operator=</a> (const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a8ab47317ca450263be9b245b3007016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of linear constraints to *this.  <a href="#a8ab47317ca450263be9b245b3007016f">More...</a><br /></td></tr>
<tr class="separator:a8ab47317ca450263be9b245b3007016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a13b1d97a69bb39a2a9da3eb055435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a84a13b1d97a69bb39a2a9da3eb055435">operator=</a> (const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a84a13b1d97a69bb39a2a9da3eb055435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of arbitrary constraints to *this.  <a href="#a84a13b1d97a69bb39a2a9da3eb055435">More...</a><br /></td></tr>
<tr class="separator:a84a13b1d97a69bb39a2a9da3eb055435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91393622e71700a39c71380c6bf2720d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a91393622e71700a39c71380c6bf2720d">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x)</td></tr>
<tr class="memdesc:a91393622e71700a39c71380c6bf2720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a copy of x.  <a href="#a91393622e71700a39c71380c6bf2720d">More...</a><br /></td></tr>
<tr class="separator:a91393622e71700a39c71380c6bf2720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd9d86948de72a842493e3abed86294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a3dd9d86948de72a842493e3abed86294">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:a3dd9d86948de72a842493e3abed86294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the full space.  <a href="#a3dd9d86948de72a842493e3abed86294">More...</a><br /></td></tr>
<tr class="separator:a3dd9d86948de72a842493e3abed86294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7c7c0de689b9d4b27b032a4d8e8333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aec7c7c0de689b9d4b27b032a4d8e8333">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:aec7c7c0de689b9d4b27b032a4d8e8333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the full space.  <a href="#aec7c7c0de689b9d4b27b032a4d8e8333">More...</a><br /></td></tr>
<tr class="separator:aec7c7c0de689b9d4b27b032a4d8e8333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdae15c48b20cb1e76ec5c33f7a78a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#afbdae15c48b20cb1e76ec5c33f7a78a9">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:afbdae15c48b20cb1e76ec5c33f7a78a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the empty set.  <a href="#afbdae15c48b20cb1e76ec5c33f7a78a9">More...</a><br /></td></tr>
<tr class="separator:afbdae15c48b20cb1e76ec5c33f7a78a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a76d3271d0392280af8ff54b92b6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a42a76d3271d0392280af8ff54b92b6df">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:a42a76d3271d0392280af8ff54b92b6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the empty set.  <a href="#a42a76d3271d0392280af8ff54b92b6df">More...</a><br /></td></tr>
<tr class="separator:a42a76d3271d0392280af8ff54b92b6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa189dcc451d213fd2f0c562619f840f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aa189dcc451d213fd2f0c562619f840f6">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:aa189dcc451d213fd2f0c562619f840f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <a href="#aa189dcc451d213fd2f0c562619f840f6">More...</a><br /></td></tr>
<tr class="separator:aa189dcc451d213fd2f0c562619f840f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65658443862e2a490c5cbb450fe613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a7c65658443862e2a490c5cbb450fe613">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a7c65658443862e2a490c5cbb450fe613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <a href="#a7c65658443862e2a490c5cbb450fe613">More...</a><br /></td></tr>
<tr class="separator:a7c65658443862e2a490c5cbb450fe613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d068a7df8f1190bcd028543d045bdc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a9d068a7df8f1190bcd028543d045bdc8">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a9d068a7df8f1190bcd028543d045bdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <a href="#a9d068a7df8f1190bcd028543d045bdc8">More...</a><br /></td></tr>
<tr class="separator:a9d068a7df8f1190bcd028543d045bdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253431f62f1a765051f6a7288f51855a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a253431f62f1a765051f6a7288f51855a">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a253431f62f1a765051f6a7288f51855a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of linear constraints.  <a href="#a253431f62f1a765051f6a7288f51855a">More...</a><br /></td></tr>
<tr class="separator:a253431f62f1a765051f6a7288f51855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fa2f49b715da57bc50a5e65b986f6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a91fa2f49b715da57bc50a5e65b986f6f">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a91fa2f49b715da57bc50a5e65b986f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of arbitrary constraints.  <a href="#a91fa2f49b715da57bc50a5e65b986f6f">More...</a><br /></td></tr>
<tr class="separator:a91fa2f49b715da57bc50a5e65b986f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Control of internal representation</div></td></tr>
<tr class="memitem:ad800ae88efb344abe032bf85cdac3b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ad800ae88efb344abe032bf85cdac3b68">minimize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:ad800ae88efb344abe032bf85cdac3b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimizes the size of the representation, to save memory.  <a href="#ad800ae88efb344abe032bf85cdac3b68">More...</a><br /></td></tr>
<tr class="separator:ad800ae88efb344abe032bf85cdac3b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad5bdefc0b48a13f839de77a97868f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a3ad5bdefc0b48a13f839de77a97868f6">canonicalize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a3ad5bdefc0b48a13f839de77a97868f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the abstract element in canonical form (if such a notion exists).  <a href="#a3ad5bdefc0b48a13f839de77a97868f6">More...</a><br /></td></tr>
<tr class="separator:a3ad5bdefc0b48a13f839de77a97868f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994069657f16633ba0e4c7c23e0468c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a994069657f16633ba0e4c7c23e0468c3">approximate</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, int algorithm)</td></tr>
<tr class="memdesc:a994069657f16633ba0e4c7c23e0468c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the abstract element, potentially loosing precision.  <a href="#a994069657f16633ba0e4c7c23e0468c3">More...</a><br /></td></tr>
<tr class="separator:a994069657f16633ba0e4c7c23e0468c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr class="memitem:a76b2862115aa5fbd87175686e493c481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1manager.html">manager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a76b2862115aa5fbd87175686e493c481">get_manager</a> () const</td></tr>
<tr class="memdesc:a76b2862115aa5fbd87175686e493c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the manager the abstract element was created with (with reference count incremented).  <a href="#a76b2862115aa5fbd87175686e493c481">More...</a><br /></td></tr>
<tr class="separator:a76b2862115aa5fbd87175686e493c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106bdd4530d40b49082f636c517fd565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1environment.html">environment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a106bdd4530d40b49082f636c517fd565">get_environment</a> () const</td></tr>
<tr class="memdesc:a106bdd4530d40b49082f636c517fd565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the environment of the abstract element (with reference count incremented).  <a href="#a106bdd4530d40b49082f636c517fd565">More...</a><br /></td></tr>
<tr class="separator:a106bdd4530d40b49082f636c517fd565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c80db7b903cece05706bdea3905bc3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a9c80db7b903cece05706bdea3905bc3d">get_abstract0</a> ()</td></tr>
<tr class="memdesc:a9c80db7b903cece05706bdea3905bc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (modifiable) reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>.  <a href="#a9c80db7b903cece05706bdea3905bc3d">More...</a><br /></td></tr>
<tr class="separator:a9c80db7b903cece05706bdea3905bc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf571fc535416273d6e7cd51893e7fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a3cf571fc535416273d6e7cd51893e7fd">get_abstract0</a> () const</td></tr>
<tr class="memdesc:a3cf571fc535416273d6e7cd51893e7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>.  <a href="#a3cf571fc535416273d6e7cd51893e7fd">More...</a><br /></td></tr>
<tr class="separator:a3cf571fc535416273d6e7cd51893e7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7978d6548967192d3be35131828776"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a0d7978d6548967192d3be35131828776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (abstract) size of the abstract element.  <a href="#a0d7978d6548967192d3be35131828776">More...</a><br /></td></tr>
<tr class="separator:a0d7978d6548967192d3be35131828776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property extraction</div></td></tr>
<tr class="memitem:a339115b7d3b039cf6a379615fc8554ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a339115b7d3b039cf6a379615fc8554ba">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l) const</td></tr>
<tr class="memdesc:a339115b7d3b039cf6a379615fc8554ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for a linear expression evaluated in all points in the abstract element.  <a href="#a339115b7d3b039cf6a379615fc8554ba">More...</a><br /></td></tr>
<tr class="separator:a339115b7d3b039cf6a379615fc8554ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d74bc2e81e8383ae45d0a129046d8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a93d74bc2e81e8383ae45d0a129046d8a">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l) const</td></tr>
<tr class="memdesc:a93d74bc2e81e8383ae45d0a129046d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for an arbitrary expression evaluated in all points in the abstract element.  <a href="#a93d74bc2e81e8383ae45d0a129046d8a">More...</a><br /></td></tr>
<tr class="separator:a93d74bc2e81e8383ae45d0a129046d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443a713ff2704f78988a5eaf5cc675c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#af443a713ff2704f78988a5eaf5cc675c">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v) const</td></tr>
<tr class="memdesc:af443a713ff2704f78988a5eaf5cc675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for the given variable on all points in the abstract element.  <a href="#af443a713ff2704f78988a5eaf5cc675c">More...</a><br /></td></tr>
<tr class="separator:af443a713ff2704f78988a5eaf5cc675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61426b2c51ea83f90ff7863cebc34cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval__array.html">interval_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a61426b2c51ea83f90ff7863cebc34cfb">to_box</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a61426b2c51ea83f90ff7863cebc34cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bounding box for the set represented by the abstract element.  <a href="#a61426b2c51ea83f90ff7863cebc34cfb">More...</a><br /></td></tr>
<tr class="separator:a61426b2c51ea83f90ff7863cebc34cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69339cb2be90a806bec2b6e674b2058d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1generator1__array.html">generator1_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a69339cb2be90a806bec2b6e674b2058d">to_generator_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a69339cb2be90a806bec2b6e674b2058d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generator representation of (an over-approximation of) the set represented by the abstract element.  <a href="#a69339cb2be90a806bec2b6e674b2058d">More...</a><br /></td></tr>
<tr class="separator:a69339cb2be90a806bec2b6e674b2058d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdef105472739af42c8a7f90389db29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#afdef105472739af42c8a7f90389db29c">to_lincons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:afdef105472739af42c8a7f90389db29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element.  <a href="#afdef105472739af42c8a7f90389db29c">More...</a><br /></td></tr>
<tr class="separator:afdef105472739af42c8a7f90389db29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944dee440aaf0c3ce4b6c1cbd83050c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab944dee440aaf0c3ce4b6c1cbd83050c">to_tcons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:ab944dee440aaf0c3ce4b6c1cbd83050c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constraint representation of (an over-approximation of) the set represented by the abstract element.  <a href="#ab944dee440aaf0c3ce4b6c1cbd83050c">More...</a><br /></td></tr>
<tr class="separator:ab944dee440aaf0c3ce4b6c1cbd83050c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C API compatibility</div></td></tr>
<tr class="memitem:aa11fa5ba8fa8a0754853548eacce5712"><td class="memItemLeft" align="right" valign="top">ap_abstract1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aa11fa5ba8fa8a0754853548eacce5712">get_ap_abstract1_t</a> ()</td></tr>
<tr class="memdesc:aa11fa5ba8fa8a0754853548eacce5712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <a href="#aa11fa5ba8fa8a0754853548eacce5712">More...</a><br /></td></tr>
<tr class="separator:aa11fa5ba8fa8a0754853548eacce5712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0f23035e10c9f05527cbd9c4259232"><td class="memItemLeft" align="right" valign="top">const ap_abstract1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aab0f23035e10c9f05527cbd9c4259232">get_ap_abstract1_t</a> () const</td></tr>
<tr class="memdesc:aab0f23035e10c9f05527cbd9c4259232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <a href="#aab0f23035e10c9f05527cbd9c4259232">More...</a><br /></td></tr>
<tr class="separator:aab0f23035e10c9f05527cbd9c4259232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structapron_1_1use__malloc"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structapron_1_1use__malloc')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a></td></tr>
<tr class="memitem:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a886761279a3b4508e689a4115060ad9f">operator new</a> (size_t sz)</td></tr>
<tr class="separator:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1a5ca8977532c5975ef94b5cd382da09">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a6049364eb61e4e9767a7eafafd3f52dc">operator delete</a> (void *p)</td></tr>
<tr class="separator:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1547897dbcdc951e206b53bb0e3b57ef">operator delete[]</a> (void *p)</td></tr>
<tr class="separator:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae9f85047c9ca23a39f505c1f4fbcff3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ae9f85047c9ca23a39f505c1f4fbcff3d">abstract1</a> (ap_abstract1_t x)</td></tr>
<tr class="memdesc:ae9f85047c9ca23a39f505c1f4fbcff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only. Shallow copy of structure.  <a href="#ae9f85047c9ca23a39f505c1f4fbcff3d">More...</a><br /></td></tr>
<tr class="separator:ae9f85047c9ca23a39f505c1f4fbcff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac46e4c0ba148a29a83394974350cd6d2"><td class="memItemLeft" align="right" valign="top">ap_abstract1_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac46e4c0ba148a29a83394974350cd6d2">a</a></td></tr>
<tr class="memdesc:ac46e4c0ba148a29a83394974350cd6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure managed by APRON.  <a href="#ac46e4c0ba148a29a83394974350cd6d2">More...</a><br /></td></tr>
<tr class="separator:ac46e4c0ba148a29a83394974350cd6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a3994902b1385eef6523d2f7b6e61f86c"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classapron_1_1abstract1.html">abstract1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></td></tr>
<tr class="memdesc:a3994902b1385eef6523d2f7b6e61f86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL abstract element, to be used only as default argument in assign and substitute.  <a href="#a3994902b1385eef6523d2f7b6e61f86c">More...</a><br /></td></tr>
<tr class="separator:a3994902b1385eef6523d2f7b6e61f86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Widening</div></td></tr>
<tr class="memitem:a555cf295c88001577220bf1bce7b337d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a555cf295c88001577220bf1bce7b337d">widening</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a555cf295c88001577220bf1bce7b337d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of x widened with y.  <a href="#a555cf295c88001577220bf1bce7b337d">More...</a><br /></td></tr>
<tr class="separator:a555cf295c88001577220bf1bce7b337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24322bfe2d2537c1764a94347c17431d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a24322bfe2d2537c1764a94347c17431d">widening</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;l)</td></tr>
<tr class="memdesc:a24322bfe2d2537c1764a94347c17431d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of x widened with y, using some widening thresholds.  <a href="#a24322bfe2d2537c1764a94347c17431d">More...</a><br /></td></tr>
<tr class="separator:a24322bfe2d2537c1764a94347c17431d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Printing</h2></td></tr>
<tr class="memitem:ada8dff0f3827b740fec81a35dd68bdb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ada8dff0f3827b740fec81a35dd68bdb5">printdiff</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y, FILE *stream)</td></tr>
<tr class="memdesc:ada8dff0f3827b740fec81a35dd68bdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-printing the difference between x and y to a C stream.  <a href="#ada8dff0f3827b740fec81a35dd68bdb5">More...</a><br /></td></tr>
<tr class="separator:ada8dff0f3827b740fec81a35dd68bdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce982025627a24429badae940664c47"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0ce982025627a24429badae940664c47">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;s)</td></tr>
<tr class="memdesc:a0ce982025627a24429badae940664c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints in constraint form.  <a href="#a0ce982025627a24429badae940664c47">More...</a><br /></td></tr>
<tr class="separator:a0ce982025627a24429badae940664c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc976840805ce49fdc62efddceb53bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8fc976840805ce49fdc62efddceb53bd">print</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:a8fc976840805ce49fdc62efddceb53bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-printing to a C stream.  <a href="#a8fc976840805ce49fdc62efddceb53bd">More...</a><br /></td></tr>
<tr class="separator:a8fc976840805ce49fdc62efddceb53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1099828d0c5158a868be70002375d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac1099828d0c5158a868be70002375d16">dump</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:ac1099828d0c5158a868be70002375d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw printing to a C stream (mainly for debug purposes).  <a href="#ac1099828d0c5158a868be70002375d16">More...</a><br /></td></tr>
<tr class="separator:ac1099828d0c5158a868be70002375d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Serialisation</h2></td></tr>
<tr class="memitem:a707d5cdf65b64cfcb89140a2b709e986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a707d5cdf65b64cfcb89140a2b709e986">deserialize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const std::string &amp;s, size_t *eaten)</td></tr>
<tr class="memdesc:a707d5cdf65b64cfcb89140a2b709e986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct an abstract element form a serialized byte-stream and put it into dst.  <a href="#a707d5cdf65b64cfcb89140a2b709e986">More...</a><br /></td></tr>
<tr class="separator:a707d5cdf65b64cfcb89140a2b709e986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2d927f165d9b4c323adbba6f571578"><td class="memItemLeft" align="right" valign="top">std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a9f2d927f165d9b4c323adbba6f571578">serialize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a9f2d927f165d9b4c323adbba6f571578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an abstract element.  <a href="#a9f2d927f165d9b4c323adbba6f571578">More...</a><br /></td></tr>
<tr class="separator:a9f2d927f165d9b4c323adbba6f571578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predicates</h2></td></tr>
<tr class="memitem:af2b16244f41df68b9e8f2647bdaf30b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#af2b16244f41df68b9e8f2647bdaf30b4">operator==</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:af2b16244f41df68b9e8f2647bdaf30b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x and y represent the same set.  <a href="#af2b16244f41df68b9e8f2647bdaf30b4">More...</a><br /></td></tr>
<tr class="separator:af2b16244f41df68b9e8f2647bdaf30b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a239822c50f0d34340cad01d2f5811d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4a239822c50f0d34340cad01d2f5811d">operator!=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a4a239822c50f0d34340cad01d2f5811d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x and y represent different sets.  <a href="#a4a239822c50f0d34340cad01d2f5811d">More...</a><br /></td></tr>
<tr class="separator:a4a239822c50f0d34340cad01d2f5811d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c28711a43d4f292157d16de13c4da90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8c28711a43d4f292157d16de13c4da90">operator&lt;=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a8c28711a43d4f292157d16de13c4da90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x is included within y (set-wise).  <a href="#a8c28711a43d4f292157d16de13c4da90">More...</a><br /></td></tr>
<tr class="separator:a8c28711a43d4f292157d16de13c4da90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71bffbef0e3d7b7f8a8106f937ddb94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab71bffbef0e3d7b7f8a8106f937ddb94">operator&gt;=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:ab71bffbef0e3d7b7f8a8106f937ddb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x contains y (set-wise).  <a href="#ab71bffbef0e3d7b7f8a8106f937ddb94">More...</a><br /></td></tr>
<tr class="separator:ab71bffbef0e3d7b7f8a8106f937ddb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96871c98bdc0fa565648fae51e8368f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab96871c98bdc0fa565648fae51e8368f">operator&gt;</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:ab96871c98bdc0fa565648fae51e8368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x strictly contains y (set-wise).  <a href="#ab96871c98bdc0fa565648fae51e8368f">More...</a><br /></td></tr>
<tr class="separator:ab96871c98bdc0fa565648fae51e8368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648c6062222f356dd99a55bc8cb57259"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a648c6062222f356dd99a55bc8cb57259">operator&lt;</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a648c6062222f356dd99a55bc8cb57259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x is strictly included within y (set-wise).  <a href="#a648c6062222f356dd99a55bc8cb57259">More...</a><br /></td></tr>
<tr class="separator:a648c6062222f356dd99a55bc8cb57259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70523104c8b0ed2932d1a1a597411a13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a70523104c8b0ed2932d1a1a597411a13">is_bottom</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a70523104c8b0ed2932d1a1a597411a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the empty set.  <a href="#a70523104c8b0ed2932d1a1a597411a13">More...</a><br /></td></tr>
<tr class="separator:a70523104c8b0ed2932d1a1a597411a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4c586d48871a8b35e3c2d1715152ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#adf4c586d48871a8b35e3c2d1715152ec">is_top</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:adf4c586d48871a8b35e3c2d1715152ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the full space.  <a href="#adf4c586d48871a8b35e3c2d1715152ec">More...</a><br /></td></tr>
<tr class="separator:adf4c586d48871a8b35e3c2d1715152ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e49f9930afa4abc377451cac1b4214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a79e49f9930afa4abc377451cac1b4214">is_eq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x) const</td></tr>
<tr class="memdesc:a79e49f9930afa4abc377451cac1b4214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this and x represent the same set.  <a href="#a79e49f9930afa4abc377451cac1b4214">More...</a><br /></td></tr>
<tr class="separator:a79e49f9930afa4abc377451cac1b4214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b10bd15959cf97dbc219dc6db572ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a86b10bd15959cf97dbc219dc6db572ca">is_leq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x) const</td></tr>
<tr class="memdesc:a86b10bd15959cf97dbc219dc6db572ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this is included in x (set-wise).  <a href="#a86b10bd15959cf97dbc219dc6db572ca">More...</a><br /></td></tr>
<tr class="separator:a86b10bd15959cf97dbc219dc6db572ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ef4e577b8dbfff9ddcb16b9393dba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a74ef4e577b8dbfff9ddcb16b9393dba4">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1.html">lincons1</a> &amp;l) const</td></tr>
<tr class="memdesc:a74ef4e577b8dbfff9ddcb16b9393dba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy a linear constraint.  <a href="#a74ef4e577b8dbfff9ddcb16b9393dba4">More...</a><br /></td></tr>
<tr class="separator:a74ef4e577b8dbfff9ddcb16b9393dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855ee58954b223c77cc9b2efa21dd31e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a855ee58954b223c77cc9b2efa21dd31e">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1.html">tcons1</a> &amp;l) const</td></tr>
<tr class="memdesc:a855ee58954b223c77cc9b2efa21dd31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy an arbitrary constraint.  <a href="#a855ee58954b223c77cc9b2efa21dd31e">More...</a><br /></td></tr>
<tr class="separator:a855ee58954b223c77cc9b2efa21dd31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f19c3e1dd25a092294a97680650f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a1f4f19c3e1dd25a092294a97680650f9">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;i) const</td></tr>
<tr class="memdesc:a1f4f19c3e1dd25a092294a97680650f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the component v of all points in *this is included in the given interval.  <a href="#a1f4f19c3e1dd25a092294a97680650f9">More...</a><br /></td></tr>
<tr class="separator:a1f4f19c3e1dd25a092294a97680650f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b43de9c05b871379b0d3202502aba2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab6b43de9c05b871379b0d3202502aba2">is_variable_unconstrained</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v) const</td></tr>
<tr class="memdesc:ab6b43de9c05b871379b0d3202502aba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the points in *this are unbounded in the given variable.  <a href="#ab6b43de9c05b871379b0d3202502aba2">More...</a><br /></td></tr>
<tr class="separator:ab6b43de9c05b871379b0d3202502aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Meet and unification</h2></td></tr>
<tr class="memitem:a44f63f5eb912be0aadc2c1b9adf2e446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a44f63f5eb912be0aadc2c1b9adf2e446">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a44f63f5eb912be0aadc2c1b9adf2e446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and y.  <a href="#a44f63f5eb912be0aadc2c1b9adf2e446">More...</a><br /></td></tr>
<tr class="separator:a44f63f5eb912be0aadc2c1b9adf2e446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be640bf60bc7b8225414c907d8d4cfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4be640bf60bc7b8225414c907d8d4cfd">unify</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a4be640bf60bc7b8225414c907d8d4cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and y.  <a href="#a4be640bf60bc7b8225414c907d8d4cfd">More...</a><br /></td></tr>
<tr class="separator:a4be640bf60bc7b8225414c907d8d4cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8719578ff340f3a7b9cbbe8a42453aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aa8719578ff340f3a7b9cbbe8a42453aa">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const std::vector&lt; const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> * &gt; &amp;x)</td></tr>
<tr class="memdesc:aa8719578ff340f3a7b9cbbe8a42453aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of all abstract elements in x.  <a href="#aa8719578ff340f3a7b9cbbe8a42453aa">More...</a><br /></td></tr>
<tr class="separator:aa8719578ff340f3a7b9cbbe8a42453aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d193f78059bf9d6802c603d87295da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a45d193f78059bf9d6802c603d87295da">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> *const x[])</td></tr>
<tr class="memdesc:a45d193f78059bf9d6802c603d87295da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of all size abstract elements in x.  <a href="#a45d193f78059bf9d6802c603d87295da">More...</a><br /></td></tr>
<tr class="separator:a45d193f78059bf9d6802c603d87295da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5062866188ef07983092b0b4b9ae93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a3b5062866188ef07983092b0b4b9ae93">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a3b5062866188ef07983092b0b4b9ae93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and some linear constraints.  <a href="#a3b5062866188ef07983092b0b4b9ae93">More...</a><br /></td></tr>
<tr class="separator:a3b5062866188ef07983092b0b4b9ae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0210b50351ddb1addac5a4aeda3ee09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0210b50351ddb1addac5a4aeda3ee09e">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a0210b50351ddb1addac5a4aeda3ee09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and some arbitrary constraints.  <a href="#a0210b50351ddb1addac5a4aeda3ee09e">More...</a><br /></td></tr>
<tr class="separator:a0210b50351ddb1addac5a4aeda3ee09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66183c64324b8f3c45e4aed4a36edf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac66183c64324b8f3c45e4aed4a36edf6">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:ac66183c64324b8f3c45e4aed4a36edf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <a href="#ac66183c64324b8f3c45e4aed4a36edf6">More...</a><br /></td></tr>
<tr class="separator:ac66183c64324b8f3c45e4aed4a36edf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba32c363a51d9b2296a2470baabc93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a7bba32c363a51d9b2296a2470baabc93">unify</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a7bba32c363a51d9b2296a2470baabc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <a href="#a7bba32c363a51d9b2296a2470baabc93">More...</a><br /></td></tr>
<tr class="separator:a7bba32c363a51d9b2296a2470baabc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f208351d3d0530b623a9f3b34f7e8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a1f208351d3d0530b623a9f3b34f7e8f2">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a1f208351d3d0530b623a9f3b34f7e8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <a href="#a1f208351d3d0530b623a9f3b34f7e8f2">More...</a><br /></td></tr>
<tr class="separator:a1f208351d3d0530b623a9f3b34f7e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d59f85b165060b50fbbf3038a046e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a1d59f85b165060b50fbbf3038a046e3a">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a1d59f85b165060b50fbbf3038a046e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <a href="#a1d59f85b165060b50fbbf3038a046e3a">More...</a><br /></td></tr>
<tr class="separator:a1d59f85b165060b50fbbf3038a046e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093fc5d169435857bd03a6d10a81fc6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a093fc5d169435857bd03a6d10a81fc6e">operator *=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a093fc5d169435857bd03a6d10a81fc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <a href="#a093fc5d169435857bd03a6d10a81fc6e">More...</a><br /></td></tr>
<tr class="separator:a093fc5d169435857bd03a6d10a81fc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49689d9bf534f318cdc0829205899fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a49689d9bf534f318cdc0829205899fe8">operator *=</a> (const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a49689d9bf534f318cdc0829205899fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <a href="#a49689d9bf534f318cdc0829205899fe8">More...</a><br /></td></tr>
<tr class="separator:a49689d9bf534f318cdc0829205899fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc0915aa1141caa1ee1e635f650407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0bcc0915aa1141caa1ee1e635f650407">operator *=</a> (const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a0bcc0915aa1141caa1ee1e635f650407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <a href="#a0bcc0915aa1141caa1ee1e635f650407">More...</a><br /></td></tr>
<tr class="separator:a0bcc0915aa1141caa1ee1e635f650407"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Join</h2></td></tr>
<tr class="memitem:abb2db93d398555349574e1e283d25359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#abb2db93d398555349574e1e283d25359">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:abb2db93d398555349574e1e283d25359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the join of x and y.  <a href="#abb2db93d398555349574e1e283d25359">More...</a><br /></td></tr>
<tr class="separator:abb2db93d398555349574e1e283d25359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7890feaf409a470ed2a654a825e0200b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a7890feaf409a470ed2a654a825e0200b">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const std::vector&lt; const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> * &gt; &amp;x)</td></tr>
<tr class="memdesc:a7890feaf409a470ed2a654a825e0200b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the join of all abstract elements in x.  <a href="#a7890feaf409a470ed2a654a825e0200b">More...</a><br /></td></tr>
<tr class="separator:a7890feaf409a470ed2a654a825e0200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340317a2f4922f03d9102300f20226b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a340317a2f4922f03d9102300f20226b5">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> *const x[])</td></tr>
<tr class="memdesc:a340317a2f4922f03d9102300f20226b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the join of all size abstract elements in x.  <a href="#a340317a2f4922f03d9102300f20226b5">More...</a><br /></td></tr>
<tr class="separator:a340317a2f4922f03d9102300f20226b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945005f0ece004079ebb5f980520b0da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a945005f0ece004079ebb5f980520b0da">add_rays</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x, const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a945005f0ece004079ebb5f980520b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with x with some rays added.  <a href="#a945005f0ece004079ebb5f980520b0da">More...</a><br /></td></tr>
<tr class="separator:a945005f0ece004079ebb5f980520b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ab9b962e4506eb2745e1b50a1e065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a6b5ab9b962e4506eb2745e1b50a1e065">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a6b5ab9b962e4506eb2745e1b50a1e065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <a href="#a6b5ab9b962e4506eb2745e1b50a1e065">More...</a><br /></td></tr>
<tr class="separator:a6b5ab9b962e4506eb2745e1b50a1e065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809a572d2873b85474682ba1705803d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4809a572d2873b85474682ba1705803d">add_rays</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a4809a572d2873b85474682ba1705803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <a href="#a4809a572d2873b85474682ba1705803d">More...</a><br /></td></tr>
<tr class="separator:a4809a572d2873b85474682ba1705803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5f91cff8da6b26382dd0e02217fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a97e5f91cff8da6b26382dd0e02217fa9">operator+=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a97e5f91cff8da6b26382dd0e02217fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <a href="#a97e5f91cff8da6b26382dd0e02217fa9">More...</a><br /></td></tr>
<tr class="separator:a97e5f91cff8da6b26382dd0e02217fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d5a971376c585ba1c6668e771565e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac92d5a971376c585ba1c6668e771565e">operator+=</a> (const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;y)</td></tr>
<tr class="memdesc:ac92d5a971376c585ba1c6668e771565e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <a href="#ac92d5a971376c585ba1c6668e771565e">More...</a><br /></td></tr>
<tr class="separator:ac92d5a971376c585ba1c6668e771565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Assignment</h2></td></tr>
<tr class="memitem:a9216632eb20097167ab022183eadc883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a9216632eb20097167ab022183eadc883">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a9216632eb20097167ab022183eadc883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of linear expression.  <a href="#a9216632eb20097167ab022183eadc883">More...</a><br /></td></tr>
<tr class="separator:a9216632eb20097167ab022183eadc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea34f1ff046ea976c7bfa9c74588eaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#afea34f1ff046ea976c7bfa9c74588eaa">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:afea34f1ff046ea976c7bfa9c74588eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of linear expressions.  <a href="#afea34f1ff046ea976c7bfa9c74588eaa">More...</a><br /></td></tr>
<tr class="separator:afea34f1ff046ea976c7bfa9c74588eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b2137344b6e96fae8ed99f76e20ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a26b2137344b6e96fae8ed99f76e20ff2">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a26b2137344b6e96fae8ed99f76e20ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of linear expressions.  <a href="#a26b2137344b6e96fae8ed99f76e20ff2">More...</a><br /></td></tr>
<tr class="separator:a26b2137344b6e96fae8ed99f76e20ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b675a0d6fed700c7bc6c3c42bac4934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8b675a0d6fed700c7bc6c3c42bac4934">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a8b675a0d6fed700c7bc6c3c42bac4934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of arbitrary expression.  <a href="#a8b675a0d6fed700c7bc6c3c42bac4934">More...</a><br /></td></tr>
<tr class="separator:a8b675a0d6fed700c7bc6c3c42bac4934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a00b3183690f93227d2f89471faa82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ad9a00b3183690f93227d2f89471faa82">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:ad9a00b3183690f93227d2f89471faa82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of arbitrary expressions.  <a href="#ad9a00b3183690f93227d2f89471faa82">More...</a><br /></td></tr>
<tr class="separator:ad9a00b3183690f93227d2f89471faa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97806e5c3e525da80565c7faee3b9758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a97806e5c3e525da80565c7faee3b9758">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a97806e5c3e525da80565c7faee3b9758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of arbitrary expressions.  <a href="#a97806e5c3e525da80565c7faee3b9758">More...</a><br /></td></tr>
<tr class="separator:a97806e5c3e525da80565c7faee3b9758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefaa89c696a78322f38d8915b85d01f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#adefaa89c696a78322f38d8915b85d01f">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:adefaa89c696a78322f38d8915b85d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of linear expression.  <a href="#adefaa89c696a78322f38d8915b85d01f">More...</a><br /></td></tr>
<tr class="separator:adefaa89c696a78322f38d8915b85d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45449456d590a2be33c745454fedf450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a45449456d590a2be33c745454fedf450">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a45449456d590a2be33c745454fedf450"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <a href="#a45449456d590a2be33c745454fedf450">More...</a><br /></td></tr>
<tr class="separator:a45449456d590a2be33c745454fedf450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade55fc02c4d9d30565f1f40df28fae71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ade55fc02c4d9d30565f1f40df28fae71">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:ade55fc02c4d9d30565f1f40df28fae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <a href="#ade55fc02c4d9d30565f1f40df28fae71">More...</a><br /></td></tr>
<tr class="separator:ade55fc02c4d9d30565f1f40df28fae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363cf28bc555c7752fa3e5b4d9c637a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a363cf28bc555c7752fa3e5b4d9c637a6">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a363cf28bc555c7752fa3e5b4d9c637a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of arbitrary expression.  <a href="#a363cf28bc555c7752fa3e5b4d9c637a6">More...</a><br /></td></tr>
<tr class="separator:a363cf28bc555c7752fa3e5b4d9c637a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafa6754f4fe4a98c0fcce04941e308e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aeafa6754f4fe4a98c0fcce04941e308e">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:aeafa6754f4fe4a98c0fcce04941e308e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <a href="#aeafa6754f4fe4a98c0fcce04941e308e">More...</a><br /></td></tr>
<tr class="separator:aeafa6754f4fe4a98c0fcce04941e308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db493c1e07d652ffeffe740178d86e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a39db493c1e07d652ffeffe740178d86e">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a39db493c1e07d652ffeffe740178d86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <a href="#a39db493c1e07d652ffeffe740178d86e">More...</a><br /></td></tr>
<tr class="separator:a39db493c1e07d652ffeffe740178d86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Substitution</h2></td></tr>
<tr class="memitem:a75a44a16725fd527da0f03507907ffab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a75a44a16725fd527da0f03507907ffab">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a75a44a16725fd527da0f03507907ffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution (backward assignment) of linear expression.  <a href="#a75a44a16725fd527da0f03507907ffab">More...</a><br /></td></tr>
<tr class="separator:a75a44a16725fd527da0f03507907ffab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf56b3f93b8e1bff16951b8dc10d980f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aaf56b3f93b8e1bff16951b8dc10d980f">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:aaf56b3f93b8e1bff16951b8dc10d980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of linear expressions.  <a href="#aaf56b3f93b8e1bff16951b8dc10d980f">More...</a><br /></td></tr>
<tr class="separator:aaf56b3f93b8e1bff16951b8dc10d980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e421d1474ae3eca5216628a285c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a391e421d1474ae3eca5216628a285c73">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a391e421d1474ae3eca5216628a285c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of linear expressions.  <a href="#a391e421d1474ae3eca5216628a285c73">More...</a><br /></td></tr>
<tr class="separator:a391e421d1474ae3eca5216628a285c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1687bc3621188d0da37acc4ae44f3926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a1687bc3621188d0da37acc4ae44f3926">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a1687bc3621188d0da37acc4ae44f3926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution (backward assignment) of arbitrary expression.  <a href="#a1687bc3621188d0da37acc4ae44f3926">More...</a><br /></td></tr>
<tr class="separator:a1687bc3621188d0da37acc4ae44f3926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2850aa95529499a06ecb57c6b22ef118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a2850aa95529499a06ecb57c6b22ef118">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a2850aa95529499a06ecb57c6b22ef118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of arbitrary expressions.  <a href="#a2850aa95529499a06ecb57c6b22ef118">More...</a><br /></td></tr>
<tr class="separator:a2850aa95529499a06ecb57c6b22ef118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580aef3b17eecae1d18c31623358b5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a580aef3b17eecae1d18c31623358b5e3">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter)</td></tr>
<tr class="memdesc:a580aef3b17eecae1d18c31623358b5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of arbitrary expressions.  <a href="#a580aef3b17eecae1d18c31623358b5e3">More...</a><br /></td></tr>
<tr class="separator:a580aef3b17eecae1d18c31623358b5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9bfb3205075ca285475ab4548fe1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#abd9bfb3205075ca285475ab4548fe1c6">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:abd9bfb3205075ca285475ab4548fe1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of linear expression.  <a href="#abd9bfb3205075ca285475ab4548fe1c6">More...</a><br /></td></tr>
<tr class="separator:abd9bfb3205075ca285475ab4548fe1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07edcac85629fd85d50fd363346b9293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a07edcac85629fd85d50fd363346b9293">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a07edcac85629fd85d50fd363346b9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <a href="#a07edcac85629fd85d50fd363346b9293">More...</a><br /></td></tr>
<tr class="separator:a07edcac85629fd85d50fd363346b9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc7dd8a2be8c35e15dd521bd7108366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8dc7dd8a2be8c35e15dd521bd7108366">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a8dc7dd8a2be8c35e15dd521bd7108366"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <a href="#a8dc7dd8a2be8c35e15dd521bd7108366">More...</a><br /></td></tr>
<tr class="separator:a8dc7dd8a2be8c35e15dd521bd7108366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abb477a5de750b64a0cdeb15ac16eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a7abb477a5de750b64a0cdeb15ac16eb6">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a7abb477a5de750b64a0cdeb15ac16eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of arbitrary expression.  <a href="#a7abb477a5de750b64a0cdeb15ac16eb6">More...</a><br /></td></tr>
<tr class="separator:a7abb477a5de750b64a0cdeb15ac16eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69194fbdeeee01716af708f343d5c45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a69194fbdeeee01716af708f343d5c45d">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a69194fbdeeee01716af708f343d5c45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <a href="#a69194fbdeeee01716af708f343d5c45d">More...</a><br /></td></tr>
<tr class="separator:a69194fbdeeee01716af708f343d5c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f11c9ee32d3d8bae94db8c1b16eacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ad3f11c9ee32d3d8bae94db8c1b16eacc">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:ad3f11c9ee32d3d8bae94db8c1b16eacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <a href="#ad3f11c9ee32d3d8bae94db8c1b16eacc">More...</a><br /></td></tr>
<tr class="separator:ad3f11c9ee32d3d8bae94db8c1b16eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Projection, forget</h2></td></tr>
<tr class="memitem:a0abbafd7879edd77ed3cf11290538172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0abbafd7879edd77ed3cf11290538172">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, bool project)</td></tr>
<tr class="memdesc:a0abbafd7879edd77ed3cf11290538172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of forgetting the value of variable v in src.  <a href="#a0abbafd7879edd77ed3cf11290538172">More...</a><br /></td></tr>
<tr class="separator:a0abbafd7879edd77ed3cf11290538172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1687c9b4456fa601876959092c3d19d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ad1687c9b4456fa601876959092c3d19d">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], bool project)</td></tr>
<tr class="memdesc:ad1687c9b4456fa601876959092c3d19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of forgetting the value of variables v[0] to v[size-1] in src.  <a href="#ad1687c9b4456fa601876959092c3d19d">More...</a><br /></td></tr>
<tr class="separator:ad1687c9b4456fa601876959092c3d19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d79f7a8cb4fdd216ae024a1b0541a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a42d79f7a8cb4fdd216ae024a1b0541a9">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, bool project)</td></tr>
<tr class="memdesc:a42d79f7a8cb4fdd216ae024a1b0541a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of forgetting the value of all the variables in v in src.  <a href="#a42d79f7a8cb4fdd216ae024a1b0541a9">More...</a><br /></td></tr>
<tr class="separator:a42d79f7a8cb4fdd216ae024a1b0541a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c60db073b2014bc0c0b9896f7e62ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a57c60db073b2014bc0c0b9896f7e62ba">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, bool project=false)</td></tr>
<tr class="memdesc:a57c60db073b2014bc0c0b9896f7e62ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of variable v in *this.  <a href="#a57c60db073b2014bc0c0b9896f7e62ba">More...</a><br /></td></tr>
<tr class="separator:a57c60db073b2014bc0c0b9896f7e62ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f2df898fa4a9e0a906837f64e5838c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab6f2df898fa4a9e0a906837f64e5838c">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], bool project=false)</td></tr>
<tr class="memdesc:ab6f2df898fa4a9e0a906837f64e5838c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of variables v[0] to v[size-1] in *this.  <a href="#ab6f2df898fa4a9e0a906837f64e5838c">More...</a><br /></td></tr>
<tr class="separator:ab6f2df898fa4a9e0a906837f64e5838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8883f407224b2c73b6564c5047469ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8883f407224b2c73b6564c5047469ea1">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, bool project=false)</td></tr>
<tr class="memdesc:a8883f407224b2c73b6564c5047469ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of all the variables in v in *this.  <a href="#a8883f407224b2c73b6564c5047469ea1">More...</a><br /></td></tr>
<tr class="separator:a8883f407224b2c73b6564c5047469ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Change of environment</h2></td></tr>
<tr class="memitem:a49e5bd333e160ef9256f6638fee0cb1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a49e5bd333e160ef9256f6638fee0cb1e">change_environment</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, bool project)</td></tr>
<tr class="memdesc:a49e5bd333e160ef9256f6638fee0cb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with src and changes its environment.  <a href="#a49e5bd333e160ef9256f6638fee0cb1e">More...</a><br /></td></tr>
<tr class="separator:a49e5bd333e160ef9256f6638fee0cb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0247adc7cf1671b10c6e27c498a39a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac0247adc7cf1671b10c6e27c498a39a0">minimize_environment</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src)</td></tr>
<tr class="memdesc:ac0247adc7cf1671b10c6e27c498a39a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with src and removes the variables that are unconstrained.  <a href="#ac0247adc7cf1671b10c6e27c498a39a0">More...</a><br /></td></tr>
<tr class="separator:ac0247adc7cf1671b10c6e27c498a39a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5facd7c9b73ff54b7ea5bb449d93305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ae5facd7c9b73ff54b7ea5bb449d93305">rename</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> oldv[], const <a class="el" href="classapron_1_1var.html">var</a> newv[])</td></tr>
<tr class="memdesc:ae5facd7c9b73ff54b7ea5bb449d93305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with src and renames oldv[i] into newv[i].  <a href="#ae5facd7c9b73ff54b7ea5bb449d93305">More...</a><br /></td></tr>
<tr class="separator:ae5facd7c9b73ff54b7ea5bb449d93305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ddb5145d9a13329c018938a8792baf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ae9ddb5145d9a13329c018938a8792baf">rename</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;oldv, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;newv)</td></tr>
<tr class="memdesc:ae9ddb5145d9a13329c018938a8792baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with src and renames oldv[i] into newv[i].  <a href="#ae9ddb5145d9a13329c018938a8792baf">More...</a><br /></td></tr>
<tr class="separator:ae9ddb5145d9a13329c018938a8792baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e10aa035e1fbe030926757b8e5d0de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a04e10aa035e1fbe030926757b8e5d0de">change_environment</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, bool project=false)</td></tr>
<tr class="memdesc:a04e10aa035e1fbe030926757b8e5d0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the environment of *this.  <a href="#a04e10aa035e1fbe030926757b8e5d0de">More...</a><br /></td></tr>
<tr class="separator:a04e10aa035e1fbe030926757b8e5d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c6a58ec8f4091bbb52fe63a6ef9265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab3c6a58ec8f4091bbb52fe63a6ef9265">minimize_environment</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:ab3c6a58ec8f4091bbb52fe63a6ef9265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from *this the variables that are unconstrained.  <a href="#ab3c6a58ec8f4091bbb52fe63a6ef9265">More...</a><br /></td></tr>
<tr class="separator:ab3c6a58ec8f4091bbb52fe63a6ef9265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c817108ac1d6a9cae53a4b91577d65f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a8c817108ac1d6a9cae53a4b91577d65f">rename</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> oldv[], const <a class="el" href="classapron_1_1var.html">var</a> newv[])</td></tr>
<tr class="memdesc:a8c817108ac1d6a9cae53a4b91577d65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames oldv[i] into newv[i] in *this.  <a href="#a8c817108ac1d6a9cae53a4b91577d65f">More...</a><br /></td></tr>
<tr class="separator:a8c817108ac1d6a9cae53a4b91577d65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad827bf6e32b6e6a9f5990ddb3a6429a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ad827bf6e32b6e6a9f5990ddb3a6429a9">rename</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;oldv, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;newv)</td></tr>
<tr class="memdesc:ad827bf6e32b6e6a9f5990ddb3a6429a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames oldv[i] into newv[i] in *this.  <a href="#ad827bf6e32b6e6a9f5990ddb3a6429a9">More...</a><br /></td></tr>
<tr class="separator:ad827bf6e32b6e6a9f5990ddb3a6429a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Expansion and folding</h2></td></tr>
<tr class="memitem:ac798aba79b35406712220cf2bcebc34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac798aba79b35406712220cf2bcebc34a">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> vv[])</td></tr>
<tr class="memdesc:ac798aba79b35406712220cf2bcebc34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and duplicates variable v into size copies.  <a href="#ac798aba79b35406712220cf2bcebc34a">More...</a><br /></td></tr>
<tr class="separator:ac798aba79b35406712220cf2bcebc34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af6ad59f731eaf35d31898aa3e866fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a2af6ad59f731eaf35d31898aa3e866fd">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;vv)</td></tr>
<tr class="memdesc:a2af6ad59f731eaf35d31898aa3e866fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and duplicates variable v.  <a href="#a2af6ad59f731eaf35d31898aa3e866fd">More...</a><br /></td></tr>
<tr class="separator:a2af6ad59f731eaf35d31898aa3e866fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce03682dcc386288e197ba23e1615fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a4ce03682dcc386288e197ba23e1615fd">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[])</td></tr>
<tr class="memdesc:a4ce03682dcc386288e197ba23e1615fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and folds variables v[0] to v[size-1].  <a href="#a4ce03682dcc386288e197ba23e1615fd">More...</a><br /></td></tr>
<tr class="separator:a4ce03682dcc386288e197ba23e1615fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d56426a8a2c45cabfd17c7da98dbd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a0d56426a8a2c45cabfd17c7da98dbd17">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a0d56426a8a2c45cabfd17c7da98dbd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and folds all variables in v.  <a href="#a0d56426a8a2c45cabfd17c7da98dbd17">More...</a><br /></td></tr>
<tr class="separator:a0d56426a8a2c45cabfd17c7da98dbd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab453cfeb32b2a13ecdc877709852ddcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab453cfeb32b2a13ecdc877709852ddcb">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> vv[])</td></tr>
<tr class="memdesc:ab453cfeb32b2a13ecdc877709852ddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates variable v into size copies in *this (modified in-place).  <a href="#ab453cfeb32b2a13ecdc877709852ddcb">More...</a><br /></td></tr>
<tr class="separator:ab453cfeb32b2a13ecdc877709852ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aaabc3ffa391ade9cccd9ba722e76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ac6aaabc3ffa391ade9cccd9ba722e76a">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;vv)</td></tr>
<tr class="memdesc:ac6aaabc3ffa391ade9cccd9ba722e76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates variable v in *this (modified in-place).  <a href="#ac6aaabc3ffa391ade9cccd9ba722e76a">More...</a><br /></td></tr>
<tr class="separator:ac6aaabc3ffa391ade9cccd9ba722e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467674d5fa94396b70d063df2c681cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a467674d5fa94396b70d063df2c681cd2">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract1.html#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[])</td></tr>
<tr class="memdesc:a467674d5fa94396b70d063df2c681cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds variables v[0] to v[size-1] in *this (modified in-place).  <a href="#a467674d5fa94396b70d063df2c681cd2">More...</a><br /></td></tr>
<tr class="separator:a467674d5fa94396b70d063df2c681cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab051c409c69c5e56f50cdfb4939c7918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#ab051c409c69c5e56f50cdfb4939c7918">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ab051c409c69c5e56f50cdfb4939c7918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds all variables v in *this (modified in-place).  <a href="#ab051c409c69c5e56f50cdfb4939c7918">More...</a><br /></td></tr>
<tr class="separator:ab051c409c69c5e56f50cdfb4939c7918"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Closure</h2></td></tr>
<tr class="memitem:a264a47c60f4a2ed76d09c690737e7df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#a264a47c60f4a2ed76d09c690737e7df1">closure</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;dst, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;src)</td></tr>
<tr class="memdesc:a264a47c60f4a2ed76d09c690737e7df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the topological closure of src.  <a href="#a264a47c60f4a2ed76d09c690737e7df1">More...</a><br /></td></tr>
<tr class="separator:a264a47c60f4a2ed76d09c690737e7df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f5c128921fd8bde7596852cf15715a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract1.html#aa4f5c128921fd8bde7596852cf15715a">closure</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:aa4f5c128921fd8bde7596852cf15715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with its topological closure.  <a href="#aa4f5c128921fd8bde7596852cf15715a">More...</a><br /></td></tr>
<tr class="separator:aa4f5c128921fd8bde7596852cf15715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Level 1 abstract value (ap_abstract1_t wrapper). </p>
<p>Level 1 version of abstract values. Variable names (var) are used in place of dimensions (ap_dim_t). Internally, an <a class="el" href="classapron_1_1abstract1.html" title="Level 1 abstract value (ap_abstract1_t wrapper).">abstract1</a> wraps together an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> (memory managed) and an environment (holding a reference count). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae9f85047c9ca23a39f505c1f4fbcff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f85047c9ca23a39f505c1f4fbcff3d">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype">ap_abstract1_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. Shallow copy of structure. </p>

</div>
</div>
<a id="a04607bc2854b93283cd1994db4c4dbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04607bc2854b93283cd1994db4c4dbf6">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the whole space. </p>

</div>
</div>
<a id="afd708dc2f4446bafea3d17e291f33af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd708dc2f4446bafea3d17e291f33af1">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the empty set. </p>

</div>
</div>
<a id="a5024cf04cdd6fe3fba1e97534893ae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5024cf04cdd6fe3fba1e97534893ae41">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>

</div>
</div>
<a id="a06bc49a6b2b019a776860c266c94add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bc49a6b2b019a776860c266c94add2">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element and associates an environment (reference count incremented). </p>

</div>
</div>
<a id="a17a47774aefe36f6de2306ba55983bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a47774aefe36f6de2306ba55983bb2">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a box. </p>
<p>x[i] is the bound for the variable v[i]. Variables not in v have unconstrained bounds. </p>

</div>
</div>
<a id="abe83b8f8e90be8f60f6a743a4e920060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe83b8f8e90be8f60f6a743a4e920060">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a box. </p>
<p>x[i] is the bound for all the variables in v. Variables not in v have unconstrained bounds. </p>

</div>
</div>
<a id="a4af38a4b59e58b87104a70d88ac044f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af38a4b59e58b87104a70d88ac044f9">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of linear constraints. </p>

</div>
</div>
<a id="ae78a788ac56604363ee6df87f1db8440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78a788ac56604363ee6df87f1db8440">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of arbitrary constraints. </p>

</div>
</div>
<a id="a4e5578abd8e6f47364d58d8f06a8dc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5578abd8e6f47364d58d8f06a8dc6c">&#9670;&nbsp;</a></span>abstract1() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a4f3e5e486b1a2139208b58b424418fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e5e486b1a2139208b58b424418fd8">&#9670;&nbsp;</a></span>~abstract1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::~abstract1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4809a572d2873b85474682ba1705803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4809a572d2873b85474682ba1705803d">&#9670;&nbsp;</a></span>add_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::add_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a994069657f16633ba0e4c7c23e0468c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994069657f16633ba0e4c7c23e0468c3">&#9670;&nbsp;</a></span>approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::approximate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies the abstract element, potentially loosing precision. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="adefaa89c696a78322f38d8915b85d01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefaa89c696a78322f38d8915b85d01f">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of linear expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a45449456d590a2be33c745454fedf450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45449456d590a2be33c745454fedf450">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ade55fc02c4d9d30565f1f40df28fae71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade55fc02c4d9d30565f1f40df28fae71">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a363cf28bc555c7752fa3e5b4d9c637a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363cf28bc555c7752fa3e5b4d9c637a6">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aeafa6754f4fe4a98c0fcce04941e308e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafa6754f4fe4a98c0fcce04941e308e">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a39db493c1e07d652ffeffe740178d86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39db493c1e07d652ffeffe740178d86e">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339115b7d3b039cf6a379615fc8554ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339115b7d3b039cf6a379615fc8554ba">&#9670;&nbsp;</a></span>bound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract1::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for a linear expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="a93d74bc2e81e8383ae45d0a129046d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d74bc2e81e8383ae45d0a129046d8a">&#9670;&nbsp;</a></span>bound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract1::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for an arbitrary expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="af443a713ff2704f78988a5eaf5cc675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443a713ff2704f78988a5eaf5cc675c">&#9670;&nbsp;</a></span>bound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> apron::abstract1::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for the given variable on all points in the abstract element. </p>

</div>
</div>
<a id="a3ad5bdefc0b48a13f839de77a97868f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5bdefc0b48a13f839de77a97868f6">&#9670;&nbsp;</a></span>canonicalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the abstract element in canonical form (if such a notion exists). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a04e10aa035e1fbe030926757b8e5d0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e10aa035e1fbe030926757b8e5d0de">&#9670;&nbsp;</a></span>change_environment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::change_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the environment of *this. </p>
<ul>
<li><code>project</code> whether new variables are initialized to 0 (if true), or undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa4f5c128921fd8bde7596852cf15715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f5c128921fd8bde7596852cf15715a">&#9670;&nbsp;</a></span>closure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with its topological closure. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac1099828d0c5158a868be70002375d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1099828d0c5158a868be70002375d16">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract1::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em> = <code>stdout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw printing to a C stream (mainly for debug purposes). </p>

</div>
</div>
<a id="ab453cfeb32b2a13ecdc877709852ddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab453cfeb32b2a13ecdc877709852ddcb">&#9670;&nbsp;</a></span>expand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>vv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates variable v into size copies in *this (modified in-place). </p>
<p>New variables are named vv[0] to vv[size-1].</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac6aaabc3ffa391ade9cccd9ba722e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aaabc3ffa391ade9cccd9ba722e76a">&#9670;&nbsp;</a></span>expand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates variable v in *this (modified in-place). </p>
<p>The i-th new variable is named vv[i].</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a467674d5fa94396b70d063df2c681cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467674d5fa94396b70d063df2c681cd2">&#9670;&nbsp;</a></span>fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds variables v[0] to v[size-1] in *this (modified in-place). </p>
<p>After folding, only v[0] is kept and other variables are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab051c409c69c5e56f50cdfb4939c7918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab051c409c69c5e56f50cdfb4939c7918">&#9670;&nbsp;</a></span>fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds all variables v in *this (modified in-place). </p>
<p>After folding, only v[0] is kept and other variables are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a57c60db073b2014bc0c0b9896f7e62ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c60db073b2014bc0c0b9896f7e62ba">&#9670;&nbsp;</a></span>forget() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of variable v in *this. </p>
<ul>
<li><code>project</code> whether to reset the variable to 0 (if true), or leave it undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab6f2df898fa4a9e0a906837f64e5838c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f2df898fa4a9e0a906837f64e5838c">&#9670;&nbsp;</a></span>forget() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of variables v[0] to v[size-1] in *this. </p>
<ul>
<li><code>project</code> whether to reset the variables to 0 (if true), or it them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a8883f407224b2c73b6564c5047469ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8883f407224b2c73b6564c5047469ea1">&#9670;&nbsp;</a></span>forget() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of all the variables in v in *this. </p>
<ul>
<li><code>project</code> whether to reset the variables to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="af1b80374409c75e5d1f3b4d1e91141ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b80374409c75e5d1f3b4d1e91141ad">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract1::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element using the given manager. </p>
<p>The abstract element cannot be used after being freed. However, the standard destructor can be safely be called (resulting in a no-op). </p>

</div>
</div>
<a id="a9c80db7b903cece05706bdea3905bc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c80db7b903cece05706bdea3905bc3d">&#9670;&nbsp;</a></span>get_abstract0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract1::get_abstract0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a (modifiable) reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>. </p>

</div>
</div>
<a id="a3cf571fc535416273d6e7cd51893e7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf571fc535416273d6e7cd51893e7fd">&#9670;&nbsp;</a></span>get_abstract0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract1::get_abstract0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>. </p>

</div>
</div>
<a id="aa11fa5ba8fa8a0754853548eacce5712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11fa5ba8fa8a0754853548eacce5712">&#9670;&nbsp;</a></span>get_ap_abstract1_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract1_t * abstract1::get_ap_abstract1_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="aab0f23035e10c9f05527cbd9c4259232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0f23035e10c9f05527cbd9c4259232">&#9670;&nbsp;</a></span>get_ap_abstract1_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ap_abstract1_t * abstract1::get_ap_abstract1_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="a106bdd4530d40b49082f636c517fd565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106bdd4530d40b49082f636c517fd565">&#9670;&nbsp;</a></span>get_environment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1environment.html">environment</a> abstract1::get_environment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the environment of the abstract element (with reference count incremented). </p>

</div>
</div>
<a id="a76b2862115aa5fbd87175686e493c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b2862115aa5fbd87175686e493c481">&#9670;&nbsp;</a></span>get_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1manager.html">manager</a> abstract1::get_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the manager the abstract element was created with (with reference count incremented). </p>

</div>
</div>
<a id="a70523104c8b0ed2932d1a1a597411a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70523104c8b0ed2932d1a1a597411a13">&#9670;&nbsp;</a></span>is_bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the empty set. </p>

</div>
</div>
<a id="a79e49f9930afa4abc377451cac1b4214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e49f9930afa4abc377451cac1b4214">&#9670;&nbsp;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this and x represent the same set. </p>

</div>
</div>
<a id="a86b10bd15959cf97dbc219dc6db572ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b10bd15959cf97dbc219dc6db572ca">&#9670;&nbsp;</a></span>is_leq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_leq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this is included in x (set-wise). </p>

</div>
</div>
<a id="adf4c586d48871a8b35e3c2d1715152ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4c586d48871a8b35e3c2d1715152ec">&#9670;&nbsp;</a></span>is_top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the full space. </p>

</div>
</div>
<a id="ab6b43de9c05b871379b0d3202502aba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b43de9c05b871379b0d3202502aba2">&#9670;&nbsp;</a></span>is_variable_unconstrained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_variable_unconstrained </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the points in *this are unbounded in the given variable. </p>

</div>
</div>
<a id="a6b5ab9b962e4506eb2745e1b50a1e065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5ab9b962e4506eb2745e1b50a1e065">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac66183c64324b8f3c45e4aed4a36edf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66183c64324b8f3c45e4aed4a36edf6">&#9670;&nbsp;</a></span>meet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1f208351d3d0530b623a9f3b34f7e8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f208351d3d0530b623a9f3b34f7e8f2">&#9670;&nbsp;</a></span>meet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1d59f85b165060b50fbbf3038a046e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d59f85b165060b50fbbf3038a046e3a">&#9670;&nbsp;</a></span>meet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ad800ae88efb344abe032bf85cdac3b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad800ae88efb344abe032bf85cdac3b68">&#9670;&nbsp;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimizes the size of the representation, to save memory. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab3c6a58ec8f4091bbb52fe63a6ef9265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c6a58ec8f4091bbb52fe63a6ef9265">&#9670;&nbsp;</a></span>minimize_environment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::minimize_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from *this the variables that are unconstrained. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a093fc5d169435857bd03a6d10a81fc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093fc5d169435857bd03a6d10a81fc6e">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a49689d9bf534f318cdc0829205899fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49689d9bf534f318cdc0829205899fe8">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a0bcc0915aa1141caa1ee1e635f650407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcc0915aa1141caa1ee1e635f650407">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a97e5f91cff8da6b26382dd0e02217fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5f91cff8da6b26382dd0e02217fa9">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac92d5a971376c585ba1c6668e771565e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92d5a971376c585ba1c6668e771565e">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa3eddc65033da59f2b8e3da88017d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3eddc65033da59f2b8e3da88017d4c4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a copy of t to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a0f7fd4292a248506462e5f75534896bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7fd4292a248506462e5f75534896bc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the full space to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a01d4d3d989bc573422ace03218c96beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d4d3d989bc573422ace03218c96beb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the empty set to *this. </p>
<p>Implicitly uses the manager used to create *this. Does not change the environment. </p>

</div>
</div>
<a id="ab8592168b29edfe3d00fe264c26a2efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8592168b29edfe3d00fe264c26a2efd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a box to *this. </p>
<p>Implicitly uses the manager used to create *this. Does not change the environment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the array has insufficient size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ab47317ca450263be9b245b3007016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab47317ca450263be9b245b3007016f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of linear constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. Does not change the environment. </p>

</div>
</div>
<a id="a84a13b1d97a69bb39a2a9da3eb055435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a13b1d97a69bb39a2a9da3eb055435">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of arbitrary constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a8fc976840805ce49fdc62efddceb53bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc976840805ce49fdc62efddceb53bd">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract1::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em> = <code>stdout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty-printing to a C stream. </p>

</div>
</div>
<a id="a8c817108ac1d6a9cae53a4b91577d65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c817108ac1d6a9cae53a4b91577d65f">&#9670;&nbsp;</a></span>rename() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>oldv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>newv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames oldv[i] into newv[i] in *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ad827bf6e32b6e6a9f5990ddb3a6429a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad827bf6e32b6e6a9f5990ddb3a6429a9">&#9670;&nbsp;</a></span>rename() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames oldv[i] into newv[i] in *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a74ef4e577b8dbfff9ddcb16b9393dba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef4e577b8dbfff9ddcb16b9393dba4">&#9670;&nbsp;</a></span>sat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1.html">lincons1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy a linear constraint. </p>

</div>
</div>
<a id="a855ee58954b223c77cc9b2efa21dd31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855ee58954b223c77cc9b2efa21dd31e">&#9670;&nbsp;</a></span>sat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1.html">tcons1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy an arbitrary constraint. </p>

</div>
</div>
<a id="a1f4f19c3e1dd25a092294a97680650f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4f19c3e1dd25a092294a97680650f9">&#9670;&nbsp;</a></span>sat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the component v of all points in *this is included in the given interval. </p>

</div>
</div>
<a id="a9f2d927f165d9b4c323adbba6f571578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2d927f165d9b4c323adbba6f571578">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string * abstract1::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes an abstract element. </p>
<p>The string can be safely stored to disk and reloaded later or transmitted across a network. The format is library-specific but is generally a machine-readable byte-stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated string that the caller should delete it after use. </dd></dl>

</div>
</div>
<a id="a91393622e71700a39c71380c6bf2720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91393622e71700a39c71380c6bf2720d">&#9670;&nbsp;</a></span>set() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a copy of x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a3dd9d86948de72a842493e3abed86294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd9d86948de72a842493e3abed86294">&#9670;&nbsp;</a></span>set() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the full space. </p>
<p>Does not change the environment.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aec7c7c0de689b9d4b27b032a4d8e8333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7c7c0de689b9d4b27b032a4d8e8333">&#9670;&nbsp;</a></span>set() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the full space. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="afbdae15c48b20cb1e76ec5c33f7a78a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdae15c48b20cb1e76ec5c33f7a78a9">&#9670;&nbsp;</a></span>set() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the empty set. </p>
<p>Does not change the environment.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a42a76d3271d0392280af8ff54b92b6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a76d3271d0392280af8ff54b92b6df">&#9670;&nbsp;</a></span>set() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the empty set. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa189dcc451d213fd2f0c562619f840f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa189dcc451d213fd2f0c562619f840f6">&#9670;&nbsp;</a></span>set() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<p>Does not change the environment.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a7c65658443862e2a490c5cbb450fe613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65658443862e2a490c5cbb450fe613">&#9670;&nbsp;</a></span>set() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a9d068a7df8f1190bcd028543d045bdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d068a7df8f1190bcd028543d045bdc8">&#9670;&nbsp;</a></span>set() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a253431f62f1a765051f6a7288f51855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253431f62f1a765051f6a7288f51855a">&#9670;&nbsp;</a></span>set() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of linear constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a91fa2f49b715da57bc50a5e65b986f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fa2f49b715da57bc50a5e65b986f6f">&#9670;&nbsp;</a></span>set() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of arbitrary constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a0d7978d6548967192d3be35131828776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7978d6548967192d3be35131828776">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t abstract1::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (abstract) size of the abstract element. </p>
<p>The unit in which size is computed is library-specific. It is guaranteed to be the same as the unit for the <code>max_object_size</code> field of the ap_funopt_t structure. </p>

</div>
</div>
<a id="abd9bfb3205075ca285475ab4548fe1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9bfb3205075ca285475ab4548fe1c6">&#9670;&nbsp;</a></span>substitute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of linear expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a07edcac85629fd85d50fd363346b9293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07edcac85629fd85d50fd363346b9293">&#9670;&nbsp;</a></span>substitute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a8dc7dd8a2be8c35e15dd521bd7108366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc7dd8a2be8c35e15dd521bd7108366">&#9670;&nbsp;</a></span>substitute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abb477a5de750b64a0cdeb15ac16eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abb477a5de750b64a0cdeb15ac16eb6">&#9670;&nbsp;</a></span>substitute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a69194fbdeeee01716af708f343d5c45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69194fbdeeee01716af708f343d5c45d">&#9670;&nbsp;</a></span>substitute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ad3f11c9ee32d3d8bae94db8c1b16eacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f11c9ee32d3d8bae94db8c1b16eacc">&#9670;&nbsp;</a></span>substitute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61426b2c51ea83f90ff7863cebc34cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61426b2c51ea83f90ff7863cebc34cfb">&#9670;&nbsp;</a></span>to_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval__array.html">interval_array</a> abstract1::to_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bounding box for the set represented by the abstract element. </p>

</div>
</div>
<a id="a69339cb2be90a806bec2b6e674b2058d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69339cb2be90a806bec2b6e674b2058d">&#9670;&nbsp;</a></span>to_generator_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> abstract1::to_generator_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a generator representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="afdef105472739af42c8a7f90389db29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdef105472739af42c8a7f90389db29c">&#9670;&nbsp;</a></span>to_lincons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> abstract1::to_lincons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="ab944dee440aaf0c3ce4b6c1cbd83050c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab944dee440aaf0c3ce4b6c1cbd83050c">&#9670;&nbsp;</a></span>to_tcons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> abstract1::to_tcons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="a7bba32c363a51d9b2296a2470baabc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bba32c363a51d9b2296a2470baabc93">&#9670;&nbsp;</a></span>unify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::unify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<p>*this and y can have different environment. They are first embedded into the least common environment before the meet is computed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a945005f0ece004079ebb5f980520b0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945005f0ece004079ebb5f980520b0da">&#9670;&nbsp;</a></span>add_rays</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; add_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with x with some rays added. </p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a9216632eb20097167ab022183eadc883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9216632eb20097167ab022183eadc883">&#9670;&nbsp;</a></span>assign <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of linear expression. </p>
<p>dst is replaced with the effect of assigning l to variable v in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="afea34f1ff046ea976c7bfa9c74588eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea34f1ff046ea976c7bfa9c74588eaa">&#9670;&nbsp;</a></span>assign <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of linear expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to variable v[i] in src, for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a26b2137344b6e96fae8ed99f76e20ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b2137344b6e96fae8ed99f76e20ff2">&#9670;&nbsp;</a></span>assign <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of linear expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to variable v[i] in src. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b675a0d6fed700c7bc6c3c42bac4934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b675a0d6fed700c7bc6c3c42bac4934">&#9670;&nbsp;</a></span>assign <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of arbitrary expression. </p>
<p>dst is replaced with the effect of assigning l to variable v in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ad9a00b3183690f93227d2f89471faa82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a00b3183690f93227d2f89471faa82">&#9670;&nbsp;</a></span>assign <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of arbitrary expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to variable v[i] in src, for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a97806e5c3e525da80565c7faee3b9758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97806e5c3e525da80565c7faee3b9758">&#9670;&nbsp;</a></span>assign <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of arbitrary expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to variable v[i] in src. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49e5bd333e160ef9256f6638fee0cb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e5bd333e160ef9256f6638fee0cb1e">&#9670;&nbsp;</a></span>change_environment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; change_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with src and changes its environment. </p>
<ul>
<li><code>project</code> whether new variables are initialized to 0 (if true), or undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a264a47c60f4a2ed76d09c690737e7df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264a47c60f4a2ed76d09c690737e7df1">&#9670;&nbsp;</a></span>closure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the topological closure of src. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a707d5cdf65b64cfcb89140a2b709e986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707d5cdf65b64cfcb89140a2b709e986">&#9670;&nbsp;</a></span>deserialize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>eaten</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstruct an abstract element form a serialized byte-stream and put it into dst. </p>
<p>The managers used to serialized and deserialize need not be the same, but they must have been created using the same library and with the same arguments.</p>
<ul>
<li><code>eaten</code>, if not NULL, will be set to the actual number of bytes consumed from the string. <dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ac798aba79b35406712220cf2bcebc34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac798aba79b35406712220cf2bcebc34a">&#9670;&nbsp;</a></span>expand <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>vv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and duplicates variable v into size copies. </p>
<p>New variables are named vv[0] to vv[size-1].</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a2af6ad59f731eaf35d31898aa3e866fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af6ad59f731eaf35d31898aa3e866fd">&#9670;&nbsp;</a></span>expand <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and duplicates variable v. </p>
<p>The i-th new variables is named vv[i].</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a4ce03682dcc386288e197ba23e1615fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce03682dcc386288e197ba23e1615fd">&#9670;&nbsp;</a></span>fold <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and folds variables v[0] to v[size-1]. </p>
<p>After folding, only v[0] is kept and other variables are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a0d56426a8a2c45cabfd17c7da98dbd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d56426a8a2c45cabfd17c7da98dbd17">&#9670;&nbsp;</a></span>fold <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and folds all variables in v. </p>
<p>After folding, only v[0] is kept and other variables are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a0abbafd7879edd77ed3cf11290538172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abbafd7879edd77ed3cf11290538172">&#9670;&nbsp;</a></span>forget <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of forgetting the value of variable v in src. </p>
<ul>
<li><code>project</code> if true, resets the variable to 0 (if true).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ad1687c9b4456fa601876959092c3d19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1687c9b4456fa601876959092c3d19d">&#9670;&nbsp;</a></span>forget <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of forgetting the value of variables v[0] to v[size-1] in src. </p>
<ul>
<li><code>project</code> whether to reset the variables to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a42d79f7a8cb4fdd216ae024a1b0541a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d79f7a8cb4fdd216ae024a1b0541a9">&#9670;&nbsp;</a></span>forget <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of forgetting the value of all the variables in v in src. </p>
<ul>
<li><code>project</code> whether to reset the variables to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="abb2db93d398555349574e1e283d25359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2db93d398555349574e1e283d25359">&#9670;&nbsp;</a></span>join <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the join of x and y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a7890feaf409a470ed2a654a825e0200b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7890feaf409a470ed2a654a825e0200b">&#9670;&nbsp;</a></span>join <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the join of all abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a340317a2f4922f03d9102300f20226b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340317a2f4922f03d9102300f20226b5">&#9670;&nbsp;</a></span>join <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> *const&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the join of all size abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a44f63f5eb912be0aadc2c1b9adf2e446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f63f5eb912be0aadc2c1b9adf2e446">&#9670;&nbsp;</a></span>meet <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="aa8719578ff340f3a7b9cbbe8a42453aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8719578ff340f3a7b9cbbe8a42453aa">&#9670;&nbsp;</a></span>meet <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of all abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a45d193f78059bf9d6802c603d87295da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d193f78059bf9d6802c603d87295da">&#9670;&nbsp;</a></span>meet <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> *const&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of all size abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a3b5062866188ef07983092b0b4b9ae93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5062866188ef07983092b0b4b9ae93">&#9670;&nbsp;</a></span>meet <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and some linear constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a0210b50351ddb1addac5a4aeda3ee09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0210b50351ddb1addac5a4aeda3ee09e">&#9670;&nbsp;</a></span>meet <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and some arbitrary constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ac0247adc7cf1671b10c6e27c498a39a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0247adc7cf1671b10c6e27c498a39a0">&#9670;&nbsp;</a></span>minimize_environment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; minimize_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with src and removes the variables that are unconstrained. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a4a239822c50f0d34340cad01d2f5811d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a239822c50f0d34340cad01d2f5811d">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceapron.html#aa74e2a030ba8a4a51298a020518860e7">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x and y represent different sets. </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a648c6062222f356dd99a55bc8cb57259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648c6062222f356dd99a55bc8cb57259">&#9670;&nbsp;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x is strictly included within y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a0ce982025627a24429badae940664c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce982025627a24429badae940664c47">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints in constraint form. </p>

</div>
</div>
<a id="a8c28711a43d4f292157d16de13c4da90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c28711a43d4f292157d16de13c4da90">&#9670;&nbsp;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x is included within y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="af2b16244f41df68b9e8f2647bdaf30b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b16244f41df68b9e8f2647bdaf30b4">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x and y represent the same set. </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="ab96871c98bdc0fa565648fae51e8368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96871c98bdc0fa565648fae51e8368f">&#9670;&nbsp;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x strictly contains y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="ab71bffbef0e3d7b7f8a8106f937ddb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71bffbef0e3d7b7f8a8106f937ddb94">&#9670;&nbsp;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x contains y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="ada8dff0f3827b740fec81a35dd68bdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8dff0f3827b740fec81a35dd68bdb5">&#9670;&nbsp;</a></span>printdiff</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void printdiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em> = <code>stdout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty-printing the difference between x and y to a C stream. </p>

</div>
</div>
<a id="ae5facd7c9b73ff54b7ea5bb449d93305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5facd7c9b73ff54b7ea5bb449d93305">&#9670;&nbsp;</a></span>rename <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>oldv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>newv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with src and renames oldv[i] into newv[i]. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ae9ddb5145d9a13329c018938a8792baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ddb5145d9a13329c018938a8792baf">&#9670;&nbsp;</a></span>rename <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with src and renames oldv[i] into newv[i]. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a75a44a16725fd527da0f03507907ffab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a44a16725fd527da0f03507907ffab">&#9670;&nbsp;</a></span>substitute <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution (backward assignment) of linear expression. </p>
<p>dst is replaced with the effect of substituting l to variable v in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="aaf56b3f93b8e1bff16951b8dc10d980f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf56b3f93b8e1bff16951b8dc10d980f">&#9670;&nbsp;</a></span>substitute <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of linear expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to variable v[i] in src, for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a391e421d1474ae3eca5216628a285c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391e421d1474ae3eca5216628a285c73">&#9670;&nbsp;</a></span>substitute <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of linear expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to variable v[i] in src. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1687bc3621188d0da37acc4ae44f3926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1687bc3621188d0da37acc4ae44f3926">&#9670;&nbsp;</a></span>substitute <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution (backward assignment) of arbitrary expression. </p>
<p>dst is replaced with the effect of substituting l to variable v in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a2850aa95529499a06ecb57c6b22ef118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2850aa95529499a06ecb57c6b22ef118">&#9670;&nbsp;</a></span>substitute <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a>&#160;</td>
          <td class="paramname"><em>v</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to variable v[i] in src, for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a580aef3b17eecae1d18c31623358b5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580aef3b17eecae1d18c31623358b5e3">&#9670;&nbsp;</a></span>substitute <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract1.html#a3994902b1385eef6523d2f7b6e61f86c">abstract1::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to variable v[i] in src. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4be640bf60bc7b8225414c907d8d4cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be640bf60bc7b8225414c907d8d4cfd">&#9670;&nbsp;</a></span>unify</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; unify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and y. </p>
<p>x and y can have different environment. They are first embedded into the least common environment before the meet is computed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a555cf295c88001577220bf1bce7b337d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555cf295c88001577220bf1bce7b337d">&#9670;&nbsp;</a></span>widening <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; widening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of x widened with y. </p>
<dl class="section warning"><dt>Warning</dt><dd>y must be a superset of x.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a24322bfe2d2537c1764a94347c17431d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24322bfe2d2537c1764a94347c17431d">&#9670;&nbsp;</a></span>widening <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a>&amp; widening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of x widened with y, using some widening thresholds. </p>
<dl class="section warning"><dt>Warning</dt><dd>y must be a superset of x.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac46e4c0ba148a29a83394974350cd6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46e4c0ba148a29a83394974350cd6d2">&#9670;&nbsp;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract1_t apron::abstract1::a</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Structure managed by APRON. </p>

</div>
</div>
<a id="a3994902b1385eef6523d2f7b6e61f86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3994902b1385eef6523d2f7b6e61f86c">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> apron::abstract1::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NULL abstract element, to be used only as default argument in assign and substitute. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract1_8hh_source.html">apxx_abstract1.hh</a></li>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract1__inline_8hh_source.html">apxx_abstract1_inline.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 10 2019 10:49:09 for APRONXX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
