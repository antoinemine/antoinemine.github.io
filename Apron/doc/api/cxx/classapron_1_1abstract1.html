<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APRONXX: apron::abstract1 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">APRONXX<span id="projectnumber">&#160;0.9.15</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceapron.html">apron</a></li><li class="navelem"><a class="el" href="classapron_1_1abstract1.html">abstract1</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classapron_1_1abstract1-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">apron::abstract1 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Level 1 abstract value (ap_abstract1_t wrapper).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="apxx__abstract1_8hh_source.html">apxx_abstract1.hh</a>&gt;</code></p>

<p>Inherits <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a04607bc2854b93283cd1994db4c4dbf6" id="r_a04607bc2854b93283cd1994db4c4dbf6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04607bc2854b93283cd1994db4c4dbf6">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1top.html">top</a> x)</td></tr>
<tr class="memdesc:a04607bc2854b93283cd1994db4c4dbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the whole space.  <br /></td></tr>
<tr class="separator:a04607bc2854b93283cd1994db4c4dbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd708dc2f4446bafea3d17e291f33af1" id="r_afd708dc2f4446bafea3d17e291f33af1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd708dc2f4446bafea3d17e291f33af1">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1bottom.html">bottom</a> x)</td></tr>
<tr class="memdesc:afd708dc2f4446bafea3d17e291f33af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the empty set.  <br /></td></tr>
<tr class="separator:afd708dc2f4446bafea3d17e291f33af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5024cf04cdd6fe3fba1e97534893ae41" id="r_a5024cf04cdd6fe3fba1e97534893ae41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5024cf04cdd6fe3fba1e97534893ae41">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;t)</td></tr>
<tr class="memdesc:a5024cf04cdd6fe3fba1e97534893ae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <br /></td></tr>
<tr class="separator:a5024cf04cdd6fe3fba1e97534893ae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc49a6b2b019a776860c266c94add2" id="r_a06bc49a6b2b019a776860c266c94add2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06bc49a6b2b019a776860c266c94add2">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a06bc49a6b2b019a776860c266c94add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element and associates an environment (reference count incremented).  <br /></td></tr>
<tr class="separator:a06bc49a6b2b019a776860c266c94add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a47774aefe36f6de2306ba55983bb2" id="r_a17a47774aefe36f6de2306ba55983bb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17a47774aefe36f6de2306ba55983bb2">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a17a47774aefe36f6de2306ba55983bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a box.  <br /></td></tr>
<tr class="separator:a17a47774aefe36f6de2306ba55983bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe83b8f8e90be8f60f6a743a4e920060" id="r_abe83b8f8e90be8f60f6a743a4e920060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe83b8f8e90be8f60f6a743a4e920060">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:abe83b8f8e90be8f60f6a743a4e920060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a box.  <br /></td></tr>
<tr class="separator:abe83b8f8e90be8f60f6a743a4e920060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af38a4b59e58b87104a70d88ac044f9" id="r_a4af38a4b59e58b87104a70d88ac044f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4af38a4b59e58b87104a70d88ac044f9">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a4af38a4b59e58b87104a70d88ac044f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of linear constraints.  <br /></td></tr>
<tr class="separator:a4af38a4b59e58b87104a70d88ac044f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78a788ac56604363ee6df87f1db8440" id="r_ae78a788ac56604363ee6df87f1db8440"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae78a788ac56604363ee6df87f1db8440">abstract1</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:ae78a788ac56604363ee6df87f1db8440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of arbitrary constraints.  <br /></td></tr>
<tr class="separator:ae78a788ac56604363ee6df87f1db8440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5578abd8e6f47364d58d8f06a8dc6c" id="r_a4e5578abd8e6f47364d58d8f06a8dc6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e5578abd8e6f47364d58d8f06a8dc6c">abstract1</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;t)</td></tr>
<tr class="memdesc:a4e5578abd8e6f47364d58d8f06a8dc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <br /></td></tr>
<tr class="separator:a4e5578abd8e6f47364d58d8f06a8dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr class="memitem:a4f3e5e486b1a2139208b58b424418fd8" id="r_a4f3e5e486b1a2139208b58b424418fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f3e5e486b1a2139208b58b424418fd8">~abstract1</a> ()</td></tr>
<tr class="memdesc:a4f3e5e486b1a2139208b58b424418fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element.  <br /></td></tr>
<tr class="separator:a4f3e5e486b1a2139208b58b424418fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b80374409c75e5d1f3b4d1e91141ad" id="r_af1b80374409c75e5d1f3b4d1e91141ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1b80374409c75e5d1f3b4d1e91141ad">free</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:af1b80374409c75e5d1f3b4d1e91141ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element using the given manager.  <br /></td></tr>
<tr class="separator:af1b80374409c75e5d1f3b4d1e91141ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Copies and conversions to abstract elements</div></td></tr>
<tr class="memitem:aa3eddc65033da59f2b8e3da88017d4c4" id="r_aa3eddc65033da59f2b8e3da88017d4c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3eddc65033da59f2b8e3da88017d4c4">operator=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;t)</td></tr>
<tr class="memdesc:aa3eddc65033da59f2b8e3da88017d4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a copy of t to *this.  <br /></td></tr>
<tr class="separator:aa3eddc65033da59f2b8e3da88017d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7fd4292a248506462e5f75534896bc" id="r_a0f7fd4292a248506462e5f75534896bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7fd4292a248506462e5f75534896bc">operator=</a> (<a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:a0f7fd4292a248506462e5f75534896bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the full space to *this.  <br /></td></tr>
<tr class="separator:a0f7fd4292a248506462e5f75534896bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d4d3d989bc573422ace03218c96beb" id="r_a01d4d3d989bc573422ace03218c96beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01d4d3d989bc573422ace03218c96beb">operator=</a> (<a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:a01d4d3d989bc573422ace03218c96beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the empty set to *this.  <br /></td></tr>
<tr class="separator:a01d4d3d989bc573422ace03218c96beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8592168b29edfe3d00fe264c26a2efd" id="r_ab8592168b29edfe3d00fe264c26a2efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8592168b29edfe3d00fe264c26a2efd">operator=</a> (const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:ab8592168b29edfe3d00fe264c26a2efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a box to *this.  <br /></td></tr>
<tr class="separator:ab8592168b29edfe3d00fe264c26a2efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab47317ca450263be9b245b3007016f" id="r_a8ab47317ca450263be9b245b3007016f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab47317ca450263be9b245b3007016f">operator=</a> (const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a8ab47317ca450263be9b245b3007016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of linear constraints to *this.  <br /></td></tr>
<tr class="separator:a8ab47317ca450263be9b245b3007016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a13b1d97a69bb39a2a9da3eb055435" id="r_a84a13b1d97a69bb39a2a9da3eb055435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a13b1d97a69bb39a2a9da3eb055435">operator=</a> (const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a84a13b1d97a69bb39a2a9da3eb055435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of arbitrary constraints to *this.  <br /></td></tr>
<tr class="separator:a84a13b1d97a69bb39a2a9da3eb055435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91393622e71700a39c71380c6bf2720d" id="r_a91393622e71700a39c71380c6bf2720d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91393622e71700a39c71380c6bf2720d">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x)</td></tr>
<tr class="memdesc:a91393622e71700a39c71380c6bf2720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a copy of x.  <br /></td></tr>
<tr class="separator:a91393622e71700a39c71380c6bf2720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd9d86948de72a842493e3abed86294" id="r_a3dd9d86948de72a842493e3abed86294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dd9d86948de72a842493e3abed86294">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:a3dd9d86948de72a842493e3abed86294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the full space.  <br /></td></tr>
<tr class="separator:a3dd9d86948de72a842493e3abed86294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7c7c0de689b9d4b27b032a4d8e8333" id="r_aec7c7c0de689b9d4b27b032a4d8e8333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7c7c0de689b9d4b27b032a4d8e8333">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:aec7c7c0de689b9d4b27b032a4d8e8333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the full space.  <br /></td></tr>
<tr class="separator:aec7c7c0de689b9d4b27b032a4d8e8333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdae15c48b20cb1e76ec5c33f7a78a9" id="r_afbdae15c48b20cb1e76ec5c33f7a78a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbdae15c48b20cb1e76ec5c33f7a78a9">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:afbdae15c48b20cb1e76ec5c33f7a78a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the empty set.  <br /></td></tr>
<tr class="separator:afbdae15c48b20cb1e76ec5c33f7a78a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a76d3271d0392280af8ff54b92b6df" id="r_a42a76d3271d0392280af8ff54b92b6df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42a76d3271d0392280af8ff54b92b6df">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, <a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:a42a76d3271d0392280af8ff54b92b6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the empty set.  <br /></td></tr>
<tr class="separator:a42a76d3271d0392280af8ff54b92b6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa189dcc451d213fd2f0c562619f840f6" id="r_aa189dcc451d213fd2f0c562619f840f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa189dcc451d213fd2f0c562619f840f6">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:aa189dcc451d213fd2f0c562619f840f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <br /></td></tr>
<tr class="separator:aa189dcc451d213fd2f0c562619f840f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65658443862e2a490c5cbb450fe613" id="r_a7c65658443862e2a490c5cbb450fe613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c65658443862e2a490c5cbb450fe613">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a7c65658443862e2a490c5cbb450fe613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <br /></td></tr>
<tr class="separator:a7c65658443862e2a490c5cbb450fe613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d068a7df8f1190bcd028543d045bdc8" id="r_a9d068a7df8f1190bcd028543d045bdc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d068a7df8f1190bcd028543d045bdc8">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a9d068a7df8f1190bcd028543d045bdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <br /></td></tr>
<tr class="separator:a9d068a7df8f1190bcd028543d045bdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253431f62f1a765051f6a7288f51855a" id="r_a253431f62f1a765051f6a7288f51855a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a253431f62f1a765051f6a7288f51855a">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a253431f62f1a765051f6a7288f51855a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of linear constraints.  <br /></td></tr>
<tr class="separator:a253431f62f1a765051f6a7288f51855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fa2f49b715da57bc50a5e65b986f6f" id="r_a91fa2f49b715da57bc50a5e65b986f6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91fa2f49b715da57bc50a5e65b986f6f">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;x)</td></tr>
<tr class="memdesc:a91fa2f49b715da57bc50a5e65b986f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of arbitrary constraints.  <br /></td></tr>
<tr class="separator:a91fa2f49b715da57bc50a5e65b986f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Control of internal representation</div></td></tr>
<tr class="memitem:ad800ae88efb344abe032bf85cdac3b68" id="r_ad800ae88efb344abe032bf85cdac3b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad800ae88efb344abe032bf85cdac3b68">minimize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:ad800ae88efb344abe032bf85cdac3b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimizes the size of the representation, to save memory.  <br /></td></tr>
<tr class="separator:ad800ae88efb344abe032bf85cdac3b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad5bdefc0b48a13f839de77a97868f6" id="r_a3ad5bdefc0b48a13f839de77a97868f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ad5bdefc0b48a13f839de77a97868f6">canonicalize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a3ad5bdefc0b48a13f839de77a97868f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the abstract element in canonical form (if such a notion exists).  <br /></td></tr>
<tr class="separator:a3ad5bdefc0b48a13f839de77a97868f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994069657f16633ba0e4c7c23e0468c3" id="r_a994069657f16633ba0e4c7c23e0468c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994069657f16633ba0e4c7c23e0468c3">approximate</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, int algorithm)</td></tr>
<tr class="memdesc:a994069657f16633ba0e4c7c23e0468c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the abstract element, potentially loosing precision.  <br /></td></tr>
<tr class="separator:a994069657f16633ba0e4c7c23e0468c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr class="memitem:a76b2862115aa5fbd87175686e493c481" id="r_a76b2862115aa5fbd87175686e493c481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1manager.html">manager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76b2862115aa5fbd87175686e493c481">get_manager</a> () const</td></tr>
<tr class="memdesc:a76b2862115aa5fbd87175686e493c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the manager the abstract element was created with (with reference count incremented).  <br /></td></tr>
<tr class="separator:a76b2862115aa5fbd87175686e493c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106bdd4530d40b49082f636c517fd565" id="r_a106bdd4530d40b49082f636c517fd565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1environment.html">environment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a106bdd4530d40b49082f636c517fd565">get_environment</a> () const</td></tr>
<tr class="memdesc:a106bdd4530d40b49082f636c517fd565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the environment of the abstract element (with reference count incremented).  <br /></td></tr>
<tr class="separator:a106bdd4530d40b49082f636c517fd565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c80db7b903cece05706bdea3905bc3d" id="r_a9c80db7b903cece05706bdea3905bc3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c80db7b903cece05706bdea3905bc3d">get_abstract0</a> ()</td></tr>
<tr class="memdesc:a9c80db7b903cece05706bdea3905bc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (modifiable) reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>.  <br /></td></tr>
<tr class="separator:a9c80db7b903cece05706bdea3905bc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf571fc535416273d6e7cd51893e7fd" id="r_a3cf571fc535416273d6e7cd51893e7fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cf571fc535416273d6e7cd51893e7fd">get_abstract0</a> () const</td></tr>
<tr class="memdesc:a3cf571fc535416273d6e7cd51893e7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>.  <br /></td></tr>
<tr class="separator:a3cf571fc535416273d6e7cd51893e7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7978d6548967192d3be35131828776" id="r_a0d7978d6548967192d3be35131828776"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7978d6548967192d3be35131828776">size</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a0d7978d6548967192d3be35131828776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (abstract) size of the abstract element.  <br /></td></tr>
<tr class="separator:a0d7978d6548967192d3be35131828776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property extraction</div></td></tr>
<tr class="memitem:a339115b7d3b039cf6a379615fc8554ba" id="r_a339115b7d3b039cf6a379615fc8554ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a339115b7d3b039cf6a379615fc8554ba">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l) const</td></tr>
<tr class="memdesc:a339115b7d3b039cf6a379615fc8554ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for a linear expression evaluated in all points in the abstract element.  <br /></td></tr>
<tr class="separator:a339115b7d3b039cf6a379615fc8554ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d74bc2e81e8383ae45d0a129046d8a" id="r_a93d74bc2e81e8383ae45d0a129046d8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d74bc2e81e8383ae45d0a129046d8a">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l) const</td></tr>
<tr class="memdesc:a93d74bc2e81e8383ae45d0a129046d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for an arbitrary expression evaluated in all points in the abstract element.  <br /></td></tr>
<tr class="separator:a93d74bc2e81e8383ae45d0a129046d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443a713ff2704f78988a5eaf5cc675c" id="r_af443a713ff2704f78988a5eaf5cc675c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af443a713ff2704f78988a5eaf5cc675c">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v) const</td></tr>
<tr class="memdesc:af443a713ff2704f78988a5eaf5cc675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for the given variable on all points in the abstract element.  <br /></td></tr>
<tr class="separator:af443a713ff2704f78988a5eaf5cc675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61426b2c51ea83f90ff7863cebc34cfb" id="r_a61426b2c51ea83f90ff7863cebc34cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval__array.html">interval_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61426b2c51ea83f90ff7863cebc34cfb">to_box</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a61426b2c51ea83f90ff7863cebc34cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bounding box for the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:a61426b2c51ea83f90ff7863cebc34cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69339cb2be90a806bec2b6e674b2058d" id="r_a69339cb2be90a806bec2b6e674b2058d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1generator1__array.html">generator1_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69339cb2be90a806bec2b6e674b2058d">to_generator_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a69339cb2be90a806bec2b6e674b2058d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generator representation of (an over-approximation of) the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:a69339cb2be90a806bec2b6e674b2058d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdef105472739af42c8a7f90389db29c" id="r_afdef105472739af42c8a7f90389db29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdef105472739af42c8a7f90389db29c">to_lincons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:afdef105472739af42c8a7f90389db29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:afdef105472739af42c8a7f90389db29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944dee440aaf0c3ce4b6c1cbd83050c" id="r_ab944dee440aaf0c3ce4b6c1cbd83050c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab944dee440aaf0c3ce4b6c1cbd83050c">to_tcons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:ab944dee440aaf0c3ce4b6c1cbd83050c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constraint representation of (an over-approximation of) the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:ab944dee440aaf0c3ce4b6c1cbd83050c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C API compatibility</div></td></tr>
<tr class="memitem:aa11fa5ba8fa8a0754853548eacce5712" id="r_aa11fa5ba8fa8a0754853548eacce5712"><td class="memItemLeft" align="right" valign="top">ap_abstract1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa11fa5ba8fa8a0754853548eacce5712">get_ap_abstract1_t</a> ()</td></tr>
<tr class="memdesc:aa11fa5ba8fa8a0754853548eacce5712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <br /></td></tr>
<tr class="separator:aa11fa5ba8fa8a0754853548eacce5712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0f23035e10c9f05527cbd9c4259232" id="r_aab0f23035e10c9f05527cbd9c4259232"><td class="memItemLeft" align="right" valign="top">const ap_abstract1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab0f23035e10c9f05527cbd9c4259232">get_ap_abstract1_t</a> () const</td></tr>
<tr class="memdesc:aab0f23035e10c9f05527cbd9c4259232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <br /></td></tr>
<tr class="separator:aab0f23035e10c9f05527cbd9c4259232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structapron_1_1use__malloc"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structapron_1_1use__malloc')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a></td></tr>
<tr class="memitem:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc" id="r_a886761279a3b4508e689a4115060ad9f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a886761279a3b4508e689a4115060ad9f">operator new</a> (size_t sz)</td></tr>
<tr class="separator:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc" id="r_a1a5ca8977532c5975ef94b5cd382da09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1a5ca8977532c5975ef94b5cd382da09">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc" id="r_a6049364eb61e4e9767a7eafafd3f52dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a6049364eb61e4e9767a7eafafd3f52dc">operator delete</a> (void *p)</td></tr>
<tr class="separator:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc" id="r_a1547897dbcdc951e206b53bb0e3b57ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1547897dbcdc951e206b53bb0e3b57ef">operator delete[]</a> (void *p)</td></tr>
<tr class="separator:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae9f85047c9ca23a39f505c1f4fbcff3d" id="r_ae9f85047c9ca23a39f505c1f4fbcff3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9f85047c9ca23a39f505c1f4fbcff3d">abstract1</a> (ap_abstract1_t x)</td></tr>
<tr class="memdesc:ae9f85047c9ca23a39f505c1f4fbcff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only. Shallow copy of structure.  <br /></td></tr>
<tr class="separator:ae9f85047c9ca23a39f505c1f4fbcff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac46e4c0ba148a29a83394974350cd6d2" id="r_ac46e4c0ba148a29a83394974350cd6d2"><td class="memItemLeft" align="right" valign="top">ap_abstract1_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac46e4c0ba148a29a83394974350cd6d2">a</a></td></tr>
<tr class="memdesc:ac46e4c0ba148a29a83394974350cd6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure managed by APRON.  <br /></td></tr>
<tr class="separator:ac46e4c0ba148a29a83394974350cd6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a3994902b1385eef6523d2f7b6e61f86c" id="r_a3994902b1385eef6523d2f7b6e61f86c"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classapron_1_1abstract1.html">abstract1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></td></tr>
<tr class="memdesc:a3994902b1385eef6523d2f7b6e61f86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL abstract element, to be used only as default argument in assign and substitute.  <br /></td></tr>
<tr class="separator:a3994902b1385eef6523d2f7b6e61f86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Printing</h2></td></tr>
<tr class="memitem:a8fc976840805ce49fdc62efddceb53bd" id="r_a8fc976840805ce49fdc62efddceb53bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fc976840805ce49fdc62efddceb53bd">print</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:a8fc976840805ce49fdc62efddceb53bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-printing to a C stream.  <br /></td></tr>
<tr class="separator:a8fc976840805ce49fdc62efddceb53bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1099828d0c5158a868be70002375d16" id="r_ac1099828d0c5158a868be70002375d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1099828d0c5158a868be70002375d16">dump</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:ac1099828d0c5158a868be70002375d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw printing to a C stream (mainly for debug purposes).  <br /></td></tr>
<tr class="separator:ac1099828d0c5158a868be70002375d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Serialisation</h2></td></tr>
<tr class="memitem:a9f2d927f165d9b4c323adbba6f571578" id="r_a9f2d927f165d9b4c323adbba6f571578"><td class="memItemLeft" align="right" valign="top">std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f2d927f165d9b4c323adbba6f571578">serialize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a9f2d927f165d9b4c323adbba6f571578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an abstract element.  <br /></td></tr>
<tr class="separator:a9f2d927f165d9b4c323adbba6f571578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Predicates</h2></td></tr>
<tr class="memitem:a70523104c8b0ed2932d1a1a597411a13" id="r_a70523104c8b0ed2932d1a1a597411a13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70523104c8b0ed2932d1a1a597411a13">is_bottom</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a70523104c8b0ed2932d1a1a597411a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the empty set.  <br /></td></tr>
<tr class="separator:a70523104c8b0ed2932d1a1a597411a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4c586d48871a8b35e3c2d1715152ec" id="r_adf4c586d48871a8b35e3c2d1715152ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf4c586d48871a8b35e3c2d1715152ec">is_top</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:adf4c586d48871a8b35e3c2d1715152ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the full space.  <br /></td></tr>
<tr class="separator:adf4c586d48871a8b35e3c2d1715152ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e49f9930afa4abc377451cac1b4214" id="r_a79e49f9930afa4abc377451cac1b4214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79e49f9930afa4abc377451cac1b4214">is_eq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x) const</td></tr>
<tr class="memdesc:a79e49f9930afa4abc377451cac1b4214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this and x represent the same set.  <br /></td></tr>
<tr class="separator:a79e49f9930afa4abc377451cac1b4214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b10bd15959cf97dbc219dc6db572ca" id="r_a86b10bd15959cf97dbc219dc6db572ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86b10bd15959cf97dbc219dc6db572ca">is_leq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;x) const</td></tr>
<tr class="memdesc:a86b10bd15959cf97dbc219dc6db572ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this is included in x (set-wise).  <br /></td></tr>
<tr class="separator:a86b10bd15959cf97dbc219dc6db572ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ef4e577b8dbfff9ddcb16b9393dba4" id="r_a74ef4e577b8dbfff9ddcb16b9393dba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ef4e577b8dbfff9ddcb16b9393dba4">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1.html">lincons1</a> &amp;l) const</td></tr>
<tr class="memdesc:a74ef4e577b8dbfff9ddcb16b9393dba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy a linear constraint.  <br /></td></tr>
<tr class="separator:a74ef4e577b8dbfff9ddcb16b9393dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855ee58954b223c77cc9b2efa21dd31e" id="r_a855ee58954b223c77cc9b2efa21dd31e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a855ee58954b223c77cc9b2efa21dd31e">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1.html">tcons1</a> &amp;l) const</td></tr>
<tr class="memdesc:a855ee58954b223c77cc9b2efa21dd31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy an arbitrary constraint.  <br /></td></tr>
<tr class="separator:a855ee58954b223c77cc9b2efa21dd31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f19c3e1dd25a092294a97680650f9" id="r_a1f4f19c3e1dd25a092294a97680650f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4f19c3e1dd25a092294a97680650f9">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;i) const</td></tr>
<tr class="memdesc:a1f4f19c3e1dd25a092294a97680650f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the component v of all points in *this is included in the given interval.  <br /></td></tr>
<tr class="separator:a1f4f19c3e1dd25a092294a97680650f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b43de9c05b871379b0d3202502aba2" id="r_ab6b43de9c05b871379b0d3202502aba2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6b43de9c05b871379b0d3202502aba2">is_variable_unconstrained</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v) const</td></tr>
<tr class="memdesc:ab6b43de9c05b871379b0d3202502aba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the points in *this are unbounded in the given variable.  <br /></td></tr>
<tr class="separator:ab6b43de9c05b871379b0d3202502aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Meet and unification</h2></td></tr>
<tr class="memitem:ac66183c64324b8f3c45e4aed4a36edf6" id="r_ac66183c64324b8f3c45e4aed4a36edf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac66183c64324b8f3c45e4aed4a36edf6">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:ac66183c64324b8f3c45e4aed4a36edf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:ac66183c64324b8f3c45e4aed4a36edf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba32c363a51d9b2296a2470baabc93" id="r_a7bba32c363a51d9b2296a2470baabc93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bba32c363a51d9b2296a2470baabc93">unify</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a7bba32c363a51d9b2296a2470baabc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a7bba32c363a51d9b2296a2470baabc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f208351d3d0530b623a9f3b34f7e8f2" id="r_a1f208351d3d0530b623a9f3b34f7e8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f208351d3d0530b623a9f3b34f7e8f2">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a1f208351d3d0530b623a9f3b34f7e8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a1f208351d3d0530b623a9f3b34f7e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d59f85b165060b50fbbf3038a046e3a" id="r_a1d59f85b165060b50fbbf3038a046e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d59f85b165060b50fbbf3038a046e3a">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a1d59f85b165060b50fbbf3038a046e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a1d59f85b165060b50fbbf3038a046e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecf4559098997971e25c6a8286ba255" id="r_a8ecf4559098997971e25c6a8286ba255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ecf4559098997971e25c6a8286ba255">operator*=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a8ecf4559098997971e25c6a8286ba255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a8ecf4559098997971e25c6a8286ba255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8674bbc0cb2af50dbecaf9b414169f" id="r_a6d8674bbc0cb2af50dbecaf9b414169f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8674bbc0cb2af50dbecaf9b414169f">operator*=</a> (const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a6d8674bbc0cb2af50dbecaf9b414169f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a6d8674bbc0cb2af50dbecaf9b414169f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eea4377612d05c0f70b6bc127391a2" id="r_a90eea4377612d05c0f70b6bc127391a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90eea4377612d05c0f70b6bc127391a2">operator*=</a> (const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a90eea4377612d05c0f70b6bc127391a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a90eea4377612d05c0f70b6bc127391a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Join</h2></td></tr>
<tr class="memitem:a6b5ab9b962e4506eb2745e1b50a1e065" id="r_a6b5ab9b962e4506eb2745e1b50a1e065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b5ab9b962e4506eb2745e1b50a1e065">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a6b5ab9b962e4506eb2745e1b50a1e065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a6b5ab9b962e4506eb2745e1b50a1e065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809a572d2873b85474682ba1705803d" id="r_a4809a572d2873b85474682ba1705803d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4809a572d2873b85474682ba1705803d">add_rays</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;y)</td></tr>
<tr class="memdesc:a4809a572d2873b85474682ba1705803d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a4809a572d2873b85474682ba1705803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e5f91cff8da6b26382dd0e02217fa9" id="r_a97e5f91cff8da6b26382dd0e02217fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97e5f91cff8da6b26382dd0e02217fa9">operator+=</a> (const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;y)</td></tr>
<tr class="memdesc:a97e5f91cff8da6b26382dd0e02217fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a97e5f91cff8da6b26382dd0e02217fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d5a971376c585ba1c6668e771565e" id="r_ac92d5a971376c585ba1c6668e771565e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92d5a971376c585ba1c6668e771565e">operator+=</a> (const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;y)</td></tr>
<tr class="memdesc:ac92d5a971376c585ba1c6668e771565e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <br /></td></tr>
<tr class="separator:ac92d5a971376c585ba1c6668e771565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Assignment</h2></td></tr>
<tr class="memitem:aab6e9bba6f7555f3f5155ae2353f00c1" id="r_aab6e9bba6f7555f3f5155ae2353f00c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab6e9bba6f7555f3f5155ae2353f00c1">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:aab6e9bba6f7555f3f5155ae2353f00c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of linear expression.  <br /></td></tr>
<tr class="separator:aab6e9bba6f7555f3f5155ae2353f00c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5e6e99ed5d0b8d5874a270b8ccc14f" id="r_a2e5e6e99ed5d0b8d5874a270b8ccc14f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e5e6e99ed5d0b8d5874a270b8ccc14f">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a2e5e6e99ed5d0b8d5874a270b8ccc14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <br /></td></tr>
<tr class="separator:a2e5e6e99ed5d0b8d5874a270b8ccc14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de0bfb7e0298c0ff0b4e2a77dcffe15" id="r_a3de0bfb7e0298c0ff0b4e2a77dcffe15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3de0bfb7e0298c0ff0b4e2a77dcffe15">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a3de0bfb7e0298c0ff0b4e2a77dcffe15"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <br /></td></tr>
<tr class="separator:a3de0bfb7e0298c0ff0b4e2a77dcffe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade787ba2cfe69e447e6d3161980cc343" id="r_ade787ba2cfe69e447e6d3161980cc343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade787ba2cfe69e447e6d3161980cc343">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:ade787ba2cfe69e447e6d3161980cc343"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of arbitrary expression.  <br /></td></tr>
<tr class="separator:ade787ba2cfe69e447e6d3161980cc343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aaa8bc60874c624ae4c19a931db601" id="r_a90aaa8bc60874c624ae4c19a931db601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90aaa8bc60874c624ae4c19a931db601">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a90aaa8bc60874c624ae4c19a931db601"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <br /></td></tr>
<tr class="separator:a90aaa8bc60874c624ae4c19a931db601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ac5b1b7195fbf709c8a9a73c110380" id="r_a06ac5b1b7195fbf709c8a9a73c110380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ac5b1b7195fbf709c8a9a73c110380">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a06ac5b1b7195fbf709c8a9a73c110380"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <br /></td></tr>
<tr class="separator:a06ac5b1b7195fbf709c8a9a73c110380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Substitution</h2></td></tr>
<tr class="memitem:aee1d7a90ce9a94e0592426d7c7d2e8ce" id="r_aee1d7a90ce9a94e0592426d7c7d2e8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee1d7a90ce9a94e0592426d7c7d2e8ce">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:aee1d7a90ce9a94e0592426d7c7d2e8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of linear expression.  <br /></td></tr>
<tr class="separator:aee1d7a90ce9a94e0592426d7c7d2e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d1ae0c1771350d104eef6d3f5ecfa" id="r_aa12d1ae0c1771350d104eef6d3f5ecfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa12d1ae0c1771350d104eef6d3f5ecfa">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:aa12d1ae0c1771350d104eef6d3f5ecfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <br /></td></tr>
<tr class="separator:aa12d1ae0c1771350d104eef6d3f5ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5364f8a8f5db9521377ac33039602af6" id="r_a5364f8a8f5db9521377ac33039602af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5364f8a8f5db9521377ac33039602af6">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:a5364f8a8f5db9521377ac33039602af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <br /></td></tr>
<tr class="separator:a5364f8a8f5db9521377ac33039602af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b56b16d317876ea6ff9c97c3a77f6f" id="r_ae8b56b16d317876ea6ff9c97c3a77f6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b56b16d317876ea6ff9c97c3a77f6f">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:ae8b56b16d317876ea6ff9c97c3a77f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of arbitrary expression.  <br /></td></tr>
<tr class="separator:ae8b56b16d317876ea6ff9c97c3a77f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8aa8c6894236f0dffcceaa732ba2ec" id="r_adf8aa8c6894236f0dffcceaa732ba2ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf8aa8c6894236f0dffcceaa732ba2ec">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const l[], const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:adf8aa8c6894236f0dffcceaa732ba2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <br /></td></tr>
<tr class="separator:adf8aa8c6894236f0dffcceaa732ba2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecba5c006fbaa95d51f00bce067b928c" id="r_aecba5c006fbaa95d51f00bce067b928c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecba5c006fbaa95d51f00bce067b928c">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;inter=<a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a>)</td></tr>
<tr class="memdesc:aecba5c006fbaa95d51f00bce067b928c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <br /></td></tr>
<tr class="separator:aecba5c006fbaa95d51f00bce067b928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Projection, forget</h2></td></tr>
<tr class="memitem:a488249f4157db84313a85f2c0103288d" id="r_a488249f4157db84313a85f2c0103288d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488249f4157db84313a85f2c0103288d">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, bool project=false)</td></tr>
<tr class="memdesc:a488249f4157db84313a85f2c0103288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of variable v in *this.  <br /></td></tr>
<tr class="separator:a488249f4157db84313a85f2c0103288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559dd40ce4566a28565f469b35234ca0" id="r_a559dd40ce4566a28565f469b35234ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a559dd40ce4566a28565f469b35234ca0">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[], bool project=false)</td></tr>
<tr class="memdesc:a559dd40ce4566a28565f469b35234ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of variables v[0] to v[size-1] in *this.  <br /></td></tr>
<tr class="separator:a559dd40ce4566a28565f469b35234ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249f20beb7b6a0896ebcc8ebb17c7a54" id="r_a249f20beb7b6a0896ebcc8ebb17c7a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a249f20beb7b6a0896ebcc8ebb17c7a54">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v, bool project=false)</td></tr>
<tr class="memdesc:a249f20beb7b6a0896ebcc8ebb17c7a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of all the variables in v in *this.  <br /></td></tr>
<tr class="separator:a249f20beb7b6a0896ebcc8ebb17c7a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Change of environment</h2></td></tr>
<tr class="memitem:a631453288760117c8e44e6612ddc3c52" id="r_a631453288760117c8e44e6612ddc3c52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a631453288760117c8e44e6612ddc3c52">change_environment</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;e, bool project=false)</td></tr>
<tr class="memdesc:a631453288760117c8e44e6612ddc3c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the environment of *this.  <br /></td></tr>
<tr class="separator:a631453288760117c8e44e6612ddc3c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c6a58ec8f4091bbb52fe63a6ef9265" id="r_ab3c6a58ec8f4091bbb52fe63a6ef9265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c6a58ec8f4091bbb52fe63a6ef9265">minimize_environment</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:ab3c6a58ec8f4091bbb52fe63a6ef9265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from *this the variables that are unconstrained.  <br /></td></tr>
<tr class="separator:ab3c6a58ec8f4091bbb52fe63a6ef9265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c817108ac1d6a9cae53a4b91577d65f" id="r_a8c817108ac1d6a9cae53a4b91577d65f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c817108ac1d6a9cae53a4b91577d65f">rename</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> oldv[], const <a class="el" href="classapron_1_1var.html">var</a> newv[])</td></tr>
<tr class="memdesc:a8c817108ac1d6a9cae53a4b91577d65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames oldv[i] into newv[i] in *this.  <br /></td></tr>
<tr class="separator:a8c817108ac1d6a9cae53a4b91577d65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad827bf6e32b6e6a9f5990ddb3a6429a9" id="r_ad827bf6e32b6e6a9f5990ddb3a6429a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad827bf6e32b6e6a9f5990ddb3a6429a9">rename</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;oldv, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;newv)</td></tr>
<tr class="memdesc:ad827bf6e32b6e6a9f5990ddb3a6429a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames oldv[i] into newv[i] in *this.  <br /></td></tr>
<tr class="separator:ad827bf6e32b6e6a9f5990ddb3a6429a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Expansion and folding</h2></td></tr>
<tr class="memitem:ab453cfeb32b2a13ecdc877709852ddcb" id="r_ab453cfeb32b2a13ecdc877709852ddcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab453cfeb32b2a13ecdc877709852ddcb">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> vv[])</td></tr>
<tr class="memdesc:ab453cfeb32b2a13ecdc877709852ddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates variable v into size copies in *this (modified in-place).  <br /></td></tr>
<tr class="separator:ab453cfeb32b2a13ecdc877709852ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aaabc3ffa391ade9cccd9ba722e76a" id="r_ac6aaabc3ffa391ade9cccd9ba722e76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6aaabc3ffa391ade9cccd9ba722e76a">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1var.html">var</a> &amp;v, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;vv)</td></tr>
<tr class="memdesc:ac6aaabc3ffa391ade9cccd9ba722e76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates variable v in *this (modified in-place).  <br /></td></tr>
<tr class="separator:ac6aaabc3ffa391ade9cccd9ba722e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467674d5fa94396b70d063df2c681cd2" id="r_a467674d5fa94396b70d063df2c681cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467674d5fa94396b70d063df2c681cd2">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#a0d7978d6548967192d3be35131828776">size</a>, const <a class="el" href="classapron_1_1var.html">var</a> v[])</td></tr>
<tr class="memdesc:a467674d5fa94396b70d063df2c681cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds variables v[0] to v[size-1] in *this (modified in-place).  <br /></td></tr>
<tr class="separator:a467674d5fa94396b70d063df2c681cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab051c409c69c5e56f50cdfb4939c7918" id="r_ab051c409c69c5e56f50cdfb4939c7918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab051c409c69c5e56f50cdfb4939c7918">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ab051c409c69c5e56f50cdfb4939c7918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds all variables v in *this (modified in-place).  <br /></td></tr>
<tr class="separator:ab051c409c69c5e56f50cdfb4939c7918"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Closure</h2></td></tr>
<tr class="memitem:aa4f5c128921fd8bde7596852cf15715a" id="r_aa4f5c128921fd8bde7596852cf15715a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4f5c128921fd8bde7596852cf15715a">closure</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:aa4f5c128921fd8bde7596852cf15715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with its topological closure.  <br /></td></tr>
<tr class="separator:aa4f5c128921fd8bde7596852cf15715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Level 1 abstract value (ap_abstract1_t wrapper). </p>
<p>Level 1 version of abstract values. Variable names (var) are used in place of dimensions (ap_dim_t). Internally, an <a class="el" href="classapron_1_1abstract1.html" title="Level 1 abstract value (ap_abstract1_t wrapper).">abstract1</a> wraps together an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> (memory managed) and an environment (holding a reference count). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae9f85047c9ca23a39f505c1f4fbcff3d" name="ae9f85047c9ca23a39f505c1f4fbcff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f85047c9ca23a39f505c1f4fbcff3d">&#9670;&#160;</a></span>abstract1() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype">ap_abstract1_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. Shallow copy of structure. </p>

</div>
</div>
<a id="a04607bc2854b93283cd1994db4c4dbf6" name="a04607bc2854b93283cd1994db4c4dbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04607bc2854b93283cd1994db4c4dbf6">&#9670;&#160;</a></span>abstract1() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the whole space. </p>

</div>
</div>
<a id="afd708dc2f4446bafea3d17e291f33af1" name="afd708dc2f4446bafea3d17e291f33af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd708dc2f4446bafea3d17e291f33af1">&#9670;&#160;</a></span>abstract1() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the empty set. </p>

</div>
</div>
<a id="a5024cf04cdd6fe3fba1e97534893ae41" name="a5024cf04cdd6fe3fba1e97534893ae41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5024cf04cdd6fe3fba1e97534893ae41">&#9670;&#160;</a></span>abstract1() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>

</div>
</div>
<a id="a06bc49a6b2b019a776860c266c94add2" name="a06bc49a6b2b019a776860c266c94add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bc49a6b2b019a776860c266c94add2">&#9670;&#160;</a></span>abstract1() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element and associates an environment (reference count incremented). </p>

</div>
</div>
<a id="a17a47774aefe36f6de2306ba55983bb2" name="a17a47774aefe36f6de2306ba55983bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a47774aefe36f6de2306ba55983bb2">&#9670;&#160;</a></span>abstract1() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a box. </p>
<p>x[i] is the bound for the variable v[i]. Variables not in v have unconstrained bounds. </p>

</div>
</div>
<a id="abe83b8f8e90be8f60f6a743a4e920060" name="abe83b8f8e90be8f60f6a743a4e920060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe83b8f8e90be8f60f6a743a4e920060">&#9670;&#160;</a></span>abstract1() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a box. </p>
<p>x[i] is the bound for all the variables in v. Variables not in v have unconstrained bounds. </p>

</div>
</div>
<a id="a4af38a4b59e58b87104a70d88ac044f9" name="a4af38a4b59e58b87104a70d88ac044f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af38a4b59e58b87104a70d88ac044f9">&#9670;&#160;</a></span>abstract1() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of linear constraints. </p>

</div>
</div>
<a id="ae78a788ac56604363ee6df87f1db8440" name="ae78a788ac56604363ee6df87f1db8440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78a788ac56604363ee6df87f1db8440">&#9670;&#160;</a></span>abstract1() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of arbitrary constraints. </p>

</div>
</div>
<a id="a4e5578abd8e6f47364d58d8f06a8dc6c" name="a4e5578abd8e6f47364d58d8f06a8dc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5578abd8e6f47364d58d8f06a8dc6c">&#9670;&#160;</a></span>abstract1() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::abstract1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a4f3e5e486b1a2139208b58b424418fd8" name="a4f3e5e486b1a2139208b58b424418fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e5e486b1a2139208b58b424418fd8">&#9670;&#160;</a></span>~abstract1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract1::~abstract1 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4809a572d2873b85474682ba1705803d" name="a4809a572d2873b85474682ba1705803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4809a572d2873b85474682ba1705803d">&#9670;&#160;</a></span>add_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::add_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a994069657f16633ba0e4c7c23e0468c3" name="a994069657f16633ba0e4c7c23e0468c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994069657f16633ba0e4c7c23e0468c3">&#9670;&#160;</a></span>approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::approximate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies the abstract element, potentially loosing precision. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a3de0bfb7e0298c0ff0b4e2a77dcffe15" name="a3de0bfb7e0298c0ff0b4e2a77dcffe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de0bfb7e0298c0ff0b4e2a77dcffe15">&#9670;&#160;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06ac5b1b7195fbf709c8a9a73c110380" name="a06ac5b1b7195fbf709c8a9a73c110380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ac5b1b7195fbf709c8a9a73c110380">&#9670;&#160;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab6e9bba6f7555f3f5155ae2353f00c1" name="aab6e9bba6f7555f3f5155ae2353f00c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6e9bba6f7555f3f5155ae2353f00c1">&#9670;&#160;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of linear expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ade787ba2cfe69e447e6d3161980cc343" name="ade787ba2cfe69e447e6d3161980cc343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade787ba2cfe69e447e6d3161980cc343">&#9670;&#160;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a2e5e6e99ed5d0b8d5874a270b8ccc14f" name="a2e5e6e99ed5d0b8d5874a270b8ccc14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5e6e99ed5d0b8d5874a270b8ccc14f">&#9670;&#160;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a90aaa8bc60874c624ae4c19a931db601" name="a90aaa8bc60874c624ae4c19a931db601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aaa8bc60874c624ae4c19a931db601">&#9670;&#160;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to variable v[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a339115b7d3b039cf6a379615fc8554ba" name="a339115b7d3b039cf6a379615fc8554ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339115b7d3b039cf6a379615fc8554ba">&#9670;&#160;</a></span>bound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract1::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for a linear expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="a93d74bc2e81e8383ae45d0a129046d8a" name="a93d74bc2e81e8383ae45d0a129046d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d74bc2e81e8383ae45d0a129046d8a">&#9670;&#160;</a></span>bound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract1::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for an arbitrary expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="af443a713ff2704f78988a5eaf5cc675c" name="af443a713ff2704f78988a5eaf5cc675c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443a713ff2704f78988a5eaf5cc675c">&#9670;&#160;</a></span>bound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> apron::abstract1::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for the given variable on all points in the abstract element. </p>

</div>
</div>
<a id="a3ad5bdefc0b48a13f839de77a97868f6" name="a3ad5bdefc0b48a13f839de77a97868f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5bdefc0b48a13f839de77a97868f6">&#9670;&#160;</a></span>canonicalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the abstract element in canonical form (if such a notion exists). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a631453288760117c8e44e6612ddc3c52" name="a631453288760117c8e44e6612ddc3c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631453288760117c8e44e6612ddc3c52">&#9670;&#160;</a></span>change_environment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::change_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the environment of *this. </p>
<ul>
<li><code>project</code> whether new variables are initialized to 0 (if true), or undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa4f5c128921fd8bde7596852cf15715a" name="aa4f5c128921fd8bde7596852cf15715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f5c128921fd8bde7596852cf15715a">&#9670;&#160;</a></span>closure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with its topological closure. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac1099828d0c5158a868be70002375d16" name="ac1099828d0c5158a868be70002375d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1099828d0c5158a868be70002375d16">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract1::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">stdout</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw printing to a C stream (mainly for debug purposes). </p>

</div>
</div>
<a id="ac6aaabc3ffa391ade9cccd9ba722e76a" name="ac6aaabc3ffa391ade9cccd9ba722e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aaabc3ffa391ade9cccd9ba722e76a">&#9670;&#160;</a></span>expand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vv</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates variable v in *this (modified in-place). </p>
<p>The i-th new variable is named vv[i].</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab453cfeb32b2a13ecdc877709852ddcb" name="ab453cfeb32b2a13ecdc877709852ddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab453cfeb32b2a13ecdc877709852ddcb">&#9670;&#160;</a></span>expand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>vv</em></span>[]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates variable v into size copies in *this (modified in-place). </p>
<p>New variables are named vv[0] to vv[size-1].</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab051c409c69c5e56f50cdfb4939c7918" name="ab051c409c69c5e56f50cdfb4939c7918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab051c409c69c5e56f50cdfb4939c7918">&#9670;&#160;</a></span>fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds all variables v in *this (modified in-place). </p>
<p>After folding, only v[0] is kept and other variables are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a467674d5fa94396b70d063df2c681cd2" name="a467674d5fa94396b70d063df2c681cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467674d5fa94396b70d063df2c681cd2">&#9670;&#160;</a></span>fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; apron::abstract1::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds variables v[0] to v[size-1] in *this (modified in-place). </p>
<p>After folding, only v[0] is kept and other variables are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a249f20beb7b6a0896ebcc8ebb17c7a54" name="a249f20beb7b6a0896ebcc8ebb17c7a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249f20beb7b6a0896ebcc8ebb17c7a54">&#9670;&#160;</a></span>forget() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of all the variables in v in *this. </p>
<ul>
<li><code>project</code> whether to reset the variables to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a488249f4157db84313a85f2c0103288d" name="a488249f4157db84313a85f2c0103288d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488249f4157db84313a85f2c0103288d">&#9670;&#160;</a></span>forget() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of variable v in *this. </p>
<ul>
<li><code>project</code> whether to reset the variable to 0 (if true), or leave it undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a559dd40ce4566a28565f469b35234ca0" name="a559dd40ce4566a28565f469b35234ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559dd40ce4566a28565f469b35234ca0">&#9670;&#160;</a></span>forget() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of variables v[0] to v[size-1] in *this. </p>
<ul>
<li><code>project</code> whether to reset the variables to 0 (if true), or it them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="af1b80374409c75e5d1f3b4d1e91141ad" name="af1b80374409c75e5d1f3b4d1e91141ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b80374409c75e5d1f3b4d1e91141ad">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract1::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element using the given manager. </p>
<p>The abstract element cannot be used after being freed. However, the standard destructor can be safely be called (resulting in a no-op). </p>

</div>
</div>
<a id="a9c80db7b903cece05706bdea3905bc3d" name="a9c80db7b903cece05706bdea3905bc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c80db7b903cece05706bdea3905bc3d">&#9670;&#160;</a></span>get_abstract0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract1::get_abstract0 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a (modifiable) reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>. </p>

</div>
</div>
<a id="a3cf571fc535416273d6e7cd51893e7fd" name="a3cf571fc535416273d6e7cd51893e7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf571fc535416273d6e7cd51893e7fd">&#9670;&#160;</a></span>get_abstract0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract1::get_abstract0 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the underlying <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>. </p>

</div>
</div>
<a id="aa11fa5ba8fa8a0754853548eacce5712" name="aa11fa5ba8fa8a0754853548eacce5712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11fa5ba8fa8a0754853548eacce5712">&#9670;&#160;</a></span>get_ap_abstract1_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract1_t * abstract1::get_ap_abstract1_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="aab0f23035e10c9f05527cbd9c4259232" name="aab0f23035e10c9f05527cbd9c4259232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0f23035e10c9f05527cbd9c4259232">&#9670;&#160;</a></span>get_ap_abstract1_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ap_abstract1_t * abstract1::get_ap_abstract1_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="a106bdd4530d40b49082f636c517fd565" name="a106bdd4530d40b49082f636c517fd565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106bdd4530d40b49082f636c517fd565">&#9670;&#160;</a></span>get_environment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1environment.html">environment</a> abstract1::get_environment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the environment of the abstract element (with reference count incremented). </p>

</div>
</div>
<a id="a76b2862115aa5fbd87175686e493c481" name="a76b2862115aa5fbd87175686e493c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b2862115aa5fbd87175686e493c481">&#9670;&#160;</a></span>get_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1manager.html">manager</a> abstract1::get_manager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the manager the abstract element was created with (with reference count incremented). </p>

</div>
</div>
<a id="a70523104c8b0ed2932d1a1a597411a13" name="a70523104c8b0ed2932d1a1a597411a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70523104c8b0ed2932d1a1a597411a13">&#9670;&#160;</a></span>is_bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the empty set. </p>

</div>
</div>
<a id="a79e49f9930afa4abc377451cac1b4214" name="a79e49f9930afa4abc377451cac1b4214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e49f9930afa4abc377451cac1b4214">&#9670;&#160;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this and x represent the same set. </p>

</div>
</div>
<a id="a86b10bd15959cf97dbc219dc6db572ca" name="a86b10bd15959cf97dbc219dc6db572ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b10bd15959cf97dbc219dc6db572ca">&#9670;&#160;</a></span>is_leq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_leq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this is included in x (set-wise). </p>

</div>
</div>
<a id="adf4c586d48871a8b35e3c2d1715152ec" name="adf4c586d48871a8b35e3c2d1715152ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4c586d48871a8b35e3c2d1715152ec">&#9670;&#160;</a></span>is_top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the full space. </p>

</div>
</div>
<a id="ab6b43de9c05b871379b0d3202502aba2" name="ab6b43de9c05b871379b0d3202502aba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b43de9c05b871379b0d3202502aba2">&#9670;&#160;</a></span>is_variable_unconstrained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::is_variable_unconstrained </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the points in *this are unbounded in the given variable. </p>

</div>
</div>
<a id="a6b5ab9b962e4506eb2745e1b50a1e065" name="a6b5ab9b962e4506eb2745e1b50a1e065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5ab9b962e4506eb2745e1b50a1e065">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac66183c64324b8f3c45e4aed4a36edf6" name="ac66183c64324b8f3c45e4aed4a36edf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66183c64324b8f3c45e4aed4a36edf6">&#9670;&#160;</a></span>meet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1f208351d3d0530b623a9f3b34f7e8f2" name="a1f208351d3d0530b623a9f3b34f7e8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f208351d3d0530b623a9f3b34f7e8f2">&#9670;&#160;</a></span>meet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1d59f85b165060b50fbbf3038a046e3a" name="a1d59f85b165060b50fbbf3038a046e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d59f85b165060b50fbbf3038a046e3a">&#9670;&#160;</a></span>meet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ad800ae88efb344abe032bf85cdac3b68" name="ad800ae88efb344abe032bf85cdac3b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad800ae88efb344abe032bf85cdac3b68">&#9670;&#160;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimizes the size of the representation, to save memory. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab3c6a58ec8f4091bbb52fe63a6ef9265" name="ab3c6a58ec8f4091bbb52fe63a6ef9265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c6a58ec8f4091bbb52fe63a6ef9265">&#9670;&#160;</a></span>minimize_environment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::minimize_environment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from *this the variables that are unconstrained. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a8ecf4559098997971e25c6a8286ba255" name="a8ecf4559098997971e25c6a8286ba255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecf4559098997971e25c6a8286ba255">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a6d8674bbc0cb2af50dbecaf9b414169f" name="a6d8674bbc0cb2af50dbecaf9b414169f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8674bbc0cb2af50dbecaf9b414169f">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a90eea4377612d05c0f70b6bc127391a2" name="a90eea4377612d05c0f70b6bc127391a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eea4377612d05c0f70b6bc127391a2">&#9670;&#160;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a97e5f91cff8da6b26382dd0e02217fa9" name="a97e5f91cff8da6b26382dd0e02217fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e5f91cff8da6b26382dd0e02217fa9">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac92d5a971376c585ba1c6668e771565e" name="ac92d5a971376c585ba1c6668e771565e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92d5a971376c585ba1c6668e771565e">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a01d4d3d989bc573422ace03218c96beb" name="a01d4d3d989bc573422ace03218c96beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d4d3d989bc573422ace03218c96beb">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the empty set to *this. </p>
<p>Implicitly uses the manager used to create *this. Does not change the environment. </p>

</div>
</div>
<a id="aa3eddc65033da59f2b8e3da88017d4c4" name="aa3eddc65033da59f2b8e3da88017d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3eddc65033da59f2b8e3da88017d4c4">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a copy of t to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="ab8592168b29edfe3d00fe264c26a2efd" name="ab8592168b29edfe3d00fe264c26a2efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8592168b29edfe3d00fe264c26a2efd">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a box to *this. </p>
<p>Implicitly uses the manager used to create *this. Does not change the environment.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the array has insufficient size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ab47317ca450263be9b245b3007016f" name="a8ab47317ca450263be9b245b3007016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab47317ca450263be9b245b3007016f">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of linear constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. Does not change the environment. </p>

</div>
</div>
<a id="a84a13b1d97a69bb39a2a9da3eb055435" name="a84a13b1d97a69bb39a2a9da3eb055435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a13b1d97a69bb39a2a9da3eb055435">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of arbitrary constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a0f7fd4292a248506462e5f75534896bc" name="a0f7fd4292a248506462e5f75534896bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7fd4292a248506462e5f75534896bc">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the full space to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a8fc976840805ce49fdc62efddceb53bd" name="a8fc976840805ce49fdc62efddceb53bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc976840805ce49fdc62efddceb53bd">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract1::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">stdout</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty-printing to a C stream. </p>

</div>
</div>
<a id="ad827bf6e32b6e6a9f5990ddb3a6429a9" name="ad827bf6e32b6e6a9f5990ddb3a6429a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad827bf6e32b6e6a9f5990ddb3a6429a9">&#9670;&#160;</a></span>rename() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>oldv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newv</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames oldv[i] into newv[i] in *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a8c817108ac1d6a9cae53a4b91577d65f" name="a8c817108ac1d6a9cae53a4b91577d65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c817108ac1d6a9cae53a4b91577d65f">&#9670;&#160;</a></span>rename() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>oldv</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>newv</em></span>[]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renames oldv[i] into newv[i] in *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a74ef4e577b8dbfff9ddcb16b9393dba4" name="a74ef4e577b8dbfff9ddcb16b9393dba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ef4e577b8dbfff9ddcb16b9393dba4">&#9670;&#160;</a></span>sat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1.html">lincons1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy a linear constraint. </p>

</div>
</div>
<a id="a855ee58954b223c77cc9b2efa21dd31e" name="a855ee58954b223c77cc9b2efa21dd31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855ee58954b223c77cc9b2efa21dd31e">&#9670;&#160;</a></span>sat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1.html">tcons1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy an arbitrary constraint. </p>

</div>
</div>
<a id="a1f4f19c3e1dd25a092294a97680650f9" name="a1f4f19c3e1dd25a092294a97680650f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4f19c3e1dd25a092294a97680650f9">&#9670;&#160;</a></span>sat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract1::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the component v of all points in *this is included in the given interval. </p>

</div>
</div>
<a id="a9f2d927f165d9b4c323adbba6f571578" name="a9f2d927f165d9b4c323adbba6f571578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2d927f165d9b4c323adbba6f571578">&#9670;&#160;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string * abstract1::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes an abstract element. </p>
<p>The string can be safely stored to disk and reloaded later or transmitted across a network. The format is library-specific but is generally a machine-readable byte-stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated string that the caller should delete it after use. </dd></dl>

</div>
</div>
<a id="afbdae15c48b20cb1e76ec5c33f7a78a9" name="afbdae15c48b20cb1e76ec5c33f7a78a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdae15c48b20cb1e76ec5c33f7a78a9">&#9670;&#160;</a></span>set() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the empty set. </p>
<p>Does not change the environment.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a91393622e71700a39c71380c6bf2720d" name="a91393622e71700a39c71380c6bf2720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91393622e71700a39c71380c6bf2720d">&#9670;&#160;</a></span>set() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a copy of x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a42a76d3271d0392280af8ff54b92b6df" name="a42a76d3271d0392280af8ff54b92b6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a76d3271d0392280af8ff54b92b6df">&#9670;&#160;</a></span>set() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the empty set. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a9d068a7df8f1190bcd028543d045bdc8" name="a9d068a7df8f1190bcd028543d045bdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d068a7df8f1190bcd028543d045bdc8">&#9670;&#160;</a></span>set() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a7c65658443862e2a490c5cbb450fe613" name="a7c65658443862e2a490c5cbb450fe613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65658443862e2a490c5cbb450fe613">&#9670;&#160;</a></span>set() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aec7c7c0de689b9d4b27b032a4d8e8333" name="aec7c7c0de689b9d4b27b032a4d8e8333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7c7c0de689b9d4b27b032a4d8e8333">&#9670;&#160;</a></span>set() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1environment.html">environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the full space. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa189dcc451d213fd2f0c562619f840f6" name="aa189dcc451d213fd2f0c562619f840f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa189dcc451d213fd2f0c562619f840f6">&#9670;&#160;</a></span>set() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<p>Does not change the environment.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a253431f62f1a765051f6a7288f51855a" name="a253431f62f1a765051f6a7288f51855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253431f62f1a765051f6a7288f51855a">&#9670;&#160;</a></span>set() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of linear constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a91fa2f49b715da57bc50a5e65b986f6f" name="a91fa2f49b715da57bc50a5e65b986f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fa2f49b715da57bc50a5e65b986f6f">&#9670;&#160;</a></span>set() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of arbitrary constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a3dd9d86948de72a842493e3abed86294" name="a3dd9d86948de72a842493e3abed86294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd9d86948de72a842493e3abed86294">&#9670;&#160;</a></span>set() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the full space. </p>
<p>Does not change the environment.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a0d7978d6548967192d3be35131828776" name="a0d7978d6548967192d3be35131828776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7978d6548967192d3be35131828776">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t abstract1::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (abstract) size of the abstract element. </p>
<p>The unit in which size is computed is library-specific. It is guaranteed to be the same as the unit for the <code>max_object_size</code> field of the ap_funopt_t structure. </p>

</div>
</div>
<a id="a5364f8a8f5db9521377ac33039602af6" name="a5364f8a8f5db9521377ac33039602af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5364f8a8f5db9521377ac33039602af6">&#9670;&#160;</a></span>substitute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecba5c006fbaa95d51f00bce067b928c" name="aecba5c006fbaa95d51f00bce067b928c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecba5c006fbaa95d51f00bce067b928c">&#9670;&#160;</a></span>substitute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classapron_1_1var.html">var</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee1d7a90ce9a94e0592426d7c7d2e8ce" name="aee1d7a90ce9a94e0592426d7c7d2e8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1d7a90ce9a94e0592426d7c7d2e8ce">&#9670;&#160;</a></span>substitute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of linear expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ae8b56b16d317876ea6ff9c97c3a77f6f" name="ae8b56b16d317876ea6ff9c97c3a77f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b56b16d317876ea6ff9c97c3a77f6f">&#9670;&#160;</a></span>substitute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to variable v. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa12d1ae0c1771350d104eef6d3f5ecfa" name="aa12d1ae0c1771350d104eef6d3f5ecfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12d1ae0c1771350d104eef6d3f5ecfa">&#9670;&#160;</a></span>substitute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr1.html">linexpr1</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="adf8aa8c6894236f0dffcceaa732ba2ec" name="adf8aa8c6894236f0dffcceaa732ba2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8aa8c6894236f0dffcceaa732ba2ec">&#9670;&#160;</a></span>substitute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1var.html">var</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr1.html">texpr1</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a3994902b1385eef6523d2f7b6e61f86c">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to variable v[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a61426b2c51ea83f90ff7863cebc34cfb" name="a61426b2c51ea83f90ff7863cebc34cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61426b2c51ea83f90ff7863cebc34cfb">&#9670;&#160;</a></span>to_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval__array.html">interval_array</a> abstract1::to_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bounding box for the set represented by the abstract element. </p>

</div>
</div>
<a id="a69339cb2be90a806bec2b6e674b2058d" name="a69339cb2be90a806bec2b6e674b2058d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69339cb2be90a806bec2b6e674b2058d">&#9670;&#160;</a></span>to_generator_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1generator1__array.html">generator1_array</a> abstract1::to_generator_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a generator representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="afdef105472739af42c8a7f90389db29c" name="afdef105472739af42c8a7f90389db29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdef105472739af42c8a7f90389db29c">&#9670;&#160;</a></span>to_lincons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1lincons1__array.html">lincons1_array</a> abstract1::to_lincons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="ab944dee440aaf0c3ce4b6c1cbd83050c" name="ab944dee440aaf0c3ce4b6c1cbd83050c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab944dee440aaf0c3ce4b6c1cbd83050c">&#9670;&#160;</a></span>to_tcons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1tcons1__array.html">tcons1_array</a> abstract1::to_tcons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="a7bba32c363a51d9b2296a2470baabc93" name="a7bba32c363a51d9b2296a2470baabc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bba32c363a51d9b2296a2470baabc93">&#9670;&#160;</a></span>unify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp; abstract1::unify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<p>*this and y can have different environment. They are first embedded into the least common environment before the meet is computed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac46e4c0ba148a29a83394974350cd6d2" name="ac46e4c0ba148a29a83394974350cd6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46e4c0ba148a29a83394974350cd6d2">&#9670;&#160;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract1_t apron::abstract1::a</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Structure managed by APRON. </p>

</div>
</div>
<a id="a3994902b1385eef6523d2f7b6e61f86c" name="a3994902b1385eef6523d2f7b6e61f86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3994902b1385eef6523d2f7b6e61f86c">&#9670;&#160;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classapron_1_1abstract1.html">abstract1</a> apron::abstract1::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NULL abstract element, to be used only as default argument in assign and substitute. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract1_8hh_source.html">apxx_abstract1.hh</a></li>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract1__inline_8hh_source.html">apxx_abstract1_inline.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 29 2025 12:06:48 for APRONXX by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
