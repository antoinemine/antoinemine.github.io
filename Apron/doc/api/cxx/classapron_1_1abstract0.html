<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APRONXX: apron::abstract0 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">APRONXX
   &#160;<span id="projectnumber">0.9.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceapron.html">apron</a></li><li class="navelem"><a class="el" href="classapron_1_1abstract0.html">abstract0</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classapron_1_1abstract0-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">apron::abstract0 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Level 0 abstract value (ap_abstract0_t* wrapper).  
 <a href="classapron_1_1abstract0.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="apxx__abstract0_8hh_source.html">apxx_abstract0.hh</a>&gt;</code></p>

<p>Inherits <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a47720402023ba5b5378390ed4c5206e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a47720402023ba5b5378390ed4c5206e3">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, <a class="el" href="structapron_1_1top.html">top</a> x)</td></tr>
<tr class="memdesc:a47720402023ba5b5378390ed4c5206e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the whole space.  <a href="#a47720402023ba5b5378390ed4c5206e3">More...</a><br /></td></tr>
<tr class="separator:a47720402023ba5b5378390ed4c5206e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83420d0e0f11695e1c3a544b864fa36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#af83420d0e0f11695e1c3a544b864fa36">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, <a class="el" href="structapron_1_1bottom.html">bottom</a> x)</td></tr>
<tr class="memdesc:af83420d0e0f11695e1c3a544b864fa36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the empty set.  <a href="#af83420d0e0f11695e1c3a544b864fa36">More...</a><br /></td></tr>
<tr class="separator:af83420d0e0f11695e1c3a544b864fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da4b783ea69e4655502d1637f55a98a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a2da4b783ea69e4655502d1637f55a98a">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a2da4b783ea69e4655502d1637f55a98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <a href="#a2da4b783ea69e4655502d1637f55a98a">More...</a><br /></td></tr>
<tr class="separator:a2da4b783ea69e4655502d1637f55a98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc727bde899fbf168b7ce1dd6b61402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aacc727bde899fbf168b7ce1dd6b61402">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:aacc727bde899fbf168b7ce1dd6b61402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a box.  <a href="#aacc727bde899fbf168b7ce1dd6b61402">More...</a><br /></td></tr>
<tr class="separator:aacc727bde899fbf168b7ce1dd6b61402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a55c6e21eb9a2942c94bcf81702a19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a38a55c6e21eb9a2942c94bcf81702a19">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:a38a55c6e21eb9a2942c94bcf81702a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of linear constraints.  <a href="#a38a55c6e21eb9a2942c94bcf81702a19">More...</a><br /></td></tr>
<tr class="separator:a38a55c6e21eb9a2942c94bcf81702a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd5bdcf44d170dde123e1b2d403e1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ac1bd5bdcf44d170dde123e1b2d403e1a">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:ac1bd5bdcf44d170dde123e1b2d403e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of arbitrary constraints.  <a href="#ac1bd5bdcf44d170dde123e1b2d403e1a">More...</a><br /></td></tr>
<tr class="separator:ac1bd5bdcf44d170dde123e1b2d403e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345867b8095f2cb3587f32c4d085afe5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a345867b8095f2cb3587f32c4d085afe5">abstract0</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a345867b8095f2cb3587f32c4d085afe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <a href="#a345867b8095f2cb3587f32c4d085afe5">More...</a><br /></td></tr>
<tr class="separator:a345867b8095f2cb3587f32c4d085afe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr class="memitem:ae9c7c340d33af5013e6a29500d3710a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae9c7c340d33af5013e6a29500d3710a3">~abstract0</a> ()</td></tr>
<tr class="memdesc:ae9c7c340d33af5013e6a29500d3710a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element.  <a href="#ae9c7c340d33af5013e6a29500d3710a3">More...</a><br /></td></tr>
<tr class="separator:ae9c7c340d33af5013e6a29500d3710a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e60165bf1962ee9dbb8c207c2c56e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a39e60165bf1962ee9dbb8c207c2c56e8">free</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a39e60165bf1962ee9dbb8c207c2c56e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element using the given manager.  <a href="#a39e60165bf1962ee9dbb8c207c2c56e8">More...</a><br /></td></tr>
<tr class="separator:a39e60165bf1962ee9dbb8c207c2c56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Copies and conversions to abstract elements</div></td></tr>
<tr class="memitem:a991b63c268bdbed29e2fac7d44cd7167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a991b63c268bdbed29e2fac7d44cd7167">operator=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a991b63c268bdbed29e2fac7d44cd7167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a copy of t to *this.  <a href="#a991b63c268bdbed29e2fac7d44cd7167">More...</a><br /></td></tr>
<tr class="separator:a991b63c268bdbed29e2fac7d44cd7167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e212ccde834e62fe4c4cbc006415bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aa6e212ccde834e62fe4c4cbc006415bd">operator=</a> (<a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:aa6e212ccde834e62fe4c4cbc006415bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the full space to *this.  <a href="#aa6e212ccde834e62fe4c4cbc006415bd">More...</a><br /></td></tr>
<tr class="separator:aa6e212ccde834e62fe4c4cbc006415bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e12b7728038f0c8f990a31758ad291f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5e12b7728038f0c8f990a31758ad291f">operator=</a> (<a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:a5e12b7728038f0c8f990a31758ad291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the empty set to *this.  <a href="#a5e12b7728038f0c8f990a31758ad291f">More...</a><br /></td></tr>
<tr class="separator:a5e12b7728038f0c8f990a31758ad291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7043b7f05fc23ac032f0b12f6286b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a3d7043b7f05fc23ac032f0b12f6286b7">operator=</a> (const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a3d7043b7f05fc23ac032f0b12f6286b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a box to *this.  <a href="#a3d7043b7f05fc23ac032f0b12f6286b7">More...</a><br /></td></tr>
<tr class="separator:a3d7043b7f05fc23ac032f0b12f6286b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae189bac5b66bb54a6035146b189ac31a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae189bac5b66bb54a6035146b189ac31a">operator=</a> (const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:ae189bac5b66bb54a6035146b189ac31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of linear constraints to *this.  <a href="#ae189bac5b66bb54a6035146b189ac31a">More...</a><br /></td></tr>
<tr class="separator:ae189bac5b66bb54a6035146b189ac31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de9e63831781c5196cd2fc3ac5189b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0de9e63831781c5196cd2fc3ac5189b8">operator=</a> (const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:a0de9e63831781c5196cd2fc3ac5189b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of arbitrary constraints to *this.  <a href="#a0de9e63831781c5196cd2fc3ac5189b8">More...</a><br /></td></tr>
<tr class="separator:a0de9e63831781c5196cd2fc3ac5189b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f304a032eb83b75c4dc7dd91c8666cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0f304a032eb83b75c4dc7dd91c8666cf">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x)</td></tr>
<tr class="memdesc:a0f304a032eb83b75c4dc7dd91c8666cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a copy of x.  <a href="#a0f304a032eb83b75c4dc7dd91c8666cf">More...</a><br /></td></tr>
<tr class="separator:a0f304a032eb83b75c4dc7dd91c8666cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e81dbfaa49410805f96037c9612aee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a1e81dbfaa49410805f96037c9612aee1">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1top.html">top</a> t, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:a1e81dbfaa49410805f96037c9612aee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the full space.  <a href="#a1e81dbfaa49410805f96037c9612aee1">More...</a><br /></td></tr>
<tr class="separator:a1e81dbfaa49410805f96037c9612aee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac442226bf6efafa4a739a61d76c09caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ac442226bf6efafa4a739a61d76c09caf">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1bottom.html">bottom</a> t, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:ac442226bf6efafa4a739a61d76c09caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the empty set.  <a href="#ac442226bf6efafa4a739a61d76c09caf">More...</a><br /></td></tr>
<tr class="separator:ac442226bf6efafa4a739a61d76c09caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680eec402729a6e8e7e2c7773756ec94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a680eec402729a6e8e7e2c7773756ec94">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:a680eec402729a6e8e7e2c7773756ec94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <a href="#a680eec402729a6e8e7e2c7773756ec94">More...</a><br /></td></tr>
<tr class="separator:a680eec402729a6e8e7e2c7773756ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5fdcb4af7130ab402a699ffd11cc6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a7b5fdcb4af7130ab402a699ffd11cc6a">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;x, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:a7b5fdcb4af7130ab402a699ffd11cc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of linear constraints.  <a href="#a7b5fdcb4af7130ab402a699ffd11cc6a">More...</a><br /></td></tr>
<tr class="separator:a7b5fdcb4af7130ab402a699ffd11cc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1ce6a6f0144dbcd06355c75df1bef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#acf1ce6a6f0144dbcd06355c75df1bef6">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;x, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:acf1ce6a6f0144dbcd06355c75df1bef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of arbitrary constraints.  <a href="#acf1ce6a6f0144dbcd06355c75df1bef6">More...</a><br /></td></tr>
<tr class="separator:acf1ce6a6f0144dbcd06355c75df1bef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Control of internal representation</div></td></tr>
<tr class="memitem:a97812eb92ef7ad2155367eeb99b161fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a97812eb92ef7ad2155367eeb99b161fe">minimize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a97812eb92ef7ad2155367eeb99b161fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimizes the size of the representation, to save memory.  <a href="#a97812eb92ef7ad2155367eeb99b161fe">More...</a><br /></td></tr>
<tr class="separator:a97812eb92ef7ad2155367eeb99b161fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949de6ba2d6ccb862c689a8f8b977822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a949de6ba2d6ccb862c689a8f8b977822">canonicalize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a949de6ba2d6ccb862c689a8f8b977822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the abstract element in canonical form (if such a notion exists).  <a href="#a949de6ba2d6ccb862c689a8f8b977822">More...</a><br /></td></tr>
<tr class="separator:a949de6ba2d6ccb862c689a8f8b977822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7215e4ba3298da7f66b835a95560ea62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a7215e4ba3298da7f66b835a95560ea62">approximate</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, int algorithm)</td></tr>
<tr class="memdesc:a7215e4ba3298da7f66b835a95560ea62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the abstract element, potentially loosing precision.  <a href="#a7215e4ba3298da7f66b835a95560ea62">More...</a><br /></td></tr>
<tr class="separator:a7215e4ba3298da7f66b835a95560ea62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr class="memitem:a78360af632ff0a307e50ec155b688d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1manager.html">manager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a78360af632ff0a307e50ec155b688d09">get_manager</a> () const</td></tr>
<tr class="memdesc:a78360af632ff0a307e50ec155b688d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the manager the abstract element was created with (with reference count incremented).  <a href="#a78360af632ff0a307e50ec155b688d09">More...</a><br /></td></tr>
<tr class="separator:a78360af632ff0a307e50ec155b688d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea39fa14594c33e0b585dfa5f68c3894"><td class="memItemLeft" align="right" valign="top">ap_dimension_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aea39fa14594c33e0b585dfa5f68c3894">get_dimension</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:aea39fa14594c33e0b585dfa5f68c3894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of integer and real dimensions in the abstract element.  <a href="#aea39fa14594c33e0b585dfa5f68c3894">More...</a><br /></td></tr>
<tr class="separator:aea39fa14594c33e0b585dfa5f68c3894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f7b4c634f4cdaa2aeaf46f9618105e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:ac1f7b4c634f4cdaa2aeaf46f9618105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (abstract) size of the abstract element.  <a href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">More...</a><br /></td></tr>
<tr class="separator:ac1f7b4c634f4cdaa2aeaf46f9618105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property extraction</div></td></tr>
<tr class="memitem:ad3bfcde8e04c8fd2371cf62ee719f535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ad3bfcde8e04c8fd2371cf62ee719f535">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l) const</td></tr>
<tr class="memdesc:ad3bfcde8e04c8fd2371cf62ee719f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for a linear expression evaluated in all points in the abstract element.  <a href="#ad3bfcde8e04c8fd2371cf62ee719f535">More...</a><br /></td></tr>
<tr class="separator:ad3bfcde8e04c8fd2371cf62ee719f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d2040cf521822aabe729a159c99b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a22d2040cf521822aabe729a159c99b53">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l) const</td></tr>
<tr class="memdesc:a22d2040cf521822aabe729a159c99b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for an arbitrary expression evaluated in all points in the abstract element.  <a href="#a22d2040cf521822aabe729a159c99b53">More...</a><br /></td></tr>
<tr class="separator:a22d2040cf521822aabe729a159c99b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2489df6d4cd5578c8dff76ea45d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#af2c2489df6d4cd5578c8dff76ea45d53">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t d) const</td></tr>
<tr class="memdesc:af2c2489df6d4cd5578c8dff76ea45d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for the given coordinate on all points in the abstract element.  <a href="#af2c2489df6d4cd5578c8dff76ea45d53">More...</a><br /></td></tr>
<tr class="separator:af2c2489df6d4cd5578c8dff76ea45d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ec014691a2646c4c78effbacb185c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval__array.html">interval_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a028ec014691a2646c4c78effbacb185c">to_box</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a028ec014691a2646c4c78effbacb185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bounding box for the set represented by the abstract element.  <a href="#a028ec014691a2646c4c78effbacb185c">More...</a><br /></td></tr>
<tr class="separator:a028ec014691a2646c4c78effbacb185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcdc01b87c1d2beecdb07a8297a9ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1generator0__array.html">generator0_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aabcdc01b87c1d2beecdb07a8297a9ca7">to_generator_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:aabcdc01b87c1d2beecdb07a8297a9ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generator representation of (an over-approximation of) the set represented by the abstract element.  <a href="#aabcdc01b87c1d2beecdb07a8297a9ca7">More...</a><br /></td></tr>
<tr class="separator:aabcdc01b87c1d2beecdb07a8297a9ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6af1b50ab4747690a09a24687af4e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a2f6af1b50ab4747690a09a24687af4e6">to_lincons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a2f6af1b50ab4747690a09a24687af4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element.  <a href="#a2f6af1b50ab4747690a09a24687af4e6">More...</a><br /></td></tr>
<tr class="separator:a2f6af1b50ab4747690a09a24687af4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ec6b5d4ca8b8047351f411094da8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a669ec6b5d4ca8b8047351f411094da8e">to_tcons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a669ec6b5d4ca8b8047351f411094da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constraint representation of (an over-approximation of) the set represented by the abstract element.  <a href="#a669ec6b5d4ca8b8047351f411094da8e">More...</a><br /></td></tr>
<tr class="separator:a669ec6b5d4ca8b8047351f411094da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C API compatibility</div></td></tr>
<tr class="memitem:a827e433f2875073e98ed2b290230b42e"><td class="memItemLeft" align="right" valign="top">ap_abstract0_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a827e433f2875073e98ed2b290230b42e">get_ap_abstract0_t</a> ()</td></tr>
<tr class="memdesc:a827e433f2875073e98ed2b290230b42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <a href="#a827e433f2875073e98ed2b290230b42e">More...</a><br /></td></tr>
<tr class="separator:a827e433f2875073e98ed2b290230b42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6122cfcdc68fbbeef4702a25ba94ae4"><td class="memItemLeft" align="right" valign="top">const ap_abstract0_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae6122cfcdc68fbbeef4702a25ba94ae4">get_ap_abstract0_t</a> () const</td></tr>
<tr class="memdesc:ae6122cfcdc68fbbeef4702a25ba94ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <a href="#ae6122cfcdc68fbbeef4702a25ba94ae4">More...</a><br /></td></tr>
<tr class="separator:ae6122cfcdc68fbbeef4702a25ba94ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structapron_1_1use__malloc"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structapron_1_1use__malloc')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a></td></tr>
<tr class="memitem:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a886761279a3b4508e689a4115060ad9f">operator new</a> (size_t sz)</td></tr>
<tr class="separator:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1a5ca8977532c5975ef94b5cd382da09">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a6049364eb61e4e9767a7eafafd3f52dc">operator delete</a> (void *p)</td></tr>
<tr class="separator:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1547897dbcdc951e206b53bb0e3b57ef">operator delete[]</a> (void *p)</td></tr>
<tr class="separator:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5b9da766a1817a41d7ad3c739902e3c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5b9da766a1817a41d7ad3c739902e3c7">abstract0</a> (ap_abstract0_t *x)</td></tr>
<tr class="memdesc:a5b9da766a1817a41d7ad3c739902e3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only. Wraps an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> around the pointer x, taking ownership of the object.  <a href="#a5b9da766a1817a41d7ad3c739902e3c7">More...</a><br /></td></tr>
<tr class="separator:a5b9da766a1817a41d7ad3c739902e3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7704fa4e2822eef41be9e570cf6a21c2"><td class="memItemLeft" align="right" valign="top">ap_abstract0_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a7704fa4e2822eef41be9e570cf6a21c2">a</a></td></tr>
<tr class="memdesc:a7704fa4e2822eef41be9e570cf6a21c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer managed by APRON.  <a href="#a7704fa4e2822eef41be9e570cf6a21c2">More...</a><br /></td></tr>
<tr class="separator:a7704fa4e2822eef41be9e570cf6a21c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5aadba4862f59ae21ffd467661f247a5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classapron_1_1abstract0.html">abstract0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></td></tr>
<tr class="memdesc:a5aadba4862f59ae21ffd467661f247a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL abstract element, to be used only as default argument in assign and substitute.  <a href="#a5aadba4862f59ae21ffd467661f247a5">More...</a><br /></td></tr>
<tr class="separator:a5aadba4862f59ae21ffd467661f247a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Widening</div></td></tr>
<tr class="memitem:a5ac1e0ee4bbb4f8fa02ce781cc27712e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5ac1e0ee4bbb4f8fa02ce781cc27712e">widening</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a5ac1e0ee4bbb4f8fa02ce781cc27712e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of x widened with y.  <a href="#a5ac1e0ee4bbb4f8fa02ce781cc27712e">More...</a><br /></td></tr>
<tr class="separator:a5ac1e0ee4bbb4f8fa02ce781cc27712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7e6dd64ae824216262935c0ac05bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a00f7e6dd64ae824216262935c0ac05bd">widening</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;l)</td></tr>
<tr class="memdesc:a00f7e6dd64ae824216262935c0ac05bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of x widened with y, using some widening thresholds.  <a href="#a00f7e6dd64ae824216262935c0ac05bd">More...</a><br /></td></tr>
<tr class="separator:a00f7e6dd64ae824216262935c0ac05bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Printing</h2></td></tr>
<tr class="memitem:af71edee802455ccf0771b9aabb985753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#af71edee802455ccf0771b9aabb985753">printdiff</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y, char **name_of_dim, FILE *stream)</td></tr>
<tr class="memdesc:af71edee802455ccf0771b9aabb985753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-printing the difference between x and y to a C stream.  <a href="#af71edee802455ccf0771b9aabb985753">More...</a><br /></td></tr>
<tr class="separator:af71edee802455ccf0771b9aabb985753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbeca61b6c9414c116e7fa4b49cff58"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a1bbeca61b6c9414c116e7fa4b49cff58">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;s)</td></tr>
<tr class="memdesc:a1bbeca61b6c9414c116e7fa4b49cff58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints in constraint form.  <a href="#a1bbeca61b6c9414c116e7fa4b49cff58">More...</a><br /></td></tr>
<tr class="separator:a1bbeca61b6c9414c116e7fa4b49cff58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ddbea873bf9284071a840bef83b79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae3ddbea873bf9284071a840bef83b79f">print</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, char **name_of_dim=NULL, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:ae3ddbea873bf9284071a840bef83b79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-printing to a C stream.  <a href="#ae3ddbea873bf9284071a840bef83b79f">More...</a><br /></td></tr>
<tr class="separator:ae3ddbea873bf9284071a840bef83b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8893cfe891544972d4d840638fe692ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a8893cfe891544972d4d840638fe692ce">dump</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:a8893cfe891544972d4d840638fe692ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw printing to a C stream (mainly for debug purposes).  <a href="#a8893cfe891544972d4d840638fe692ce">More...</a><br /></td></tr>
<tr class="separator:a8893cfe891544972d4d840638fe692ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Serialisation</h2></td></tr>
<tr class="memitem:addd31837987d25c058e08ce280389e12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#addd31837987d25c058e08ce280389e12">deserialize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const std::string &amp;s, size_t *eaten)</td></tr>
<tr class="memdesc:addd31837987d25c058e08ce280389e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct an abstract element form a serialized byte-stream and put it into dst.  <a href="#addd31837987d25c058e08ce280389e12">More...</a><br /></td></tr>
<tr class="separator:addd31837987d25c058e08ce280389e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd22f0663c916eeb92784639f4565d1b"><td class="memItemLeft" align="right" valign="top">std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#abd22f0663c916eeb92784639f4565d1b">serialize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:abd22f0663c916eeb92784639f4565d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an abstract element.  <a href="#abd22f0663c916eeb92784639f4565d1b">More...</a><br /></td></tr>
<tr class="separator:abd22f0663c916eeb92784639f4565d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predicates</h2></td></tr>
<tr class="memitem:a0196e7f2f52c507845482ebab1baf630"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0196e7f2f52c507845482ebab1baf630">operator==</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a0196e7f2f52c507845482ebab1baf630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x and y represent the same set.  <a href="#a0196e7f2f52c507845482ebab1baf630">More...</a><br /></td></tr>
<tr class="separator:a0196e7f2f52c507845482ebab1baf630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad426e9cd549c3ce1f4b4a187c353dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aad426e9cd549c3ce1f4b4a187c353dc4">operator!=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:aad426e9cd549c3ce1f4b4a187c353dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x and y represent different sets.  <a href="#aad426e9cd549c3ce1f4b4a187c353dc4">More...</a><br /></td></tr>
<tr class="separator:aad426e9cd549c3ce1f4b4a187c353dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddf1a5c8a9bb8cb9af7a7a0863e70f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a3ddf1a5c8a9bb8cb9af7a7a0863e70f1">operator&lt;=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a3ddf1a5c8a9bb8cb9af7a7a0863e70f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x is included within y (set-wise).  <a href="#a3ddf1a5c8a9bb8cb9af7a7a0863e70f1">More...</a><br /></td></tr>
<tr class="separator:a3ddf1a5c8a9bb8cb9af7a7a0863e70f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f38f23b7d75b47ed069498c207c16a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aa3f38f23b7d75b47ed069498c207c16a">operator&gt;=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:aa3f38f23b7d75b47ed069498c207c16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x contains y (set-wise).  <a href="#aa3f38f23b7d75b47ed069498c207c16a">More...</a><br /></td></tr>
<tr class="separator:aa3f38f23b7d75b47ed069498c207c16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e28097c3860312abf87e86663db1cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a42e28097c3860312abf87e86663db1cf">operator&gt;</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a42e28097c3860312abf87e86663db1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x strictly contains y (set-wise).  <a href="#a42e28097c3860312abf87e86663db1cf">More...</a><br /></td></tr>
<tr class="separator:a42e28097c3860312abf87e86663db1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a3ee60358edf3c5c14196e6dde9de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a4d4a3ee60358edf3c5c14196e6dde9de">operator&lt;</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a4d4a3ee60358edf3c5c14196e6dde9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether x is strictly included within y (set-wise).  <a href="#a4d4a3ee60358edf3c5c14196e6dde9de">More...</a><br /></td></tr>
<tr class="separator:a4d4a3ee60358edf3c5c14196e6dde9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef077940578d27ea281ec8838fb0548c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aef077940578d27ea281ec8838fb0548c">is_bottom</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:aef077940578d27ea281ec8838fb0548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the empty set.  <a href="#aef077940578d27ea281ec8838fb0548c">More...</a><br /></td></tr>
<tr class="separator:aef077940578d27ea281ec8838fb0548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae4abccf24b03fbc9a84d1c9e2dad3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#acae4abccf24b03fbc9a84d1c9e2dad3c">is_top</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:acae4abccf24b03fbc9a84d1c9e2dad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the full space.  <a href="#acae4abccf24b03fbc9a84d1c9e2dad3c">More...</a><br /></td></tr>
<tr class="separator:acae4abccf24b03fbc9a84d1c9e2dad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77769eec2a835b68309495758b583175"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a77769eec2a835b68309495758b583175">is_eq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x) const</td></tr>
<tr class="memdesc:a77769eec2a835b68309495758b583175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this and x represent the same set.  <a href="#a77769eec2a835b68309495758b583175">More...</a><br /></td></tr>
<tr class="separator:a77769eec2a835b68309495758b583175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cd8dd502422c80a947e6bea1af42ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a97cd8dd502422c80a947e6bea1af42ee">is_leq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x) const</td></tr>
<tr class="memdesc:a97cd8dd502422c80a947e6bea1af42ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this is included in x (set-wise).  <a href="#a97cd8dd502422c80a947e6bea1af42ee">More...</a><br /></td></tr>
<tr class="separator:a97cd8dd502422c80a947e6bea1af42ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd9bca89afa9264d570fc2194b9a6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ac8dd9bca89afa9264d570fc2194b9a6f">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons0.html">lincons0</a> &amp;l) const</td></tr>
<tr class="memdesc:ac8dd9bca89afa9264d570fc2194b9a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy a linear constraint.  <a href="#ac8dd9bca89afa9264d570fc2194b9a6f">More...</a><br /></td></tr>
<tr class="separator:ac8dd9bca89afa9264d570fc2194b9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584ba85a584bc1b01dd1b7bf9cd6387"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#af584ba85a584bc1b01dd1b7bf9cd6387">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons0.html">tcons0</a> &amp;l) const</td></tr>
<tr class="memdesc:af584ba85a584bc1b01dd1b7bf9cd6387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy an arbitrary constraint.  <a href="#af584ba85a584bc1b01dd1b7bf9cd6387">More...</a><br /></td></tr>
<tr class="separator:af584ba85a584bc1b01dd1b7bf9cd6387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80026a2875138c133476860b2e100263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a80026a2875138c133476860b2e100263">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;i) const</td></tr>
<tr class="memdesc:a80026a2875138c133476860b2e100263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the dimension dim of all points in *this is included in the given interval.  <a href="#a80026a2875138c133476860b2e100263">More...</a><br /></td></tr>
<tr class="separator:a80026a2875138c133476860b2e100263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc789b4786aaa2159fadb635c80ea9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#adfc789b4786aaa2159fadb635c80ea9c">is_dimension_unconstrained</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>) const</td></tr>
<tr class="memdesc:adfc789b4786aaa2159fadb635c80ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the points in *this are unbounded in the given dimension.  <a href="#adfc789b4786aaa2159fadb635c80ea9c">More...</a><br /></td></tr>
<tr class="separator:adfc789b4786aaa2159fadb635c80ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Meet</h2></td></tr>
<tr class="memitem:acc427355eb152f899f8972ce35f93634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#acc427355eb152f899f8972ce35f93634">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:acc427355eb152f899f8972ce35f93634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and y.  <a href="#acc427355eb152f899f8972ce35f93634">More...</a><br /></td></tr>
<tr class="separator:acc427355eb152f899f8972ce35f93634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a548eff25b721c56ea9bbe60b15638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae6a548eff25b721c56ea9bbe60b15638">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const std::vector&lt; const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> * &gt; &amp;x)</td></tr>
<tr class="memdesc:ae6a548eff25b721c56ea9bbe60b15638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of all abstract elements in x.  <a href="#ae6a548eff25b721c56ea9bbe60b15638">More...</a><br /></td></tr>
<tr class="separator:ae6a548eff25b721c56ea9bbe60b15638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052088c74910f1717dc3411ad50d2c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae052088c74910f1717dc3411ad50d2c8">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> *const x[])</td></tr>
<tr class="memdesc:ae052088c74910f1717dc3411ad50d2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of all size abstract elements in x.  <a href="#ae052088c74910f1717dc3411ad50d2c8">More...</a><br /></td></tr>
<tr class="separator:ae052088c74910f1717dc3411ad50d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee42afb4b2079815ca7fb58d4e0a9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0ee42afb4b2079815ca7fb58d4e0a9bd">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a0ee42afb4b2079815ca7fb58d4e0a9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and some linear constraints.  <a href="#a0ee42afb4b2079815ca7fb58d4e0a9bd">More...</a><br /></td></tr>
<tr class="separator:a0ee42afb4b2079815ca7fb58d4e0a9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89119589f6d92b37749c54f9620bfbfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a89119589f6d92b37749c54f9620bfbfa">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a89119589f6d92b37749c54f9620bfbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the meet of x and some arbitrary constraints.  <a href="#a89119589f6d92b37749c54f9620bfbfa">More...</a><br /></td></tr>
<tr class="separator:a89119589f6d92b37749c54f9620bfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a623a045bb56acfed7a005bc38c95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a66a623a045bb56acfed7a005bc38c95a">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a66a623a045bb56acfed7a005bc38c95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <a href="#a66a623a045bb56acfed7a005bc38c95a">More...</a><br /></td></tr>
<tr class="separator:a66a623a045bb56acfed7a005bc38c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315d46d075b64867c8acd449066bca35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a315d46d075b64867c8acd449066bca35">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a315d46d075b64867c8acd449066bca35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <a href="#a315d46d075b64867c8acd449066bca35">More...</a><br /></td></tr>
<tr class="separator:a315d46d075b64867c8acd449066bca35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322cbef8760029ab9813e50192ef2e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a322cbef8760029ab9813e50192ef2e2e">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a322cbef8760029ab9813e50192ef2e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <a href="#a322cbef8760029ab9813e50192ef2e2e">More...</a><br /></td></tr>
<tr class="separator:a322cbef8760029ab9813e50192ef2e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ce16b175bb96f9c06fcc8fcfddfc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a87ce16b175bb96f9c06fcc8fcfddfc11">operator *=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a87ce16b175bb96f9c06fcc8fcfddfc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <a href="#a87ce16b175bb96f9c06fcc8fcfddfc11">More...</a><br /></td></tr>
<tr class="separator:a87ce16b175bb96f9c06fcc8fcfddfc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce14f7dfb6205628412f08559fe78bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a1ce14f7dfb6205628412f08559fe78bf">operator *=</a> (const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a1ce14f7dfb6205628412f08559fe78bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <a href="#a1ce14f7dfb6205628412f08559fe78bf">More...</a><br /></td></tr>
<tr class="separator:a1ce14f7dfb6205628412f08559fe78bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab5b8785fe4b33ae0c6375402f5e45c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aeab5b8785fe4b33ae0c6375402f5e45c">operator *=</a> (const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:aeab5b8785fe4b33ae0c6375402f5e45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <a href="#aeab5b8785fe4b33ae0c6375402f5e45c">More...</a><br /></td></tr>
<tr class="separator:aeab5b8785fe4b33ae0c6375402f5e45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Join</h2></td></tr>
<tr class="memitem:a4f3caf40f06525f2f0850a0c75eefc95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a4f3caf40f06525f2f0850a0c75eefc95">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a4f3caf40f06525f2f0850a0c75eefc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the join of x and y.  <a href="#a4f3caf40f06525f2f0850a0c75eefc95">More...</a><br /></td></tr>
<tr class="separator:a4f3caf40f06525f2f0850a0c75eefc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae327dba80f59aae4fced1399cda3faed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae327dba80f59aae4fced1399cda3faed">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const std::vector&lt; const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> * &gt; &amp;x)</td></tr>
<tr class="memdesc:ae327dba80f59aae4fced1399cda3faed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the join of all abstract elements in x.  <a href="#ae327dba80f59aae4fced1399cda3faed">More...</a><br /></td></tr>
<tr class="separator:ae327dba80f59aae4fced1399cda3faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c6c8b390090144e5128511cbf16845"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a94c6c8b390090144e5128511cbf16845">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> *const x[])</td></tr>
<tr class="memdesc:a94c6c8b390090144e5128511cbf16845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with the join of all size abstract elements in x.  <a href="#a94c6c8b390090144e5128511cbf16845">More...</a><br /></td></tr>
<tr class="separator:a94c6c8b390090144e5128511cbf16845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aa9c376b7bc1144bd68a048000e82a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a09aa9c376b7bc1144bd68a048000e82a">add_rays</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x, const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a09aa9c376b7bc1144bd68a048000e82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with x with some rays added.  <a href="#a09aa9c376b7bc1144bd68a048000e82a">More...</a><br /></td></tr>
<tr class="separator:a09aa9c376b7bc1144bd68a048000e82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40907a86c978215e81d8f553c9053858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a40907a86c978215e81d8f553c9053858">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a40907a86c978215e81d8f553c9053858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <a href="#a40907a86c978215e81d8f553c9053858">More...</a><br /></td></tr>
<tr class="separator:a40907a86c978215e81d8f553c9053858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0afee9e56d9fdd1b8c163edaa51aa8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ab0afee9e56d9fdd1b8c163edaa51aa8b">add_rays</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;y)</td></tr>
<tr class="memdesc:ab0afee9e56d9fdd1b8c163edaa51aa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <a href="#ab0afee9e56d9fdd1b8c163edaa51aa8b">More...</a><br /></td></tr>
<tr class="separator:ab0afee9e56d9fdd1b8c163edaa51aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081d409ad6410a941951a09fa6573e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a081d409ad6410a941951a09fa6573e3a">operator+=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a081d409ad6410a941951a09fa6573e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <a href="#a081d409ad6410a941951a09fa6573e3a">More...</a><br /></td></tr>
<tr class="separator:a081d409ad6410a941951a09fa6573e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e9b2fd016578aeb05b9cf6e12a0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a6f2e9b2fd016578aeb05b9cf6e12a0fd">operator+=</a> (const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a6f2e9b2fd016578aeb05b9cf6e12a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <a href="#a6f2e9b2fd016578aeb05b9cf6e12a0fd">More...</a><br /></td></tr>
<tr class="separator:a6f2e9b2fd016578aeb05b9cf6e12a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Assignment</h2></td></tr>
<tr class="memitem:ab785e4d84d8f55f5d5a0f8fc55f46f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ab785e4d84d8f55f5d5a0f8fc55f46f8e">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:ab785e4d84d8f55f5d5a0f8fc55f46f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of linear expression.  <a href="#ab785e4d84d8f55f5d5a0f8fc55f46f8e">More...</a><br /></td></tr>
<tr class="separator:ab785e4d84d8f55f5d5a0f8fc55f46f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69479c1d7bfe19c9f21765e9310f7ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a69479c1d7bfe19c9f21765e9310f7ee5">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a69479c1d7bfe19c9f21765e9310f7ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of linear expressions.  <a href="#a69479c1d7bfe19c9f21765e9310f7ee5">More...</a><br /></td></tr>
<tr class="separator:a69479c1d7bfe19c9f21765e9310f7ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1720718e87bff8b845084baa467a3cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a1720718e87bff8b845084baa467a3cbf">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a1720718e87bff8b845084baa467a3cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of linear expressions.  <a href="#a1720718e87bff8b845084baa467a3cbf">More...</a><br /></td></tr>
<tr class="separator:a1720718e87bff8b845084baa467a3cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b893c408aa33a37311bd11763eac9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a97b893c408aa33a37311bd11763eac9f">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a97b893c408aa33a37311bd11763eac9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of arbitrary expression.  <a href="#a97b893c408aa33a37311bd11763eac9f">More...</a><br /></td></tr>
<tr class="separator:a97b893c408aa33a37311bd11763eac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d00f33c66ffb89bd81667a51f2d1853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a9d00f33c66ffb89bd81667a51f2d1853">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a9d00f33c66ffb89bd81667a51f2d1853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of arbitrary expressions.  <a href="#a9d00f33c66ffb89bd81667a51f2d1853">More...</a><br /></td></tr>
<tr class="separator:a9d00f33c66ffb89bd81667a51f2d1853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fff4d54d98b90078dc9b50cc6dfc46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a38fff4d54d98b90078dc9b50cc6dfc46">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a38fff4d54d98b90078dc9b50cc6dfc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel assignment of arbitrary expressions.  <a href="#a38fff4d54d98b90078dc9b50cc6dfc46">More...</a><br /></td></tr>
<tr class="separator:a38fff4d54d98b90078dc9b50cc6dfc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b658f699a6f447918194c5e29d15e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0b658f699a6f447918194c5e29d15e0d">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a0b658f699a6f447918194c5e29d15e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of linear expression.  <a href="#a0b658f699a6f447918194c5e29d15e0d">More...</a><br /></td></tr>
<tr class="separator:a0b658f699a6f447918194c5e29d15e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d70c5bdce42053a8eaa0a0a4708f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a678d70c5bdce42053a8eaa0a0a4708f9">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a678d70c5bdce42053a8eaa0a0a4708f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <a href="#a678d70c5bdce42053a8eaa0a0a4708f9">More...</a><br /></td></tr>
<tr class="separator:a678d70c5bdce42053a8eaa0a0a4708f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd574e03de9e1aef9eb8401627d48bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#acd574e03de9e1aef9eb8401627d48bfe">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:acd574e03de9e1aef9eb8401627d48bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <a href="#acd574e03de9e1aef9eb8401627d48bfe">More...</a><br /></td></tr>
<tr class="separator:acd574e03de9e1aef9eb8401627d48bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655a19c846835685d93976694327da8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a655a19c846835685d93976694327da8d">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a655a19c846835685d93976694327da8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of arbitrary expression.  <a href="#a655a19c846835685d93976694327da8d">More...</a><br /></td></tr>
<tr class="separator:a655a19c846835685d93976694327da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fb6b4c3eab4c5332a531ef83609202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a79fb6b4c3eab4c5332a531ef83609202">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a79fb6b4c3eab4c5332a531ef83609202"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <a href="#a79fb6b4c3eab4c5332a531ef83609202">More...</a><br /></td></tr>
<tr class="separator:a79fb6b4c3eab4c5332a531ef83609202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefc2ed88b02ade20cf2fe41325521f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5eefc2ed88b02ade20cf2fe41325521f">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a5eefc2ed88b02ade20cf2fe41325521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <a href="#a5eefc2ed88b02ade20cf2fe41325521f">More...</a><br /></td></tr>
<tr class="separator:a5eefc2ed88b02ade20cf2fe41325521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Substitution</h2></td></tr>
<tr class="memitem:a5479a2b0f14cf419b364d955b3d1319e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5479a2b0f14cf419b364d955b3d1319e">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a5479a2b0f14cf419b364d955b3d1319e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution (backward assignment) of linear expression.  <a href="#a5479a2b0f14cf419b364d955b3d1319e">More...</a><br /></td></tr>
<tr class="separator:a5479a2b0f14cf419b364d955b3d1319e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fd6749e560be394ff248ade8f61638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#af0fd6749e560be394ff248ade8f61638">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:af0fd6749e560be394ff248ade8f61638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of linear expressions.  <a href="#af0fd6749e560be394ff248ade8f61638">More...</a><br /></td></tr>
<tr class="separator:af0fd6749e560be394ff248ade8f61638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c2ed088b3d812fd1e32221b303be23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ab0c2ed088b3d812fd1e32221b303be23">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:ab0c2ed088b3d812fd1e32221b303be23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of linear expressions.  <a href="#ab0c2ed088b3d812fd1e32221b303be23">More...</a><br /></td></tr>
<tr class="separator:ab0c2ed088b3d812fd1e32221b303be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d412ec6328f62e66b00b532d5acaa40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a2d412ec6328f62e66b00b532d5acaa40">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:a2d412ec6328f62e66b00b532d5acaa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution (backward assignment) of arbitrary expression.  <a href="#a2d412ec6328f62e66b00b532d5acaa40">More...</a><br /></td></tr>
<tr class="separator:a2d412ec6328f62e66b00b532d5acaa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba71058f0d4950ca6df1a650bc4266cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aba71058f0d4950ca6df1a650bc4266cf">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:aba71058f0d4950ca6df1a650bc4266cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of arbitrary expressions.  <a href="#aba71058f0d4950ca6df1a650bc4266cf">More...</a><br /></td></tr>
<tr class="separator:aba71058f0d4950ca6df1a650bc4266cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88bd56a0c68a2c3468c0a78fb1f0786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ac88bd56a0c68a2c3468c0a78fb1f0786">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter)</td></tr>
<tr class="memdesc:ac88bd56a0c68a2c3468c0a78fb1f0786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel substitution (backward assignment) of arbitrary expressions.  <a href="#ac88bd56a0c68a2c3468c0a78fb1f0786">More...</a><br /></td></tr>
<tr class="separator:ac88bd56a0c68a2c3468c0a78fb1f0786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183128ae2c4a6f3c29713a0ee3c29796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a183128ae2c4a6f3c29713a0ee3c29796">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a183128ae2c4a6f3c29713a0ee3c29796"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of linear expression.  <a href="#a183128ae2c4a6f3c29713a0ee3c29796">More...</a><br /></td></tr>
<tr class="separator:a183128ae2c4a6f3c29713a0ee3c29796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df3b83fb6f98bfeb698e994d246f049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a9df3b83fb6f98bfeb698e994d246f049">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a9df3b83fb6f98bfeb698e994d246f049"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <a href="#a9df3b83fb6f98bfeb698e994d246f049">More...</a><br /></td></tr>
<tr class="separator:a9df3b83fb6f98bfeb698e994d246f049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab357a0a058d2f6d8a4b679d139f8206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aab357a0a058d2f6d8a4b679d139f8206">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:aab357a0a058d2f6d8a4b679d139f8206"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <a href="#aab357a0a058d2f6d8a4b679d139f8206">More...</a><br /></td></tr>
<tr class="separator:aab357a0a058d2f6d8a4b679d139f8206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8919101a7434d6fd58843f991306e356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a8919101a7434d6fd58843f991306e356">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a8919101a7434d6fd58843f991306e356"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of arbitrary expression.  <a href="#a8919101a7434d6fd58843f991306e356">More...</a><br /></td></tr>
<tr class="separator:a8919101a7434d6fd58843f991306e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a77c2c9b04f116c5ed88ea40c9b5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aa3a77c2c9b04f116c5ed88ea40c9b5a2">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:aa3a77c2c9b04f116c5ed88ea40c9b5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <a href="#aa3a77c2c9b04f116c5ed88ea40c9b5a2">More...</a><br /></td></tr>
<tr class="separator:aa3a77c2c9b04f116c5ed88ea40c9b5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102c11ea44a54b7b4967191f4e8a5cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a102c11ea44a54b7b4967191f4e8a5cf8">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a102c11ea44a54b7b4967191f4e8a5cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <a href="#a102c11ea44a54b7b4967191f4e8a5cf8">More...</a><br /></td></tr>
<tr class="separator:a102c11ea44a54b7b4967191f4e8a5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Projection, forget</h2></td></tr>
<tr class="memitem:a2b851b1b0d12f4972ab61ff0d69edb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a2b851b1b0d12f4972ab61ff0d69edb65">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, bool project)</td></tr>
<tr class="memdesc:a2b851b1b0d12f4972ab61ff0d69edb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of forgetting the value of dimension dim in src.  <a href="#a2b851b1b0d12f4972ab61ff0d69edb65">More...</a><br /></td></tr>
<tr class="separator:a2b851b1b0d12f4972ab61ff0d69edb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac66316dd5ae63ba596a951e361e0716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aac66316dd5ae63ba596a951e361e0716">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], bool project)</td></tr>
<tr class="memdesc:aac66316dd5ae63ba596a951e361e0716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of forgetting the value of dimensions dim[0] to dim[size-1] in src.  <a href="#aac66316dd5ae63ba596a951e361e0716">More...</a><br /></td></tr>
<tr class="separator:aac66316dd5ae63ba596a951e361e0716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ccdbe02dd954e8a2210a93d684e8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ae9ccdbe02dd954e8a2210a93d684e8f3">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const std::vector&lt; ap_dim_t &gt; <a class="el" href="classapron_1_1dim.html">dim</a>, bool project)</td></tr>
<tr class="memdesc:ae9ccdbe02dd954e8a2210a93d684e8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the result of forgetting the value of all the dimensions in dim in src.  <a href="#ae9ccdbe02dd954e8a2210a93d684e8f3">More...</a><br /></td></tr>
<tr class="separator:ae9ccdbe02dd954e8a2210a93d684e8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbef16e226112f83f89440317190a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a6cbef16e226112f83f89440317190a62">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, bool project=false)</td></tr>
<tr class="memdesc:a6cbef16e226112f83f89440317190a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of dimension dim in *this.  <a href="#a6cbef16e226112f83f89440317190a62">More...</a><br /></td></tr>
<tr class="separator:a6cbef16e226112f83f89440317190a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab015e6c242515dc9522f9287337660fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#ab015e6c242515dc9522f9287337660fe">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], bool project=false)</td></tr>
<tr class="memdesc:ab015e6c242515dc9522f9287337660fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of dimensions dims[0] to dims[size-1] in *this.  <a href="#ab015e6c242515dc9522f9287337660fe">More...</a><br /></td></tr>
<tr class="separator:ab015e6c242515dc9522f9287337660fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ae0b37dc2cfb6a7caca6b06e5828a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a72ae0b37dc2cfb6a7caca6b06e5828a2">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; <a class="el" href="classapron_1_1dim.html">dim</a>, bool project=false)</td></tr>
<tr class="memdesc:a72ae0b37dc2cfb6a7caca6b06e5828a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of all the dimensions in dim in *this.  <a href="#a72ae0b37dc2cfb6a7caca6b06e5828a2">More...</a><br /></td></tr>
<tr class="separator:a72ae0b37dc2cfb6a7caca6b06e5828a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Change of dimension</h2></td></tr>
<tr class="memitem:a64ae4235996ce3bc87ad30e1edaf4cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a64ae4235996ce3bc87ad30e1edaf4cd9">add_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;d, bool project)</td></tr>
<tr class="memdesc:a64ae4235996ce3bc87ad30e1edaf4cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies src into dst and adds some dimensions.  <a href="#a64ae4235996ce3bc87ad30e1edaf4cd9">More...</a><br /></td></tr>
<tr class="separator:a64ae4235996ce3bc87ad30e1edaf4cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eca949df13c55b7c488df2a048e5f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a39eca949df13c55b7c488df2a048e5f4">remove_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;d)</td></tr>
<tr class="memdesc:a39eca949df13c55b7c488df2a048e5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies src into dst and removes some dimensions.  <a href="#a39eca949df13c55b7c488df2a048e5f4">More...</a><br /></td></tr>
<tr class="separator:a39eca949df13c55b7c488df2a048e5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8a674a8c57404ed7cf2679b07f7924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0f8a674a8c57404ed7cf2679b07f7924">permute_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const <a class="el" href="classapron_1_1dimperm.html">dimperm</a> &amp;d)</td></tr>
<tr class="memdesc:a0f8a674a8c57404ed7cf2679b07f7924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies src into dst and permute some dimensions.  <a href="#a0f8a674a8c57404ed7cf2679b07f7924">More...</a><br /></td></tr>
<tr class="separator:a0f8a674a8c57404ed7cf2679b07f7924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfacabdb7add12674038b783fd45a97a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#abfacabdb7add12674038b783fd45a97a">add_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;d, bool project=false)</td></tr>
<tr class="memdesc:abfacabdb7add12674038b783fd45a97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some dimensions to *this.  <a href="#abfacabdb7add12674038b783fd45a97a">More...</a><br /></td></tr>
<tr class="separator:abfacabdb7add12674038b783fd45a97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c31b09454010d2877f768efa4611a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a88c31b09454010d2877f768efa4611a6">remove_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;d)</td></tr>
<tr class="memdesc:a88c31b09454010d2877f768efa4611a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes some dimensions from *this.  <a href="#a88c31b09454010d2877f768efa4611a6">More...</a><br /></td></tr>
<tr class="separator:a88c31b09454010d2877f768efa4611a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f61d1a7df076f91b1132cf5df256316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a1f61d1a7df076f91b1132cf5df256316">permute_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1dimperm.html">dimperm</a> &amp;d)</td></tr>
<tr class="memdesc:a1f61d1a7df076f91b1132cf5df256316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes some dimensions in *this.  <a href="#a1f61d1a7df076f91b1132cf5df256316">More...</a><br /></td></tr>
<tr class="separator:a1f61d1a7df076f91b1132cf5df256316"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Expansion and folding</h2></td></tr>
<tr class="memitem:abd6d1c53502f2e66f34f4c8930f069cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#abd6d1c53502f2e66f34f4c8930f069cf">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, size_t n)</td></tr>
<tr class="memdesc:abd6d1c53502f2e66f34f4c8930f069cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and duplicates dimension dim into n copies.  <a href="#abd6d1c53502f2e66f34f4c8930f069cf">More...</a><br /></td></tr>
<tr class="separator:abd6d1c53502f2e66f34f4c8930f069cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37615d3231e9c56c987b611a7ef6883f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a37615d3231e9c56c987b611a7ef6883f">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[])</td></tr>
<tr class="memdesc:a37615d3231e9c56c987b611a7ef6883f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and folds dimensions dims[0] to dim[size-1].  <a href="#a37615d3231e9c56c987b611a7ef6883f">More...</a><br /></td></tr>
<tr class="separator:a37615d3231e9c56c987b611a7ef6883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ad0b4d5e0a65e866f10ee58bbc2dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a215ad0b4d5e0a65e866f10ee58bbc2dc">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>)</td></tr>
<tr class="memdesc:a215ad0b4d5e0a65e866f10ee58bbc2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces dst with a copy of src and folds all dimensions in dims.  <a href="#a215ad0b4d5e0a65e866f10ee58bbc2dc">More...</a><br /></td></tr>
<tr class="separator:a215ad0b4d5e0a65e866f10ee58bbc2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842ab005b23c2703617341fa5debc9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a842ab005b23c2703617341fa5debc9d6">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, size_t n=1)</td></tr>
<tr class="memdesc:a842ab005b23c2703617341fa5debc9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates dimension dim into n copies in *this (modified in-place).  <a href="#a842ab005b23c2703617341fa5debc9d6">More...</a><br /></td></tr>
<tr class="separator:a842ab005b23c2703617341fa5debc9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df6d7b26d250725b8ceefee81606901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a5df6d7b26d250725b8ceefee81606901">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="classapron_1_1abstract0.html#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[])</td></tr>
<tr class="memdesc:a5df6d7b26d250725b8ceefee81606901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds dimensions dim[0] to dim[size-1] in *this (modified in-place).  <a href="#a5df6d7b26d250725b8ceefee81606901">More...</a><br /></td></tr>
<tr class="separator:a5df6d7b26d250725b8ceefee81606901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbc64baaab4f09559e2bc184ef6721f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a4fbc64baaab4f09559e2bc184ef6721f">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>)</td></tr>
<tr class="memdesc:a4fbc64baaab4f09559e2bc184ef6721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds all dimensions dims in *this (modified in-place).  <a href="#a4fbc64baaab4f09559e2bc184ef6721f">More...</a><br /></td></tr>
<tr class="separator:a4fbc64baaab4f09559e2bc184ef6721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Closure</h2></td></tr>
<tr class="memitem:a0ddcaa642be6ece07f8a78660fe41bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#a0ddcaa642be6ece07f8a78660fe41bdb">closure</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;dst, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;src)</td></tr>
<tr class="memdesc:a0ddcaa642be6ece07f8a78660fe41bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in dst the topological closure of src.  <a href="#a0ddcaa642be6ece07f8a78660fe41bdb">More...</a><br /></td></tr>
<tr class="separator:a0ddcaa642be6ece07f8a78660fe41bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d298935935229cbffb7afd5fb84e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapron_1_1abstract0.html#aa0d298935935229cbffb7afd5fb84e06">closure</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:aa0d298935935229cbffb7afd5fb84e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with its topological closure.  <a href="#aa0d298935935229cbffb7afd5fb84e06">More...</a><br /></td></tr>
<tr class="separator:aa0d298935935229cbffb7afd5fb84e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Level 0 abstract value (ap_abstract0_t* wrapper). </p>
<p>An <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> object stores an abstract value. It represents a set of points in a numerical space with some integer-valued dimensions and some real-valued dimensions.</p>
<dl class="section warning"><dt>Warning</dt><dd>all the abstract operators are guaranteed to be sound, but not complete, that is:<ul>
<li>returned abstract elements and intervals are over-approximations of the actual result on sets,</li>
<li>returned constraint conjunction may satisfy more points than the original abstract element,</li>
<li>returned generators may span more points than the original abstract element,</li>
<li>predicates return <code>true</code> if the predicate is definitively true, and <code>false</code> if either the predicate is false (flag_exact is then true), or due to abstraction, the domain cannot conclude (flag_exact is then false).</li>
</ul>
</dd></dl>
<p>An <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> is always created with a manager that indicates the underlying library. This defines its internal representation and algorithms, which in turns defines the expressiveness and cost vs. precision trade-off. Most operations to manipulate an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> also take a manager as first argument. This must be a manager compatible with the one of all <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> arguments (including this), that is, a manger created by the same library (e.g., NewPolka polyhedra) and using the same parameter values, if any (e.g., strictness). It need not be the very same manager the <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> was created with.</p>
<p>Overloaded arithmetic, assignment and copy operators that cannot take an extra manager argument will implicitly use the manager used to create the first argument.</p>
<p>Additionally, for binary or n-aray operators, all <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> must have the same number of integer and real dimensions.</p>
<p>Many operations exist in two kinds:</p><ul>
<li>an imperative class function that modifies the this <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>,</li>
<li>a more "functional" global function that takes as argument both one or several constant source <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> and one destination <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> that will be overridden with the result.</li>
</ul>
<p>Both kinds will return a reference to the <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> that holds the result.</p>
<p>Most functions can throw a variety of exceptions:</p><ul>
<li>std::invalid_argument, when arguments have incompatible managers, types, or dimensions,</li>
<li>std::length_error, when running out of memory or exceeding the <code>max_object_size</code> value set by the user in the manager,</li>
<li>std::overflow_error, when a numerical overflow occurs,</li>
<li><a class="el" href="classapron_1_1not__implemented.html" title="Exception raised when a function is not implemented.">not_implemented</a>, when some function is not available,</li>
<li>timeout, when exceeding the <code>timout</code> value set by the user in the manager. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5b9da766a1817a41d7ad3c739902e3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9da766a1817a41d7ad3c739902e3c7">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype">ap_abstract0_t *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. Wraps an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> around the pointer x, taking ownership of the object. </p>

</div>
</div>
<a id="a47720402023ba5b5378390ed4c5206e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47720402023ba5b5378390ed4c5206e3">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the whole space. </p>

</div>
</div>
<a id="af83420d0e0f11695e1c3a544b864fa36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83420d0e0f11695e1c3a544b864fa36">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the empty set. </p>

</div>
</div>
<a id="a2da4b783ea69e4655502d1637f55a98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da4b783ea69e4655502d1637f55a98a">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>

</div>
</div>
<a id="aacc727bde899fbf168b7ce1dd6b61402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc727bde899fbf168b7ce1dd6b61402">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a box. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if x has less than intdim+realdim dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38a55c6e21eb9a2942c94bcf81702a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a55c6e21eb9a2942c94bcf81702a19">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of linear constraints. </p>

</div>
</div>
<a id="ac1bd5bdcf44d170dde123e1b2d403e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bd5bdcf44d170dde123e1b2d403e1a">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of arbitrary constraints. </p>

</div>
</div>
<a id="a345867b8095f2cb3587f32c4d085afe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345867b8095f2cb3587f32c4d085afe5">&#9670;&nbsp;</a></span>abstract0() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="ae9c7c340d33af5013e6a29500d3710a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c7c340d33af5013e6a29500d3710a3">&#9670;&nbsp;</a></span>~abstract0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::~abstract0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abfacabdb7add12674038b783fd45a97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfacabdb7add12674038b783fd45a97a">&#9670;&nbsp;</a></span>add_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::add_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some dimensions to *this. </p>
<ul>
<li><code>project</code> whether to set the new dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab0afee9e56d9fdd1b8c163edaa51aa8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0afee9e56d9fdd1b8c163edaa51aa8b">&#9670;&nbsp;</a></span>add_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::add_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a7215e4ba3298da7f66b835a95560ea62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7215e4ba3298da7f66b835a95560ea62">&#9670;&nbsp;</a></span>approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::approximate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies the abstract element, potentially loosing precision. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a0b658f699a6f447918194c5e29d15e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b658f699a6f447918194c5e29d15e0d">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of linear expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a678d70c5bdce42053a8eaa0a0a4708f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678d70c5bdce42053a8eaa0a0a4708f9">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="acd574e03de9e1aef9eb8401627d48bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd574e03de9e1aef9eb8401627d48bfe">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a655a19c846835685d93976694327da8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655a19c846835685d93976694327da8d">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a79fb6b4c3eab4c5332a531ef83609202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fb6b4c3eab4c5332a531ef83609202">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a5eefc2ed88b02ade20cf2fe41325521f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eefc2ed88b02ade20cf2fe41325521f">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3bfcde8e04c8fd2371cf62ee719f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bfcde8e04c8fd2371cf62ee719f535">&#9670;&nbsp;</a></span>bound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract0::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for a linear expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="a22d2040cf521822aabe729a159c99b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d2040cf521822aabe729a159c99b53">&#9670;&nbsp;</a></span>bound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract0::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for an arbitrary expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="af2c2489df6d4cd5578c8dff76ea45d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c2489df6d4cd5578c8dff76ea45d53">&#9670;&nbsp;</a></span>bound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract0::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for the given coordinate on all points in the abstract element. </p>

</div>
</div>
<a id="a949de6ba2d6ccb862c689a8f8b977822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949de6ba2d6ccb862c689a8f8b977822">&#9670;&nbsp;</a></span>canonicalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the abstract element in canonical form (if such a notion exists). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa0d298935935229cbffb7afd5fb84e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d298935935229cbffb7afd5fb84e06">&#9670;&nbsp;</a></span>closure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with its topological closure. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a8893cfe891544972d4d840638fe692ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8893cfe891544972d4d840638fe692ce">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract0::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em> = <code>stdout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw printing to a C stream (mainly for debug purposes). </p>

</div>
</div>
<a id="a842ab005b23c2703617341fa5debc9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842ab005b23c2703617341fa5debc9d6">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates dimension dim into n copies in *this (modified in-place). </p>
<p>New dimensions are appended after the last integer or real dimension of *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a5df6d7b26d250725b8ceefee81606901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df6d7b26d250725b8ceefee81606901">&#9670;&nbsp;</a></span>fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds dimensions dim[0] to dim[size-1] in *this (modified in-place). </p>
<p>dim must be sorted and contain variables of the same type (integer or real). After folding, only dim[0] is kept and other dimensions are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a4fbc64baaab4f09559e2bc184ef6721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbc64baaab4f09559e2bc184ef6721f">&#9670;&nbsp;</a></span>fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds all dimensions dims in *this (modified in-place). </p>
<p>dim must be sorted and contain variables of the same type (integer or real). After folding, only dim[0] is kept and other dimensions are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a6cbef16e226112f83f89440317190a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbef16e226112f83f89440317190a62">&#9670;&nbsp;</a></span>forget() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of dimension dim in *this. </p>
<ul>
<li><code>project</code> whether to reset the dimension to 0 (if true), or leave it undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab015e6c242515dc9522f9287337660fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab015e6c242515dc9522f9287337660fe">&#9670;&nbsp;</a></span>forget() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of dimensions dims[0] to dims[size-1] in *this. </p>
<ul>
<li><code>project</code> whether to reset the dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a72ae0b37dc2cfb6a7caca6b06e5828a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ae0b37dc2cfb6a7caca6b06e5828a2">&#9670;&nbsp;</a></span>forget() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of all the dimensions in dim in *this. </p>
<ul>
<li><code>project</code> whether to reset the dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a39e60165bf1962ee9dbb8c207c2c56e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e60165bf1962ee9dbb8c207c2c56e8">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract0::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element using the given manager. </p>
<p>The abstract element cannot be used after being freed. However, the standard destructor can be safely be called (resulting in a no-op). </p>

</div>
</div>
<a id="a827e433f2875073e98ed2b290230b42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827e433f2875073e98ed2b290230b42e">&#9670;&nbsp;</a></span>get_ap_abstract0_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract0_t * abstract0::get_ap_abstract0_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="ae6122cfcdc68fbbeef4702a25ba94ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6122cfcdc68fbbeef4702a25ba94ae4">&#9670;&nbsp;</a></span>get_ap_abstract0_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ap_abstract0_t * abstract0::get_ap_abstract0_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="aea39fa14594c33e0b585dfa5f68c3894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea39fa14594c33e0b585dfa5f68c3894">&#9670;&nbsp;</a></span>get_dimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_dimension_t abstract0::get_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of integer and real dimensions in the abstract element. </p>

</div>
</div>
<a id="a78360af632ff0a307e50ec155b688d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78360af632ff0a307e50ec155b688d09">&#9670;&nbsp;</a></span>get_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1manager.html">manager</a> abstract0::get_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the manager the abstract element was created with (with reference count incremented). </p>

</div>
</div>
<a id="aef077940578d27ea281ec8838fb0548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef077940578d27ea281ec8838fb0548c">&#9670;&nbsp;</a></span>is_bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the empty set. </p>

</div>
</div>
<a id="adfc789b4786aaa2159fadb635c80ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc789b4786aaa2159fadb635c80ea9c">&#9670;&nbsp;</a></span>is_dimension_unconstrained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_dimension_unconstrained </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the points in *this are unbounded in the given dimension. </p>

</div>
</div>
<a id="a77769eec2a835b68309495758b583175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77769eec2a835b68309495758b583175">&#9670;&nbsp;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this and x represent the same set. </p>

</div>
</div>
<a id="a97cd8dd502422c80a947e6bea1af42ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cd8dd502422c80a947e6bea1af42ee">&#9670;&nbsp;</a></span>is_leq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_leq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this is included in x (set-wise). </p>

</div>
</div>
<a id="acae4abccf24b03fbc9a84d1c9e2dad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae4abccf24b03fbc9a84d1c9e2dad3c">&#9670;&nbsp;</a></span>is_top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the full space. </p>

</div>
</div>
<a id="a40907a86c978215e81d8f553c9053858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40907a86c978215e81d8f553c9053858">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a66a623a045bb56acfed7a005bc38c95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a623a045bb56acfed7a005bc38c95a">&#9670;&nbsp;</a></span>meet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a315d46d075b64867c8acd449066bca35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d46d075b64867c8acd449066bca35">&#9670;&nbsp;</a></span>meet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a322cbef8760029ab9813e50192ef2e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322cbef8760029ab9813e50192ef2e2e">&#9670;&nbsp;</a></span>meet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a97812eb92ef7ad2155367eeb99b161fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97812eb92ef7ad2155367eeb99b161fe">&#9670;&nbsp;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimizes the size of the representation, to save memory. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a87ce16b175bb96f9c06fcc8fcfddfc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ce16b175bb96f9c06fcc8fcfddfc11">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1ce14f7dfb6205628412f08559fe78bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce14f7dfb6205628412f08559fe78bf">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aeab5b8785fe4b33ae0c6375402f5e45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab5b8785fe4b33ae0c6375402f5e45c">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a081d409ad6410a941951a09fa6573e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081d409ad6410a941951a09fa6573e3a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a6f2e9b2fd016578aeb05b9cf6e12a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2e9b2fd016578aeb05b9cf6e12a0fd">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a991b63c268bdbed29e2fac7d44cd7167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991b63c268bdbed29e2fac7d44cd7167">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a copy of t to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="aa6e212ccde834e62fe4c4cbc006415bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e212ccde834e62fe4c4cbc006415bd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the full space to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a5e12b7728038f0c8f990a31758ad291f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e12b7728038f0c8f990a31758ad291f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the empty set to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a3d7043b7f05fc23ac032f0b12f6286b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7043b7f05fc23ac032f0b12f6286b7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a box to *this. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the array has insufficient size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae189bac5b66bb54a6035146b189ac31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae189bac5b66bb54a6035146b189ac31a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of linear constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a0de9e63831781c5196cd2fc3ac5189b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de9e63831781c5196cd2fc3ac5189b8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of arbitrary constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a1f61d1a7df076f91b1132cf5df256316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f61d1a7df076f91b1132cf5df256316">&#9670;&nbsp;</a></span>permute_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::permute_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimperm.html">dimperm</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes some dimensions in *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ae3ddbea873bf9284071a840bef83b79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ddbea873bf9284071a840bef83b79f">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract0::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>name_of_dim</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em> = <code>stdout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty-printing to a C stream. </p>

</div>
</div>
<a id="a88c31b09454010d2877f768efa4611a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c31b09454010d2877f768efa4611a6">&#9670;&nbsp;</a></span>remove_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::remove_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes some dimensions from *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac8dd9bca89afa9264d570fc2194b9a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dd9bca89afa9264d570fc2194b9a6f">&#9670;&nbsp;</a></span>sat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0.html">lincons0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy a linear constraint. </p>

</div>
</div>
<a id="af584ba85a584bc1b01dd1b7bf9cd6387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af584ba85a584bc1b01dd1b7bf9cd6387">&#9670;&nbsp;</a></span>sat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0.html">tcons0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy an arbitrary constraint. </p>

</div>
</div>
<a id="a80026a2875138c133476860b2e100263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80026a2875138c133476860b2e100263">&#9670;&nbsp;</a></span>sat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the dimension dim of all points in *this is included in the given interval. </p>

</div>
</div>
<a id="abd22f0663c916eeb92784639f4565d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd22f0663c916eeb92784639f4565d1b">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string * abstract0::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes an abstract element. </p>
<p>The string can be safely stored to disk and reloaded later or transmitted across a network. The format is library-specific but is generally a machine-readable byte-stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated string that the caller should delete it after use. </dd></dl>

</div>
</div>
<a id="a0f304a032eb83b75c4dc7dd91c8666cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f304a032eb83b75c4dc7dd91c8666cf">&#9670;&nbsp;</a></span>set() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a copy of x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a1e81dbfaa49410805f96037c9612aee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e81dbfaa49410805f96037c9612aee1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em> = <code>AP_DIM_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em> = <code>AP_DIM_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the full space. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac442226bf6efafa4a739a61d76c09caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac442226bf6efafa4a739a61d76c09caf">&#9670;&nbsp;</a></span>set() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em> = <code>AP_DIM_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em> = <code>AP_DIM_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the empty set. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a680eec402729a6e8e7e2c7773756ec94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680eec402729a6e8e7e2c7773756ec94">&#9670;&nbsp;</a></span>set() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em> = <code>AP_DIM_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em> = <code>AP_DIM_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a7b5fdcb4af7130ab402a699ffd11cc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5fdcb4af7130ab402a699ffd11cc6a">&#9670;&nbsp;</a></span>set() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em> = <code>AP_DIM_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em> = <code>AP_DIM_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of linear constraints. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="acf1ce6a6f0144dbcd06355c75df1bef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1ce6a6f0144dbcd06355c75df1bef6">&#9670;&nbsp;</a></span>set() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>intdim</em> = <code>AP_DIM_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>realdim</em> = <code>AP_DIM_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of arbitrary constraints. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac1f7b4c634f4cdaa2aeaf46f9618105e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t abstract0::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (abstract) size of the abstract element. </p>
<p>The unit in which size is computed is library-specific. It is guaranteed to be the same as the unit for the <code>max_object_size</code> field of the ap_funopt_t structure. </p>

</div>
</div>
<a id="a183128ae2c4a6f3c29713a0ee3c29796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183128ae2c4a6f3c29713a0ee3c29796">&#9670;&nbsp;</a></span>substitute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of linear expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a9df3b83fb6f98bfeb698e994d246f049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df3b83fb6f98bfeb698e994d246f049">&#9670;&nbsp;</a></span>substitute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aab357a0a058d2f6d8a4b679d139f8206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab357a0a058d2f6d8a4b679d139f8206">&#9670;&nbsp;</a></span>substitute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8919101a7434d6fd58843f991306e356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8919101a7434d6fd58843f991306e356">&#9670;&nbsp;</a></span>substitute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa3a77c2c9b04f116c5ed88ea40c9b5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a77c2c9b04f116c5ed88ea40c9b5a2">&#9670;&nbsp;</a></span>substitute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a102c11ea44a54b7b4967191f4e8a5cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102c11ea44a54b7b4967191f4e8a5cf8">&#9670;&nbsp;</a></span>substitute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a028ec014691a2646c4c78effbacb185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ec014691a2646c4c78effbacb185c">&#9670;&nbsp;</a></span>to_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval__array.html">interval_array</a> abstract0::to_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bounding box for the set represented by the abstract element. </p>

</div>
</div>
<a id="aabcdc01b87c1d2beecdb07a8297a9ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcdc01b87c1d2beecdb07a8297a9ca7">&#9670;&nbsp;</a></span>to_generator_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> abstract0::to_generator_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a generator representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="a2f6af1b50ab4747690a09a24687af4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6af1b50ab4747690a09a24687af4e6">&#9670;&nbsp;</a></span>to_lincons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> abstract0::to_lincons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="a669ec6b5d4ca8b8047351f411094da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669ec6b5d4ca8b8047351f411094da8e">&#9670;&nbsp;</a></span>to_tcons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> abstract0::to_tcons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a64ae4235996ce3bc87ad30e1edaf4cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ae4235996ce3bc87ad30e1edaf4cd9">&#9670;&nbsp;</a></span>add_dimensions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; add_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies src into dst and adds some dimensions. </p>
<ul>
<li><code>project</code> whether to set the new dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a09aa9c376b7bc1144bd68a048000e82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aa9c376b7bc1144bd68a048000e82a">&#9670;&nbsp;</a></span>add_rays</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; add_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with x with some rays added. </p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab785e4d84d8f55f5d5a0f8fc55f46f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab785e4d84d8f55f5d5a0f8fc55f46f8e">&#9670;&nbsp;</a></span>assign <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of linear expression. </p>
<p>dst is replaced with the effect of assigning l to dimension dim in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a69479c1d7bfe19c9f21765e9310f7ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69479c1d7bfe19c9f21765e9310f7ee5">&#9670;&nbsp;</a></span>assign <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of linear expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to dimension dim[i] in src, for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a1720718e87bff8b845084baa467a3cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1720718e87bff8b845084baa467a3cbf">&#9670;&nbsp;</a></span>assign <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of linear expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to dimension dim[i] in src. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97b893c408aa33a37311bd11763eac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b893c408aa33a37311bd11763eac9f">&#9670;&nbsp;</a></span>assign <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of arbitrary expression. </p>
<p>dst is replaced with the effect of assigning l to dimension dim in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a9d00f33c66ffb89bd81667a51f2d1853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d00f33c66ffb89bd81667a51f2d1853">&#9670;&nbsp;</a></span>assign <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of arbitrary expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to dimension dim[i] in src, for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a38fff4d54d98b90078dc9b50cc6dfc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fff4d54d98b90078dc9b50cc6dfc46">&#9670;&nbsp;</a></span>assign <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel assignment of arbitrary expressions. </p>
<p>dst is replaced with the effect of assigning l[i] to dimension dim[i] in src. Assignments are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ddcaa642be6ece07f8a78660fe41bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddcaa642be6ece07f8a78660fe41bdb">&#9670;&nbsp;</a></span>closure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the topological closure of src. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="addd31837987d25c058e08ce280389e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd31837987d25c058e08ce280389e12">&#9670;&nbsp;</a></span>deserialize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>eaten</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstruct an abstract element form a serialized byte-stream and put it into dst. </p>
<p>The managers used to serialized and deserialize need not be the same, but they must have been created using the same library and with the same arguments.</p>
<ul>
<li><code>eaten</code>, if not NULL, will be set to the actual number of bytes consumed from the string. <dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="abd6d1c53502f2e66f34f4c8930f069cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6d1c53502f2e66f34f4c8930f069cf">&#9670;&nbsp;</a></span>expand</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and duplicates dimension dim into n copies. </p>
<p>New dimensions are appended after the last integer or real dimension of dst.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a37615d3231e9c56c987b611a7ef6883f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37615d3231e9c56c987b611a7ef6883f">&#9670;&nbsp;</a></span>fold <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and folds dimensions dims[0] to dim[size-1]. </p>
<p>dim must be sorted and contain variables of the same type (integer or real). After folding, only dim[0] is kept and other dimensions are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a215ad0b4d5e0a65e866f10ee58bbc2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215ad0b4d5e0a65e866f10ee58bbc2dc">&#9670;&nbsp;</a></span>fold <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with a copy of src and folds all dimensions in dims. </p>
<p>dim must be sorted and contain variables of the same type (integer or real). After folding, only dim[0] is kept and other dimensions are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a2b851b1b0d12f4972ab61ff0d69edb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b851b1b0d12f4972ab61ff0d69edb65">&#9670;&nbsp;</a></span>forget <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of forgetting the value of dimension dim in src. </p>
<ul>
<li><code>project</code> if true, resets the dimension to 0 (if true).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="aac66316dd5ae63ba596a951e361e0716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac66316dd5ae63ba596a951e361e0716">&#9670;&nbsp;</a></span>forget <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of forgetting the value of dimensions dim[0] to dim[size-1] in src. </p>
<ul>
<li><code>project</code> whether to reset the dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ae9ccdbe02dd954e8a2210a93d684e8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ccdbe02dd954e8a2210a93d684e8f3">&#9670;&nbsp;</a></span>forget <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>project</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of forgetting the value of all the dimensions in dim in src. </p>
<ul>
<li><code>project</code> whether to reset the dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a4f3caf40f06525f2f0850a0c75eefc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3caf40f06525f2f0850a0c75eefc95">&#9670;&nbsp;</a></span>join <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the join of x and y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ae327dba80f59aae4fced1399cda3faed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae327dba80f59aae4fced1399cda3faed">&#9670;&nbsp;</a></span>join <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the join of all abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a94c6c8b390090144e5128511cbf16845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c6c8b390090144e5128511cbf16845">&#9670;&nbsp;</a></span>join <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> *const&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the join of all size abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="acc427355eb152f899f8972ce35f93634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc427355eb152f899f8972ce35f93634">&#9670;&nbsp;</a></span>meet <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ae6a548eff25b721c56ea9bbe60b15638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a548eff25b721c56ea9bbe60b15638">&#9670;&nbsp;</a></span>meet <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of all abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ae052088c74910f1717dc3411ad50d2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae052088c74910f1717dc3411ad50d2c8">&#9670;&nbsp;</a></span>meet <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> *const&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of all size abstract elements in x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a0ee42afb4b2079815ca7fb58d4e0a9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee42afb4b2079815ca7fb58d4e0a9bd">&#9670;&nbsp;</a></span>meet <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and some linear constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a89119589f6d92b37749c54f9620bfbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89119589f6d92b37749c54f9620bfbfa">&#9670;&nbsp;</a></span>meet <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces dst with the meet of x and some arbitrary constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="aad426e9cd549c3ce1f4b4a187c353dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad426e9cd549c3ce1f4b4a187c353dc4">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceapron.html#aa74e2a030ba8a4a51298a020518860e7">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x and y represent different sets. </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a4d4a3ee60358edf3c5c14196e6dde9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4a3ee60358edf3c5c14196e6dde9de">&#9670;&nbsp;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x is strictly included within y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a1bbeca61b6c9414c116e7fa4b49cff58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbeca61b6c9414c116e7fa4b49cff58">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints in constraint form. </p>

</div>
</div>
<a id="a3ddf1a5c8a9bb8cb9af7a7a0863e70f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddf1a5c8a9bb8cb9af7a7a0863e70f1">&#9670;&nbsp;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x is included within y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a0196e7f2f52c507845482ebab1baf630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0196e7f2f52c507845482ebab1baf630">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x and y represent the same set. </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a42e28097c3860312abf87e86663db1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e28097c3860312abf87e86663db1cf">&#9670;&nbsp;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x strictly contains y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="aa3f38f23b7d75b47ed069498c207c16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f38f23b7d75b47ed069498c207c16a">&#9670;&nbsp;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether x contains y (set-wise). </p>
<p>The manager for the left argument is used implicitly. </p>

</div>
</div>
<a id="a0f8a674a8c57404ed7cf2679b07f7924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8a674a8c57404ed7cf2679b07f7924">&#9670;&nbsp;</a></span>permute_dimensions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; permute_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimperm.html">dimperm</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies src into dst and permute some dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="af71edee802455ccf0771b9aabb985753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71edee802455ccf0771b9aabb985753">&#9670;&nbsp;</a></span>printdiff</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void printdiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>name_of_dim</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em> = <code>stdout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty-printing the difference between x and y to a C stream. </p>

</div>
</div>
<a id="a39eca949df13c55b7c488df2a048e5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eca949df13c55b7c488df2a048e5f4">&#9670;&nbsp;</a></span>remove_dimensions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; remove_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies src into dst and removes some dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a5479a2b0f14cf419b364d955b3d1319e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5479a2b0f14cf419b364d955b3d1319e">&#9670;&nbsp;</a></span>substitute <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution (backward assignment) of linear expression. </p>
<p>dst is replaced with the effect of substituting l to dimension dim in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="af0fd6749e560be394ff248ade8f61638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fd6749e560be394ff248ade8f61638">&#9670;&nbsp;</a></span>substitute <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of linear expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to dimension dim[i] in src, for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ab0c2ed088b3d812fd1e32221b303be23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c2ed088b3d812fd1e32221b303be23">&#9670;&nbsp;</a></span>substitute <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of linear expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to dimension dim[i] in src. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d412ec6328f62e66b00b532d5acaa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d412ec6328f62e66b00b532d5acaa40">&#9670;&nbsp;</a></span>substitute <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution (backward assignment) of arbitrary expression. </p>
<p>dst is replaced with the effect of substituting l to dimension dim in src. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="aba71058f0d4950ca6df1a650bc4266cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba71058f0d4950ca6df1a650bc4266cf">&#9670;&nbsp;</a></span>substitute <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t&#160;</td>
          <td class="paramname"><em>dim</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const&#160;</td>
          <td class="paramname"><em>l</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to dimension dim[i] in src, for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="ac88bd56a0c68a2c3468c0a78fb1f0786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88bd56a0c68a2c3468c0a78fb1f0786">&#9670;&nbsp;</a></span>substitute <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>inter</em> = <code><a class="el" href="classapron_1_1abstract0.html#a5aadba4862f59ae21ffd467661f247a5">abstract0::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>dst is replaced with the effect of substituting l[i] to dimension dim[i] in src. Substitutions are performed in parallel. If inter is specified, dst is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ac1e0ee4bbb4f8fa02ce781cc27712e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac1e0ee4bbb4f8fa02ce781cc27712e">&#9670;&nbsp;</a></span>widening <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; widening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of x widened with y. </p>
<dl class="section warning"><dt>Warning</dt><dd>y must be a superset of x.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<a id="a00f7e6dd64ae824216262935c0ac05bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f7e6dd64ae824216262935c0ac05bd">&#9670;&nbsp;</a></span>widening <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a>&amp; widening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores in dst the result of x widened with y, using some widening thresholds. </p>
<dl class="section warning"><dt>Warning</dt><dd>y must be a superset of x.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to dst. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7704fa4e2822eef41be9e570cf6a21c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7704fa4e2822eef41be9e570cf6a21c2">&#9670;&nbsp;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract0_t* apron::abstract0::a</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer managed by APRON. </p>

</div>
</div>
<a id="a5aadba4862f59ae21ffd467661f247a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aadba4862f59ae21ffd467661f247a5">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> apron::abstract0::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NULL abstract element, to be used only as default argument in assign and substitute. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract0_8hh_source.html">apxx_abstract0.hh</a></li>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract0__inline_8hh_source.html">apxx_abstract0_inline.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 10 2019 10:49:09 for APRONXX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
