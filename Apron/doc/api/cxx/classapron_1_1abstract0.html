<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APRONXX: apron::abstract0 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">APRONXX<span id="projectnumber">&#160;0.9.15</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceapron.html">apron</a></li><li class="navelem"><a class="el" href="classapron_1_1abstract0.html">abstract0</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classapron_1_1abstract0-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">apron::abstract0 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Level 0 abstract value (ap_abstract0_t* wrapper).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="apxx__abstract0_8hh_source.html">apxx_abstract0.hh</a>&gt;</code></p>

<p>Inherits <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a47720402023ba5b5378390ed4c5206e3" id="r_a47720402023ba5b5378390ed4c5206e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47720402023ba5b5378390ed4c5206e3">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, <a class="el" href="structapron_1_1top.html">top</a> x)</td></tr>
<tr class="memdesc:a47720402023ba5b5378390ed4c5206e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the whole space.  <br /></td></tr>
<tr class="separator:a47720402023ba5b5378390ed4c5206e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83420d0e0f11695e1c3a544b864fa36" id="r_af83420d0e0f11695e1c3a544b864fa36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af83420d0e0f11695e1c3a544b864fa36">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, <a class="el" href="structapron_1_1bottom.html">bottom</a> x)</td></tr>
<tr class="memdesc:af83420d0e0f11695e1c3a544b864fa36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element representing the empty set.  <br /></td></tr>
<tr class="separator:af83420d0e0f11695e1c3a544b864fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da4b783ea69e4655502d1637f55a98a" id="r_a2da4b783ea69e4655502d1637f55a98a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2da4b783ea69e4655502d1637f55a98a">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a2da4b783ea69e4655502d1637f55a98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <br /></td></tr>
<tr class="separator:a2da4b783ea69e4655502d1637f55a98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc727bde899fbf168b7ce1dd6b61402" id="r_aacc727bde899fbf168b7ce1dd6b61402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc727bde899fbf168b7ce1dd6b61402">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:aacc727bde899fbf168b7ce1dd6b61402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a box.  <br /></td></tr>
<tr class="separator:aacc727bde899fbf168b7ce1dd6b61402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a55c6e21eb9a2942c94bcf81702a19" id="r_a38a55c6e21eb9a2942c94bcf81702a19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38a55c6e21eb9a2942c94bcf81702a19">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:a38a55c6e21eb9a2942c94bcf81702a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of linear constraints.  <br /></td></tr>
<tr class="separator:a38a55c6e21eb9a2942c94bcf81702a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bd5bdcf44d170dde123e1b2d403e1a" id="r_ac1bd5bdcf44d170dde123e1b2d403e1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1bd5bdcf44d170dde123e1b2d403e1a">abstract0</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t intdim, size_t realdim, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:ac1bd5bdcf44d170dde123e1b2d403e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract element from a conjunction of arbitrary constraints.  <br /></td></tr>
<tr class="separator:ac1bd5bdcf44d170dde123e1b2d403e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345867b8095f2cb3587f32c4d085afe5" id="r_a345867b8095f2cb3587f32c4d085afe5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a345867b8095f2cb3587f32c4d085afe5">abstract0</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a345867b8095f2cb3587f32c4d085afe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (deep) copy of the abstract element.  <br /></td></tr>
<tr class="separator:a345867b8095f2cb3587f32c4d085afe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr class="memitem:ae9c7c340d33af5013e6a29500d3710a3" id="r_ae9c7c340d33af5013e6a29500d3710a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9c7c340d33af5013e6a29500d3710a3">~abstract0</a> ()</td></tr>
<tr class="memdesc:ae9c7c340d33af5013e6a29500d3710a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element.  <br /></td></tr>
<tr class="separator:ae9c7c340d33af5013e6a29500d3710a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e60165bf1962ee9dbb8c207c2c56e8" id="r_a39e60165bf1962ee9dbb8c207c2c56e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e60165bf1962ee9dbb8c207c2c56e8">free</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a39e60165bf1962ee9dbb8c207c2c56e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract element using the given manager.  <br /></td></tr>
<tr class="separator:a39e60165bf1962ee9dbb8c207c2c56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Copies and conversions to abstract elements</div></td></tr>
<tr class="memitem:a991b63c268bdbed29e2fac7d44cd7167" id="r_a991b63c268bdbed29e2fac7d44cd7167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991b63c268bdbed29e2fac7d44cd7167">operator=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;t)</td></tr>
<tr class="memdesc:a991b63c268bdbed29e2fac7d44cd7167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a copy of t to *this.  <br /></td></tr>
<tr class="separator:a991b63c268bdbed29e2fac7d44cd7167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e212ccde834e62fe4c4cbc006415bd" id="r_aa6e212ccde834e62fe4c4cbc006415bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e212ccde834e62fe4c4cbc006415bd">operator=</a> (<a class="el" href="structapron_1_1top.html">top</a> t)</td></tr>
<tr class="memdesc:aa6e212ccde834e62fe4c4cbc006415bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the full space to *this.  <br /></td></tr>
<tr class="separator:aa6e212ccde834e62fe4c4cbc006415bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e12b7728038f0c8f990a31758ad291f" id="r_a5e12b7728038f0c8f990a31758ad291f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e12b7728038f0c8f990a31758ad291f">operator=</a> (<a class="el" href="structapron_1_1bottom.html">bottom</a> t)</td></tr>
<tr class="memdesc:a5e12b7728038f0c8f990a31758ad291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the empty set to *this.  <br /></td></tr>
<tr class="separator:a5e12b7728038f0c8f990a31758ad291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7043b7f05fc23ac032f0b12f6286b7" id="r_a3d7043b7f05fc23ac032f0b12f6286b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7043b7f05fc23ac032f0b12f6286b7">operator=</a> (const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x)</td></tr>
<tr class="memdesc:a3d7043b7f05fc23ac032f0b12f6286b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a box to *this.  <br /></td></tr>
<tr class="separator:a3d7043b7f05fc23ac032f0b12f6286b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae189bac5b66bb54a6035146b189ac31a" id="r_ae189bac5b66bb54a6035146b189ac31a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae189bac5b66bb54a6035146b189ac31a">operator=</a> (const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:ae189bac5b66bb54a6035146b189ac31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of linear constraints to *this.  <br /></td></tr>
<tr class="separator:ae189bac5b66bb54a6035146b189ac31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de9e63831781c5196cd2fc3ac5189b8" id="r_a0de9e63831781c5196cd2fc3ac5189b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de9e63831781c5196cd2fc3ac5189b8">operator=</a> (const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;x)</td></tr>
<tr class="memdesc:a0de9e63831781c5196cd2fc3ac5189b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a conjunction of arbitrary constraints to *this.  <br /></td></tr>
<tr class="separator:a0de9e63831781c5196cd2fc3ac5189b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f304a032eb83b75c4dc7dd91c8666cf" id="r_a0f304a032eb83b75c4dc7dd91c8666cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f304a032eb83b75c4dc7dd91c8666cf">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x)</td></tr>
<tr class="memdesc:a0f304a032eb83b75c4dc7dd91c8666cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a copy of x.  <br /></td></tr>
<tr class="separator:a0f304a032eb83b75c4dc7dd91c8666cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe48582207ee0c9880054153fcb730a" id="r_aebe48582207ee0c9880054153fcb730a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebe48582207ee0c9880054153fcb730a">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1top.html">top</a> t, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:aebe48582207ee0c9880054153fcb730a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the full space.  <br /></td></tr>
<tr class="separator:aebe48582207ee0c9880054153fcb730a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d6108907fb617748720a63e8c65a3d" id="r_a93d6108907fb617748720a63e8c65a3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d6108907fb617748720a63e8c65a3d">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, <a class="el" href="structapron_1_1bottom.html">bottom</a> t, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:a93d6108907fb617748720a63e8c65a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the empty set.  <br /></td></tr>
<tr class="separator:a93d6108907fb617748720a63e8c65a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7436d45c66da3558aeda0b40bcbb6f" id="r_a5b7436d45c66da3558aeda0b40bcbb6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b7436d45c66da3558aeda0b40bcbb6f">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;x, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:a5b7436d45c66da3558aeda0b40bcbb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a box.  <br /></td></tr>
<tr class="separator:a5b7436d45c66da3558aeda0b40bcbb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb82775aa11fe35263c1b05e0663272a" id="r_abb82775aa11fe35263c1b05e0663272a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb82775aa11fe35263c1b05e0663272a">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;x, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:abb82775aa11fe35263c1b05e0663272a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of linear constraints.  <br /></td></tr>
<tr class="separator:abb82775aa11fe35263c1b05e0663272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69364d5b9660faf83ce687c49374ac49" id="r_a69364d5b9660faf83ce687c49374ac49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69364d5b9660faf83ce687c49374ac49">set</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;x, size_t intdim=AP_DIM_MAX, size_t realdim=AP_DIM_MAX)</td></tr>
<tr class="memdesc:a69364d5b9660faf83ce687c49374ac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with a conjunction of arbitrary constraints.  <br /></td></tr>
<tr class="separator:a69364d5b9660faf83ce687c49374ac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Control of internal representation</div></td></tr>
<tr class="memitem:a97812eb92ef7ad2155367eeb99b161fe" id="r_a97812eb92ef7ad2155367eeb99b161fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97812eb92ef7ad2155367eeb99b161fe">minimize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a97812eb92ef7ad2155367eeb99b161fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimizes the size of the representation, to save memory.  <br /></td></tr>
<tr class="separator:a97812eb92ef7ad2155367eeb99b161fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949de6ba2d6ccb862c689a8f8b977822" id="r_a949de6ba2d6ccb862c689a8f8b977822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a949de6ba2d6ccb862c689a8f8b977822">canonicalize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:a949de6ba2d6ccb862c689a8f8b977822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the abstract element in canonical form (if such a notion exists).  <br /></td></tr>
<tr class="separator:a949de6ba2d6ccb862c689a8f8b977822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7215e4ba3298da7f66b835a95560ea62" id="r_a7215e4ba3298da7f66b835a95560ea62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7215e4ba3298da7f66b835a95560ea62">approximate</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, int algorithm)</td></tr>
<tr class="memdesc:a7215e4ba3298da7f66b835a95560ea62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the abstract element, potentially loosing precision.  <br /></td></tr>
<tr class="separator:a7215e4ba3298da7f66b835a95560ea62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access</div></td></tr>
<tr class="memitem:a78360af632ff0a307e50ec155b688d09" id="r_a78360af632ff0a307e50ec155b688d09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1manager.html">manager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78360af632ff0a307e50ec155b688d09">get_manager</a> () const</td></tr>
<tr class="memdesc:a78360af632ff0a307e50ec155b688d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the manager the abstract element was created with (with reference count incremented).  <br /></td></tr>
<tr class="separator:a78360af632ff0a307e50ec155b688d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea39fa14594c33e0b585dfa5f68c3894" id="r_aea39fa14594c33e0b585dfa5f68c3894"><td class="memItemLeft" align="right" valign="top">ap_dimension_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea39fa14594c33e0b585dfa5f68c3894">get_dimension</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:aea39fa14594c33e0b585dfa5f68c3894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of integer and real dimensions in the abstract element.  <br /></td></tr>
<tr class="separator:aea39fa14594c33e0b585dfa5f68c3894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f7b4c634f4cdaa2aeaf46f9618105e" id="r_ac1f7b4c634f4cdaa2aeaf46f9618105e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:ac1f7b4c634f4cdaa2aeaf46f9618105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (abstract) size of the abstract element.  <br /></td></tr>
<tr class="separator:ac1f7b4c634f4cdaa2aeaf46f9618105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property extraction</div></td></tr>
<tr class="memitem:ad3bfcde8e04c8fd2371cf62ee719f535" id="r_ad3bfcde8e04c8fd2371cf62ee719f535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3bfcde8e04c8fd2371cf62ee719f535">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l) const</td></tr>
<tr class="memdesc:ad3bfcde8e04c8fd2371cf62ee719f535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for a linear expression evaluated in all points in the abstract element.  <br /></td></tr>
<tr class="separator:ad3bfcde8e04c8fd2371cf62ee719f535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d2040cf521822aabe729a159c99b53" id="r_a22d2040cf521822aabe729a159c99b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d2040cf521822aabe729a159c99b53">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l) const</td></tr>
<tr class="memdesc:a22d2040cf521822aabe729a159c99b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for an arbitrary expression evaluated in all points in the abstract element.  <br /></td></tr>
<tr class="separator:a22d2040cf521822aabe729a159c99b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c2489df6d4cd5578c8dff76ea45d53" id="r_af2c2489df6d4cd5578c8dff76ea45d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval.html">interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c2489df6d4cd5578c8dff76ea45d53">bound</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t d) const</td></tr>
<tr class="memdesc:af2c2489df6d4cd5578c8dff76ea45d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns some bounds for the given coordinate on all points in the abstract element.  <br /></td></tr>
<tr class="separator:af2c2489df6d4cd5578c8dff76ea45d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ec014691a2646c4c78effbacb185c" id="r_a028ec014691a2646c4c78effbacb185c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1interval__array.html">interval_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028ec014691a2646c4c78effbacb185c">to_box</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a028ec014691a2646c4c78effbacb185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bounding box for the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:a028ec014691a2646c4c78effbacb185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcdc01b87c1d2beecdb07a8297a9ca7" id="r_aabcdc01b87c1d2beecdb07a8297a9ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1generator0__array.html">generator0_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabcdc01b87c1d2beecdb07a8297a9ca7">to_generator_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:aabcdc01b87c1d2beecdb07a8297a9ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generator representation of (an over-approximation of) the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:aabcdc01b87c1d2beecdb07a8297a9ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6af1b50ab4747690a09a24687af4e6" id="r_a2f6af1b50ab4747690a09a24687af4e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6af1b50ab4747690a09a24687af4e6">to_lincons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a2f6af1b50ab4747690a09a24687af4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:a2f6af1b50ab4747690a09a24687af4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ec6b5d4ca8b8047351f411094da8e" id="r_a669ec6b5d4ca8b8047351f411094da8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a669ec6b5d4ca8b8047351f411094da8e">to_tcons_array</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:a669ec6b5d4ca8b8047351f411094da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constraint representation of (an over-approximation of) the set represented by the abstract element.  <br /></td></tr>
<tr class="separator:a669ec6b5d4ca8b8047351f411094da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C API compatibility</div></td></tr>
<tr class="memitem:a827e433f2875073e98ed2b290230b42e" id="r_a827e433f2875073e98ed2b290230b42e"><td class="memItemLeft" align="right" valign="top">ap_abstract0_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a827e433f2875073e98ed2b290230b42e">get_ap_abstract0_t</a> ()</td></tr>
<tr class="memdesc:a827e433f2875073e98ed2b290230b42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <br /></td></tr>
<tr class="separator:a827e433f2875073e98ed2b290230b42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6122cfcdc68fbbeef4702a25ba94ae4" id="r_ae6122cfcdc68fbbeef4702a25ba94ae4"><td class="memItemLeft" align="right" valign="top">const ap_abstract0_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6122cfcdc68fbbeef4702a25ba94ae4">get_ap_abstract0_t</a> () const</td></tr>
<tr class="memdesc:ae6122cfcdc68fbbeef4702a25ba94ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal APRON object stored in *this.  <br /></td></tr>
<tr class="separator:ae6122cfcdc68fbbeef4702a25ba94ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structapron_1_1use__malloc"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structapron_1_1use__malloc')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structapron_1_1use__malloc.html">apron::use_malloc</a></td></tr>
<tr class="memitem:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc" id="r_a886761279a3b4508e689a4115060ad9f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a886761279a3b4508e689a4115060ad9f">operator new</a> (size_t sz)</td></tr>
<tr class="separator:a886761279a3b4508e689a4115060ad9f inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc" id="r_a1a5ca8977532c5975ef94b5cd382da09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1a5ca8977532c5975ef94b5cd382da09">operator new[]</a> (size_t sz)</td></tr>
<tr class="separator:a1a5ca8977532c5975ef94b5cd382da09 inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc" id="r_a6049364eb61e4e9767a7eafafd3f52dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a6049364eb61e4e9767a7eafafd3f52dc">operator delete</a> (void *p)</td></tr>
<tr class="separator:a6049364eb61e4e9767a7eafafd3f52dc inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc" id="r_a1547897dbcdc951e206b53bb0e3b57ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapron_1_1use__malloc.html#a1547897dbcdc951e206b53bb0e3b57ef">operator delete[]</a> (void *p)</td></tr>
<tr class="separator:a1547897dbcdc951e206b53bb0e3b57ef inherit pub_methods_structapron_1_1use__malloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5b9da766a1817a41d7ad3c739902e3c7" id="r_a5b9da766a1817a41d7ad3c739902e3c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9da766a1817a41d7ad3c739902e3c7">abstract0</a> (ap_abstract0_t *x)</td></tr>
<tr class="memdesc:a5b9da766a1817a41d7ad3c739902e3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only. Wraps an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> around the pointer x, taking ownership of the object.  <br /></td></tr>
<tr class="separator:a5b9da766a1817a41d7ad3c739902e3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7704fa4e2822eef41be9e570cf6a21c2" id="r_a7704fa4e2822eef41be9e570cf6a21c2"><td class="memItemLeft" align="right" valign="top">ap_abstract0_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7704fa4e2822eef41be9e570cf6a21c2">a</a></td></tr>
<tr class="memdesc:a7704fa4e2822eef41be9e570cf6a21c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer managed by APRON.  <br /></td></tr>
<tr class="separator:a7704fa4e2822eef41be9e570cf6a21c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5aadba4862f59ae21ffd467661f247a5" id="r_a5aadba4862f59ae21ffd467661f247a5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classapron_1_1abstract0.html">abstract0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></td></tr>
<tr class="memdesc:a5aadba4862f59ae21ffd467661f247a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">NULL abstract element, to be used only as default argument in assign and substitute.  <br /></td></tr>
<tr class="separator:a5aadba4862f59ae21ffd467661f247a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Printing</h2></td></tr>
<tr class="memitem:ae3ddbea873bf9284071a840bef83b79f" id="r_ae3ddbea873bf9284071a840bef83b79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ddbea873bf9284071a840bef83b79f">print</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, char **name_of_dim=NULL, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:ae3ddbea873bf9284071a840bef83b79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-printing to a C stream.  <br /></td></tr>
<tr class="separator:ae3ddbea873bf9284071a840bef83b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8893cfe891544972d4d840638fe692ce" id="r_a8893cfe891544972d4d840638fe692ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8893cfe891544972d4d840638fe692ce">dump</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, FILE *stream=stdout) const</td></tr>
<tr class="memdesc:a8893cfe891544972d4d840638fe692ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw printing to a C stream (mainly for debug purposes).  <br /></td></tr>
<tr class="separator:a8893cfe891544972d4d840638fe692ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Serialisation</h2></td></tr>
<tr class="memitem:abd22f0663c916eeb92784639f4565d1b" id="r_abd22f0663c916eeb92784639f4565d1b"><td class="memItemLeft" align="right" valign="top">std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd22f0663c916eeb92784639f4565d1b">serialize</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:abd22f0663c916eeb92784639f4565d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an abstract element.  <br /></td></tr>
<tr class="separator:abd22f0663c916eeb92784639f4565d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Predicates</h2></td></tr>
<tr class="memitem:aef077940578d27ea281ec8838fb0548c" id="r_aef077940578d27ea281ec8838fb0548c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef077940578d27ea281ec8838fb0548c">is_bottom</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:aef077940578d27ea281ec8838fb0548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the empty set.  <br /></td></tr>
<tr class="separator:aef077940578d27ea281ec8838fb0548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae4abccf24b03fbc9a84d1c9e2dad3c" id="r_acae4abccf24b03fbc9a84d1c9e2dad3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acae4abccf24b03fbc9a84d1c9e2dad3c">is_top</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m) const</td></tr>
<tr class="memdesc:acae4abccf24b03fbc9a84d1c9e2dad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this represents the full space.  <br /></td></tr>
<tr class="separator:acae4abccf24b03fbc9a84d1c9e2dad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77769eec2a835b68309495758b583175" id="r_a77769eec2a835b68309495758b583175"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77769eec2a835b68309495758b583175">is_eq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x) const</td></tr>
<tr class="memdesc:a77769eec2a835b68309495758b583175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this and x represent the same set.  <br /></td></tr>
<tr class="separator:a77769eec2a835b68309495758b583175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cd8dd502422c80a947e6bea1af42ee" id="r_a97cd8dd502422c80a947e6bea1af42ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97cd8dd502422c80a947e6bea1af42ee">is_leq</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;x) const</td></tr>
<tr class="memdesc:a97cd8dd502422c80a947e6bea1af42ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether *this is included in x (set-wise).  <br /></td></tr>
<tr class="separator:a97cd8dd502422c80a947e6bea1af42ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd9bca89afa9264d570fc2194b9a6f" id="r_ac8dd9bca89afa9264d570fc2194b9a6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8dd9bca89afa9264d570fc2194b9a6f">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons0.html">lincons0</a> &amp;l) const</td></tr>
<tr class="memdesc:ac8dd9bca89afa9264d570fc2194b9a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy a linear constraint.  <br /></td></tr>
<tr class="separator:ac8dd9bca89afa9264d570fc2194b9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584ba85a584bc1b01dd1b7bf9cd6387" id="r_af584ba85a584bc1b01dd1b7bf9cd6387"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af584ba85a584bc1b01dd1b7bf9cd6387">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons0.html">tcons0</a> &amp;l) const</td></tr>
<tr class="memdesc:af584ba85a584bc1b01dd1b7bf9cd6387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all points in *this satisfy an arbitrary constraint.  <br /></td></tr>
<tr class="separator:af584ba85a584bc1b01dd1b7bf9cd6387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80026a2875138c133476860b2e100263" id="r_a80026a2875138c133476860b2e100263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80026a2875138c133476860b2e100263">sat</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;i) const</td></tr>
<tr class="memdesc:a80026a2875138c133476860b2e100263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the dimension dim of all points in *this is included in the given interval.  <br /></td></tr>
<tr class="separator:a80026a2875138c133476860b2e100263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc789b4786aaa2159fadb635c80ea9c" id="r_adfc789b4786aaa2159fadb635c80ea9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfc789b4786aaa2159fadb635c80ea9c">is_dimension_unconstrained</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>) const</td></tr>
<tr class="memdesc:adfc789b4786aaa2159fadb635c80ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the points in *this are unbounded in the given dimension.  <br /></td></tr>
<tr class="separator:adfc789b4786aaa2159fadb635c80ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Meet</h2></td></tr>
<tr class="memitem:a66a623a045bb56acfed7a005bc38c95a" id="r_a66a623a045bb56acfed7a005bc38c95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a623a045bb56acfed7a005bc38c95a">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a66a623a045bb56acfed7a005bc38c95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a66a623a045bb56acfed7a005bc38c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315d46d075b64867c8acd449066bca35" id="r_a315d46d075b64867c8acd449066bca35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a315d46d075b64867c8acd449066bca35">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a315d46d075b64867c8acd449066bca35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a315d46d075b64867c8acd449066bca35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322cbef8760029ab9813e50192ef2e2e" id="r_a322cbef8760029ab9813e50192ef2e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a322cbef8760029ab9813e50192ef2e2e">meet</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a322cbef8760029ab9813e50192ef2e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a322cbef8760029ab9813e50192ef2e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e72178b24fc38e78d55a6381204f16" id="r_ae9e72178b24fc38e78d55a6381204f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e72178b24fc38e78d55a6381204f16">operator*=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:ae9e72178b24fc38e78d55a6381204f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the meet of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:ae9e72178b24fc38e78d55a6381204f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8d7dee0fb29a6f8da081d7b6f25202" id="r_a5f8d7dee0fb29a6f8da081d7b6f25202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8d7dee0fb29a6f8da081d7b6f25202">operator*=</a> (const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a5f8d7dee0fb29a6f8da081d7b6f25202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some linear constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a5f8d7dee0fb29a6f8da081d7b6f25202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5351164b3c69f2bdf1500f490c27a37" id="r_ab5351164b3c69f2bdf1500f490c27a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5351164b3c69f2bdf1500f490c27a37">operator*=</a> (const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;y)</td></tr>
<tr class="memdesc:ab5351164b3c69f2bdf1500f490c27a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some arbitrary constraints to *this (modified in-place).  <br /></td></tr>
<tr class="separator:ab5351164b3c69f2bdf1500f490c27a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Join</h2></td></tr>
<tr class="memitem:a40907a86c978215e81d8f553c9053858" id="r_a40907a86c978215e81d8f553c9053858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40907a86c978215e81d8f553c9053858">join</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a40907a86c978215e81d8f553c9053858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a40907a86c978215e81d8f553c9053858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0afee9e56d9fdd1b8c163edaa51aa8b" id="r_ab0afee9e56d9fdd1b8c163edaa51aa8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0afee9e56d9fdd1b8c163edaa51aa8b">add_rays</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;y)</td></tr>
<tr class="memdesc:ab0afee9e56d9fdd1b8c163edaa51aa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <br /></td></tr>
<tr class="separator:ab0afee9e56d9fdd1b8c163edaa51aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081d409ad6410a941951a09fa6573e3a" id="r_a081d409ad6410a941951a09fa6573e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081d409ad6410a941951a09fa6573e3a">operator+=</a> (const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;y)</td></tr>
<tr class="memdesc:a081d409ad6410a941951a09fa6573e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with the join of *this and the abstract element y.  <br /></td></tr>
<tr class="separator:a081d409ad6410a941951a09fa6573e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e9b2fd016578aeb05b9cf6e12a0fd" id="r_a6f2e9b2fd016578aeb05b9cf6e12a0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2e9b2fd016578aeb05b9cf6e12a0fd">operator+=</a> (const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;y)</td></tr>
<tr class="memdesc:a6f2e9b2fd016578aeb05b9cf6e12a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some rays to *this (modified in-place).  <br /></td></tr>
<tr class="separator:a6f2e9b2fd016578aeb05b9cf6e12a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Assignment</h2></td></tr>
<tr class="memitem:a71d3ba2dcf1247b65ef4c20d81e7581f" id="r_a71d3ba2dcf1247b65ef4c20d81e7581f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71d3ba2dcf1247b65ef4c20d81e7581f">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a71d3ba2dcf1247b65ef4c20d81e7581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of linear expression.  <br /></td></tr>
<tr class="separator:a71d3ba2dcf1247b65ef4c20d81e7581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661115988bf44cc76a1212d877fb83fd" id="r_a661115988bf44cc76a1212d877fb83fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a661115988bf44cc76a1212d877fb83fd">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a661115988bf44cc76a1212d877fb83fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <br /></td></tr>
<tr class="separator:a661115988bf44cc76a1212d877fb83fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121e4ca66ed3e69ab7f9390275201ed1" id="r_a121e4ca66ed3e69ab7f9390275201ed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a121e4ca66ed3e69ab7f9390275201ed1">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a121e4ca66ed3e69ab7f9390275201ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of linear expressions.  <br /></td></tr>
<tr class="separator:a121e4ca66ed3e69ab7f9390275201ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2838bf753c1d133a087adf603ebf62" id="r_abe2838bf753c1d133a087adf603ebf62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe2838bf753c1d133a087adf603ebf62">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:abe2838bf753c1d133a087adf603ebf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place assignment of arbitrary expression.  <br /></td></tr>
<tr class="separator:abe2838bf753c1d133a087adf603ebf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cca7a098bea7bfc6b6203cbfb89eac" id="r_a88cca7a098bea7bfc6b6203cbfb89eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88cca7a098bea7bfc6b6203cbfb89eac">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a88cca7a098bea7bfc6b6203cbfb89eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <br /></td></tr>
<tr class="separator:a88cca7a098bea7bfc6b6203cbfb89eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae918879a7b516977964e567f406c3fdb" id="r_ae918879a7b516977964e567f406c3fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae918879a7b516977964e567f406c3fdb">assign</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:ae918879a7b516977964e567f406c3fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel assignment of arbitrary expressions.  <br /></td></tr>
<tr class="separator:ae918879a7b516977964e567f406c3fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Substitution</h2></td></tr>
<tr class="memitem:a8e528769bb56f72eb844b9acdc114c8a" id="r_a8e528769bb56f72eb844b9acdc114c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e528769bb56f72eb844b9acdc114c8a">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a8e528769bb56f72eb844b9acdc114c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of linear expression.  <br /></td></tr>
<tr class="separator:a8e528769bb56f72eb844b9acdc114c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130523896f8fa06902749c9401eb94b1" id="r_a130523896f8fa06902749c9401eb94b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a130523896f8fa06902749c9401eb94b1">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a130523896f8fa06902749c9401eb94b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <br /></td></tr>
<tr class="separator:a130523896f8fa06902749c9401eb94b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb7557827f9b12e24d8ad227e1b1fe7" id="r_a0eb7557827f9b12e24d8ad227e1b1fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eb7557827f9b12e24d8ad227e1b1fe7">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a0eb7557827f9b12e24d8ad227e1b1fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of linear expressions.  <br /></td></tr>
<tr class="separator:a0eb7557827f9b12e24d8ad227e1b1fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc30e869a8a8ba90ef85551a6b9ba936" id="r_adc30e869a8a8ba90ef85551a6b9ba936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc30e869a8a8ba90ef85551a6b9ba936">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:adc30e869a8a8ba90ef85551a6b9ba936"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place substitution (backward assignment) of arbitrary expression.  <br /></td></tr>
<tr class="separator:adc30e869a8a8ba90ef85551a6b9ba936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e4660042ed70193e8d2f4e8b46c66f" id="r_ae4e4660042ed70193e8d2f4e8b46c66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4e4660042ed70193e8d2f4e8b46c66f">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const l[], const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:ae4e4660042ed70193e8d2f4e8b46c66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <br /></td></tr>
<tr class="separator:ae4e4660042ed70193e8d2f4e8b46c66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022b6a2c46159f774a89b630be1d5a85" id="r_a022b6a2c46159f774a89b630be1d5a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a022b6a2c46159f774a89b630be1d5a85">substitute</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>, const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;l, const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;inter=<a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a>)</td></tr>
<tr class="memdesc:a022b6a2c46159f774a89b630be1d5a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place parallel substitution (backward assignment) of arbitrary expressions.  <br /></td></tr>
<tr class="separator:a022b6a2c46159f774a89b630be1d5a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Projection, forget</h2></td></tr>
<tr class="memitem:a2c2c2fcde1c1550750f545951df48356" id="r_a2c2c2fcde1c1550750f545951df48356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c2c2fcde1c1550750f545951df48356">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, bool project=false)</td></tr>
<tr class="memdesc:a2c2c2fcde1c1550750f545951df48356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of dimension dim in *this.  <br /></td></tr>
<tr class="separator:a2c2c2fcde1c1550750f545951df48356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e3026786081ffb9c09ab63633ddcc3" id="r_ac1e3026786081ffb9c09ab63633ddcc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1e3026786081ffb9c09ab63633ddcc3">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[], bool project=false)</td></tr>
<tr class="memdesc:ac1e3026786081ffb9c09ab63633ddcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of dimensions dims[0] to dims[size-1] in *this.  <br /></td></tr>
<tr class="separator:ac1e3026786081ffb9c09ab63633ddcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f5b96dca5676303ecd749acfd91a05" id="r_a37f5b96dca5676303ecd749acfd91a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37f5b96dca5676303ecd749acfd91a05">forget</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; <a class="el" href="classapron_1_1dim.html">dim</a>, bool project=false)</td></tr>
<tr class="memdesc:a37f5b96dca5676303ecd749acfd91a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forgets about the value of all the dimensions in dim in *this.  <br /></td></tr>
<tr class="separator:a37f5b96dca5676303ecd749acfd91a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Change of dimension</h2></td></tr>
<tr class="memitem:a90bec503a28913440004561f74018b7e" id="r_a90bec503a28913440004561f74018b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90bec503a28913440004561f74018b7e">add_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;d, bool project=false)</td></tr>
<tr class="memdesc:a90bec503a28913440004561f74018b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some dimensions to *this.  <br /></td></tr>
<tr class="separator:a90bec503a28913440004561f74018b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c31b09454010d2877f768efa4611a6" id="r_a88c31b09454010d2877f768efa4611a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88c31b09454010d2877f768efa4611a6">remove_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;d)</td></tr>
<tr class="memdesc:a88c31b09454010d2877f768efa4611a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes some dimensions from *this.  <br /></td></tr>
<tr class="separator:a88c31b09454010d2877f768efa4611a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f61d1a7df076f91b1132cf5df256316" id="r_a1f61d1a7df076f91b1132cf5df256316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f61d1a7df076f91b1132cf5df256316">permute_dimensions</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const <a class="el" href="classapron_1_1dimperm.html">dimperm</a> &amp;d)</td></tr>
<tr class="memdesc:a1f61d1a7df076f91b1132cf5df256316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes some dimensions in *this.  <br /></td></tr>
<tr class="separator:a1f61d1a7df076f91b1132cf5df256316"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Expansion and folding</h2></td></tr>
<tr class="memitem:ab740889e1027ef414061a41b0c7a18b4" id="r_ab740889e1027ef414061a41b0c7a18b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab740889e1027ef414061a41b0c7a18b4">expand</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>, size_t n=1)</td></tr>
<tr class="memdesc:ab740889e1027ef414061a41b0c7a18b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates dimension dim into n copies in *this (modified in-place).  <br /></td></tr>
<tr class="separator:ab740889e1027ef414061a41b0c7a18b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df6d7b26d250725b8ceefee81606901" id="r_a5df6d7b26d250725b8ceefee81606901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df6d7b26d250725b8ceefee81606901">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, size_t <a class="el" href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">size</a>, const ap_dim_t <a class="el" href="classapron_1_1dim.html">dim</a>[])</td></tr>
<tr class="memdesc:a5df6d7b26d250725b8ceefee81606901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds dimensions dim[0] to dim[size-1] in *this (modified in-place).  <br /></td></tr>
<tr class="separator:a5df6d7b26d250725b8ceefee81606901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbc64baaab4f09559e2bc184ef6721f" id="r_a4fbc64baaab4f09559e2bc184ef6721f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fbc64baaab4f09559e2bc184ef6721f">fold</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m, const std::vector&lt; ap_dim_t &gt; &amp;<a class="el" href="classapron_1_1dim.html">dim</a>)</td></tr>
<tr class="memdesc:a4fbc64baaab4f09559e2bc184ef6721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds all dimensions dims in *this (modified in-place).  <br /></td></tr>
<tr class="separator:a4fbc64baaab4f09559e2bc184ef6721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Closure</h2></td></tr>
<tr class="memitem:aa0d298935935229cbffb7afd5fb84e06" id="r_aa0d298935935229cbffb7afd5fb84e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d298935935229cbffb7afd5fb84e06">closure</a> (<a class="el" href="classapron_1_1manager.html">manager</a> &amp;m)</td></tr>
<tr class="memdesc:aa0d298935935229cbffb7afd5fb84e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces *this with its topological closure.  <br /></td></tr>
<tr class="separator:aa0d298935935229cbffb7afd5fb84e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Level 0 abstract value (ap_abstract0_t* wrapper). </p>
<p>An <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> object stores an abstract value. It represents a set of points in a numerical space with some integer-valued dimensions and some real-valued dimensions.</p>
<dl class="section warning"><dt>Warning</dt><dd>all the abstract operators are guaranteed to be sound, but not complete, that is:<ul>
<li>returned abstract elements and intervals are over-approximations of the actual result on sets,</li>
<li>returned constraint conjunction may satisfy more points than the original abstract element,</li>
<li>returned generators may span more points than the original abstract element,</li>
<li>predicates return <code>true</code> if the predicate is definitively true, and <code>false</code> if either the predicate is false (flag_exact is then true), or due to abstraction, the domain cannot conclude (flag_exact is then false).</li>
</ul>
</dd></dl>
<p>An <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> is always created with a manager that indicates the underlying library. This defines its internal representation and algorithms, which in turns defines the expressiveness and cost vs. precision trade-off. Most operations to manipulate an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> also take a manager as first argument. This must be a manager compatible with the one of all <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> arguments (including this), that is, a manger created by the same library (e.g., NewPolka polyhedra) and using the same parameter values, if any (e.g., strictness). It need not be the very same manager the <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> was created with.</p>
<p>Overloaded arithmetic, assignment and copy operators that cannot take an extra manager argument will implicitly use the manager used to create the first argument.</p>
<p>Additionally, for binary or n-aray operators, all <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> must have the same number of integer and real dimensions.</p>
<p>Many operations exist in two kinds:</p><ul>
<li>an imperative class function that modifies the this <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a>,</li>
<li>a more "functional" global function that takes as argument both one or several constant source <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> and one destination <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> that will be overridden with the result.</li>
</ul>
<p>Both kinds will return a reference to the <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> that holds the result.</p>
<p>Most functions can throw a variety of exceptions:</p><ul>
<li>std::invalid_argument, when arguments have incompatible managers, types, or dimensions,</li>
<li>std::length_error, when running out of memory or exceeding the <code>max_object_size</code> value set by the user in the manager,</li>
<li>std::overflow_error, when a numerical overflow occurs,</li>
<li><a class="el" href="classapron_1_1not__implemented.html" title="Exception raised when a function is not implemented.">not_implemented</a>, when some function is not available,</li>
<li>timeout, when exceeding the <code>timout</code> value set by the user in the manager. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5b9da766a1817a41d7ad3c739902e3c7" name="a5b9da766a1817a41d7ad3c739902e3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9da766a1817a41d7ad3c739902e3c7">&#9670;&#160;</a></span>abstract0() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype">ap_abstract0_t *</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. Wraps an <a class="el" href="classapron_1_1abstract0.html" title="Level 0 abstract value (ap_abstract0_t* wrapper).">abstract0</a> around the pointer x, taking ownership of the object. </p>

</div>
</div>
<a id="a47720402023ba5b5378390ed4c5206e3" name="a47720402023ba5b5378390ed4c5206e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47720402023ba5b5378390ed4c5206e3">&#9670;&#160;</a></span>abstract0() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the whole space. </p>

</div>
</div>
<a id="af83420d0e0f11695e1c3a544b864fa36" name="af83420d0e0f11695e1c3a544b864fa36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83420d0e0f11695e1c3a544b864fa36">&#9670;&#160;</a></span>abstract0() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element representing the empty set. </p>

</div>
</div>
<a id="a2da4b783ea69e4655502d1637f55a98a" name="a2da4b783ea69e4655502d1637f55a98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da4b783ea69e4655502d1637f55a98a">&#9670;&#160;</a></span>abstract0() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>

</div>
</div>
<a id="aacc727bde899fbf168b7ce1dd6b61402" name="aacc727bde899fbf168b7ce1dd6b61402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc727bde899fbf168b7ce1dd6b61402">&#9670;&#160;</a></span>abstract0() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a box. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if x has less than intdim+realdim dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38a55c6e21eb9a2942c94bcf81702a19" name="a38a55c6e21eb9a2942c94bcf81702a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a55c6e21eb9a2942c94bcf81702a19">&#9670;&#160;</a></span>abstract0() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of linear constraints. </p>

</div>
</div>
<a id="ac1bd5bdcf44d170dde123e1b2d403e1a" name="ac1bd5bdcf44d170dde123e1b2d403e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bd5bdcf44d170dde123e1b2d403e1a">&#9670;&#160;</a></span>abstract0() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an abstract element from a conjunction of arbitrary constraints. </p>

</div>
</div>
<a id="a345867b8095f2cb3587f32c4d085afe5" name="a345867b8095f2cb3587f32c4d085afe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345867b8095f2cb3587f32c4d085afe5">&#9670;&#160;</a></span>abstract0() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::abstract0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (deep) copy of the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="ae9c7c340d33af5013e6a29500d3710a3" name="ae9c7c340d33af5013e6a29500d3710a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c7c340d33af5013e6a29500d3710a3">&#9670;&#160;</a></span>~abstract0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">abstract0::~abstract0 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a90bec503a28913440004561f74018b7e" name="a90bec503a28913440004561f74018b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bec503a28913440004561f74018b7e">&#9670;&#160;</a></span>add_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::add_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some dimensions to *this. </p>
<ul>
<li><code>project</code> whether to set the new dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab0afee9e56d9fdd1b8c163edaa51aa8b" name="ab0afee9e56d9fdd1b8c163edaa51aa8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0afee9e56d9fdd1b8c163edaa51aa8b">&#9670;&#160;</a></span>add_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::add_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a7215e4ba3298da7f66b835a95560ea62" name="a7215e4ba3298da7f66b835a95560ea62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7215e4ba3298da7f66b835a95560ea62">&#9670;&#160;</a></span>approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::approximate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies the abstract element, potentially loosing precision. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a71d3ba2dcf1247b65ef4c20d81e7581f" name="a71d3ba2dcf1247b65ef4c20d81e7581f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d3ba2dcf1247b65ef4c20d81e7581f">&#9670;&#160;</a></span>assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of linear expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="abe2838bf753c1d133a087adf603ebf62" name="abe2838bf753c1d133a087adf603ebf62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2838bf753c1d133a087adf603ebf62">&#9670;&#160;</a></span>assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place assignment of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of assigning l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a121e4ca66ed3e69ab7f9390275201ed1" name="a121e4ca66ed3e69ab7f9390275201ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121e4ca66ed3e69ab7f9390275201ed1">&#9670;&#160;</a></span>assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae918879a7b516977964e567f406c3fdb" name="ae918879a7b516977964e567f406c3fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae918879a7b516977964e567f406c3fdb">&#9670;&#160;</a></span>assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i]. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a661115988bf44cc76a1212d877fb83fd" name="a661115988bf44cc76a1212d877fb83fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661115988bf44cc76a1212d877fb83fd">&#9670;&#160;</a></span>assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a88cca7a098bea7bfc6b6203cbfb89eac" name="a88cca7a098bea7bfc6b6203cbfb89eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cca7a098bea7bfc6b6203cbfb89eac">&#9670;&#160;</a></span>assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel assignment of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of assigning l[i] to dimension dim[i], for i from 0 to size-1. Assignments are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="af2c2489df6d4cd5578c8dff76ea45d53" name="af2c2489df6d4cd5578c8dff76ea45d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c2489df6d4cd5578c8dff76ea45d53">&#9670;&#160;</a></span>bound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract0::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for the given coordinate on all points in the abstract element. </p>

</div>
</div>
<a id="ad3bfcde8e04c8fd2371cf62ee719f535" name="ad3bfcde8e04c8fd2371cf62ee719f535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bfcde8e04c8fd2371cf62ee719f535">&#9670;&#160;</a></span>bound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract0::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for a linear expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="a22d2040cf521822aabe729a159c99b53" name="a22d2040cf521822aabe729a159c99b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d2040cf521822aabe729a159c99b53">&#9670;&#160;</a></span>bound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval.html">interval</a> abstract0::bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns some bounds for an arbitrary expression evaluated in all points in the abstract element. </p>

</div>
</div>
<a id="a949de6ba2d6ccb862c689a8f8b977822" name="a949de6ba2d6ccb862c689a8f8b977822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949de6ba2d6ccb862c689a8f8b977822">&#9670;&#160;</a></span>canonicalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::canonicalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts the abstract element in canonical form (if such a notion exists). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aa0d298935935229cbffb7afd5fb84e06" name="aa0d298935935229cbffb7afd5fb84e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d298935935229cbffb7afd5fb84e06">&#9670;&#160;</a></span>closure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::closure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with its topological closure. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a8893cfe891544972d4d840638fe692ce" name="a8893cfe891544972d4d840638fe692ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8893cfe891544972d4d840638fe692ce">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract0::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">stdout</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raw printing to a C stream (mainly for debug purposes). </p>

</div>
</div>
<a id="ab740889e1027ef414061a41b0c7a18b4" name="ab740889e1027ef414061a41b0c7a18b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab740889e1027ef414061a41b0c7a18b4">&#9670;&#160;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates dimension dim into n copies in *this (modified in-place). </p>
<p>New dimensions are appended after the last integer or real dimension of *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a4fbc64baaab4f09559e2bc184ef6721f" name="a4fbc64baaab4f09559e2bc184ef6721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbc64baaab4f09559e2bc184ef6721f">&#9670;&#160;</a></span>fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds all dimensions dims in *this (modified in-place). </p>
<p>dim must be sorted and contain variables of the same type (integer or real). After folding, only dim[0] is kept and other dimensions are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a5df6d7b26d250725b8ceefee81606901" name="a5df6d7b26d250725b8ceefee81606901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df6d7b26d250725b8ceefee81606901">&#9670;&#160;</a></span>fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>[]&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Folds dimensions dim[0] to dim[size-1] in *this (modified in-place). </p>
<p>dim must be sorted and contain variables of the same type (integer or real). After folding, only dim[0] is kept and other dimensions are removed.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a2c2c2fcde1c1550750f545951df48356" name="a2c2c2fcde1c1550750f545951df48356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2c2fcde1c1550750f545951df48356">&#9670;&#160;</a></span>forget() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of dimension dim in *this. </p>
<ul>
<li><code>project</code> whether to reset the dimension to 0 (if true), or leave it undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a37f5b96dca5676303ecd749acfd91a05" name="a37f5b96dca5676303ecd749acfd91a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f5b96dca5676303ecd749acfd91a05">&#9670;&#160;</a></span>forget() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of all the dimensions in dim in *this. </p>
<ul>
<li><code>project</code> whether to reset the dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac1e3026786081ffb9c09ab63633ddcc3" name="ac1e3026786081ffb9c09ab63633ddcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e3026786081ffb9c09ab63633ddcc3">&#9670;&#160;</a></span>forget() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::forget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>project</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forgets about the value of dimensions dims[0] to dims[size-1] in *this. </p>
<ul>
<li><code>project</code> whether to reset the dimensions to 0 (if true), or leave them undefined (if false).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a39e60165bf1962ee9dbb8c207c2c56e8" name="a39e60165bf1962ee9dbb8c207c2c56e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e60165bf1962ee9dbb8c207c2c56e8">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract0::free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the abstract element using the given manager. </p>
<p>The abstract element cannot be used after being freed. However, the standard destructor can be safely be called (resulting in a no-op). </p>

</div>
</div>
<a id="a827e433f2875073e98ed2b290230b42e" name="a827e433f2875073e98ed2b290230b42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827e433f2875073e98ed2b290230b42e">&#9670;&#160;</a></span>get_ap_abstract0_t() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract0_t * abstract0::get_ap_abstract0_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="ae6122cfcdc68fbbeef4702a25ba94ae4" name="ae6122cfcdc68fbbeef4702a25ba94ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6122cfcdc68fbbeef4702a25ba94ae4">&#9670;&#160;</a></span>get_ap_abstract0_t() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ap_abstract0_t * abstract0::get_ap_abstract0_t </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal APRON object stored in *this. </p>

</div>
</div>
<a id="aea39fa14594c33e0b585dfa5f68c3894" name="aea39fa14594c33e0b585dfa5f68c3894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea39fa14594c33e0b585dfa5f68c3894">&#9670;&#160;</a></span>get_dimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_dimension_t abstract0::get_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of integer and real dimensions in the abstract element. </p>

</div>
</div>
<a id="a78360af632ff0a307e50ec155b688d09" name="a78360af632ff0a307e50ec155b688d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78360af632ff0a307e50ec155b688d09">&#9670;&#160;</a></span>get_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1manager.html">manager</a> abstract0::get_manager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the manager the abstract element was created with (with reference count incremented). </p>

</div>
</div>
<a id="aef077940578d27ea281ec8838fb0548c" name="aef077940578d27ea281ec8838fb0548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef077940578d27ea281ec8838fb0548c">&#9670;&#160;</a></span>is_bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the empty set. </p>

</div>
</div>
<a id="adfc789b4786aaa2159fadb635c80ea9c" name="adfc789b4786aaa2159fadb635c80ea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc789b4786aaa2159fadb635c80ea9c">&#9670;&#160;</a></span>is_dimension_unconstrained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_dimension_unconstrained </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the points in *this are unbounded in the given dimension. </p>

</div>
</div>
<a id="a77769eec2a835b68309495758b583175" name="a77769eec2a835b68309495758b583175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77769eec2a835b68309495758b583175">&#9670;&#160;</a></span>is_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this and x represent the same set. </p>

</div>
</div>
<a id="a97cd8dd502422c80a947e6bea1af42ee" name="a97cd8dd502422c80a947e6bea1af42ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cd8dd502422c80a947e6bea1af42ee">&#9670;&#160;</a></span>is_leq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_leq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this is included in x (set-wise). </p>

</div>
</div>
<a id="acae4abccf24b03fbc9a84d1c9e2dad3c" name="acae4abccf24b03fbc9a84d1c9e2dad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae4abccf24b03fbc9a84d1c9e2dad3c">&#9670;&#160;</a></span>is_top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::is_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether *this represents the full space. </p>

</div>
</div>
<a id="a40907a86c978215e81d8f553c9053858" name="a40907a86c978215e81d8f553c9053858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40907a86c978215e81d8f553c9053858">&#9670;&#160;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a66a623a045bb56acfed7a005bc38c95a" name="a66a623a045bb56acfed7a005bc38c95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a623a045bb56acfed7a005bc38c95a">&#9670;&#160;</a></span>meet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a315d46d075b64867c8acd449066bca35" name="a315d46d075b64867c8acd449066bca35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d46d075b64867c8acd449066bca35">&#9670;&#160;</a></span>meet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a322cbef8760029ab9813e50192ef2e2e" name="a322cbef8760029ab9813e50192ef2e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322cbef8760029ab9813e50192ef2e2e">&#9670;&#160;</a></span>meet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::meet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a97812eb92ef7ad2155367eeb99b161fe" name="a97812eb92ef7ad2155367eeb99b161fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97812eb92ef7ad2155367eeb99b161fe">&#9670;&#160;</a></span>minimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimizes the size of the representation, to save memory. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ae9e72178b24fc38e78d55a6381204f16" name="ae9e72178b24fc38e78d55a6381204f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e72178b24fc38e78d55a6381204f16">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the meet of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a5f8d7dee0fb29a6f8da081d7b6f25202" name="a5f8d7dee0fb29a6f8da081d7b6f25202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8d7dee0fb29a6f8da081d7b6f25202">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some linear constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ab5351164b3c69f2bdf1500f490c27a37" name="ab5351164b3c69f2bdf1500f490c27a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5351164b3c69f2bdf1500f490c27a37">&#9670;&#160;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some arbitrary constraints to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a081d409ad6410a941951a09fa6573e3a" name="a081d409ad6410a941951a09fa6573e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081d409ad6410a941951a09fa6573e3a">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the join of *this and the abstract element y. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a6f2e9b2fd016578aeb05b9cf6e12a0fd" name="a6f2e9b2fd016578aeb05b9cf6e12a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2e9b2fd016578aeb05b9cf6e12a0fd">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds some rays to *this (modified in-place). </p>
<p>Implicitly uses the manager used to create *this.</p>
<ul>
<li><code>y</code> can only contain rays and lines, not vertexes.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a5e12b7728038f0c8f990a31758ad291f" name="a5e12b7728038f0c8f990a31758ad291f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e12b7728038f0c8f990a31758ad291f">&#9670;&#160;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the empty set to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a991b63c268bdbed29e2fac7d44cd7167" name="a991b63c268bdbed29e2fac7d44cd7167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991b63c268bdbed29e2fac7d44cd7167">&#9670;&#160;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a copy of t to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a3d7043b7f05fc23ac032f0b12f6286b7" name="a3d7043b7f05fc23ac032f0b12f6286b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7043b7f05fc23ac032f0b12f6286b7">&#9670;&#160;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a box to *this. </p>
<p>Implicitly uses the manager used to create *this.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the array has insufficient size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae189bac5b66bb54a6035146b189ac31a" name="ae189bac5b66bb54a6035146b189ac31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae189bac5b66bb54a6035146b189ac31a">&#9670;&#160;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of linear constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a0de9e63831781c5196cd2fc3ac5189b8" name="a0de9e63831781c5196cd2fc3ac5189b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de9e63831781c5196cd2fc3ac5189b8">&#9670;&#160;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a conjunction of arbitrary constraints to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="aa6e212ccde834e62fe4c4cbc006415bd" name="aa6e212ccde834e62fe4c4cbc006415bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e212ccde834e62fe4c4cbc006415bd">&#9670;&#160;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the full space to *this. </p>
<p>Implicitly uses the manager used to create *this. </p>

</div>
</div>
<a id="a1f61d1a7df076f91b1132cf5df256316" name="a1f61d1a7df076f91b1132cf5df256316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f61d1a7df076f91b1132cf5df256316">&#9670;&#160;</a></span>permute_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::permute_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimperm.html">dimperm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes some dimensions in *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ae3ddbea873bf9284071a840bef83b79f" name="ae3ddbea873bf9284071a840bef83b79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ddbea873bf9284071a840bef83b79f">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void abstract0::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>name_of_dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">stdout</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty-printing to a C stream. </p>

</div>
</div>
<a id="a88c31b09454010d2877f768efa4611a6" name="a88c31b09454010d2877f768efa4611a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c31b09454010d2877f768efa4611a6">&#9670;&#160;</a></span>remove_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::remove_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1dimchange.html">dimchange</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes some dimensions from *this. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a80026a2875138c133476860b2e100263" name="a80026a2875138c133476860b2e100263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80026a2875138c133476860b2e100263">&#9670;&#160;</a></span>sat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval.html">interval</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the dimension dim of all points in *this is included in the given interval. </p>

</div>
</div>
<a id="ac8dd9bca89afa9264d570fc2194b9a6f" name="ac8dd9bca89afa9264d570fc2194b9a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dd9bca89afa9264d570fc2194b9a6f">&#9670;&#160;</a></span>sat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0.html">lincons0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy a linear constraint. </p>

</div>
</div>
<a id="af584ba85a584bc1b01dd1b7bf9cd6387" name="af584ba85a584bc1b01dd1b7bf9cd6387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af584ba85a584bc1b01dd1b7bf9cd6387">&#9670;&#160;</a></span>sat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool abstract0::sat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0.html">tcons0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether all points in *this satisfy an arbitrary constraint. </p>

</div>
</div>
<a id="abd22f0663c916eeb92784639f4565d1b" name="abd22f0663c916eeb92784639f4565d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd22f0663c916eeb92784639f4565d1b">&#9670;&#160;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string * abstract0::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes an abstract element. </p>
<p>The string can be safely stored to disk and reloaded later or transmitted across a network. The format is library-specific but is generally a machine-readable byte-stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated string that the caller should delete it after use. </dd></dl>

</div>
</div>
<a id="a93d6108907fb617748720a63e8c65a3d" name="a93d6108907fb617748720a63e8c65a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d6108907fb617748720a63e8c65a3d">&#9670;&#160;</a></span>set() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1bottom.html">bottom</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the empty set. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a0f304a032eb83b75c4dc7dd91c8666cf" name="a0f304a032eb83b75c4dc7dd91c8666cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f304a032eb83b75c4dc7dd91c8666cf">&#9670;&#160;</a></span>set() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; apron::abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a copy of x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a5b7436d45c66da3558aeda0b40bcbb6f" name="a5b7436d45c66da3558aeda0b40bcbb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7436d45c66da3558aeda0b40bcbb6f">&#9670;&#160;</a></span>set() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1interval__array.html">interval_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a box. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="abb82775aa11fe35263c1b05e0663272a" name="abb82775aa11fe35263c1b05e0663272a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb82775aa11fe35263c1b05e0663272a">&#9670;&#160;</a></span>set() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of linear constraints. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a69364d5b9660faf83ce687c49374ac49" name="a69364d5b9660faf83ce687c49374ac49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69364d5b9660faf83ce687c49374ac49">&#9670;&#160;</a></span>set() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with a conjunction of arbitrary constraints. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="aebe48582207ee0c9880054153fcb730a" name="aebe48582207ee0c9880054153fcb730a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe48582207ee0c9880054153fcb730a">&#9670;&#160;</a></span>set() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapron_1_1top.html">top</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>intdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>realdim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">AP_DIM_MAX</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces *this with the full space. </p>
<p>You can either specify new intdim and realdim values or keep those of *this (if unspecified, i.e., left to <code>AP_DIM_MAX</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ac1f7b4c634f4cdaa2aeaf46f9618105e" name="ac1f7b4c634f4cdaa2aeaf46f9618105e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f7b4c634f4cdaa2aeaf46f9618105e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t abstract0::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (abstract) size of the abstract element. </p>
<p>The unit in which size is computed is library-specific. It is guaranteed to be the same as the unit for the <code>max_object_size</code> field of the ap_funopt_t structure. </p>

</div>
</div>
<a id="a8e528769bb56f72eb844b9acdc114c8a" name="a8e528769bb56f72eb844b9acdc114c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e528769bb56f72eb844b9acdc114c8a">&#9670;&#160;</a></span>substitute() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of linear expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="adc30e869a8a8ba90ef85551a6b9ba936" name="adc30e869a8a8ba90ef85551a6b9ba936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc30e869a8a8ba90ef85551a6b9ba936">&#9670;&#160;</a></span>substitute() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place substitution (backward assignment) of arbitrary expression. </p>
<p>*this is modified in-place to reflect the effect of substituting l to dimension dim. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a0eb7557827f9b12e24d8ad227e1b1fe7" name="a0eb7557827f9b12e24d8ad227e1b1fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb7557827f9b12e24d8ad227e1b1fe7">&#9670;&#160;</a></span>substitute() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a022b6a2c46159f774a89b630be1d5a85" name="a022b6a2c46159f774a89b630be1d5a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022b6a2c46159f774a89b630be1d5a85">&#9670;&#160;</a></span>substitute() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ap_dim_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i]. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the vectors have different size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a130523896f8fa06902749c9401eb94b1" name="a130523896f8fa06902749c9401eb94b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130523896f8fa06902749c9401eb94b1">&#9670;&#160;</a></span>substitute() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1linexpr0.html">linexpr0</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of linear expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="ae4e4660042ed70193e8d2f4e8b46c66f" name="ae4e4660042ed70193e8d2f4e8b46c66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e4660042ed70193e8d2f4e8b46c66f">&#9670;&#160;</a></span>substitute() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp; abstract0::substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ap_dim_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1texpr0.html">texpr0</a> *const</td>          <td class="paramname"><span class="paramname"><em>l</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5aadba4862f59ae21ffd467661f247a5">null</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place parallel substitution (backward assignment) of arbitrary expressions. </p>
<p>*this is modified in-place to reflect the effect of substituting l[i] to dimension dim[i], for i from 0 to size-1. Substitutions are performed in parallel. If inter is specified, *this is then intersected with it.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a id="a028ec014691a2646c4c78effbacb185c" name="a028ec014691a2646c4c78effbacb185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ec014691a2646c4c78effbacb185c">&#9670;&#160;</a></span>to_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1interval__array.html">interval_array</a> abstract0::to_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bounding box for the set represented by the abstract element. </p>

</div>
</div>
<a id="aabcdc01b87c1d2beecdb07a8297a9ca7" name="aabcdc01b87c1d2beecdb07a8297a9ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcdc01b87c1d2beecdb07a8297a9ca7">&#9670;&#160;</a></span>to_generator_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1generator0__array.html">generator0_array</a> abstract0::to_generator_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a generator representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="a2f6af1b50ab4747690a09a24687af4e6" name="a2f6af1b50ab4747690a09a24687af4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6af1b50ab4747690a09a24687af4e6">&#9670;&#160;</a></span>to_lincons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1lincons0__array.html">lincons0_array</a> abstract0::to_lincons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a linear constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<a id="a669ec6b5d4ca8b8047351f411094da8e" name="a669ec6b5d4ca8b8047351f411094da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669ec6b5d4ca8b8047351f411094da8e">&#9670;&#160;</a></span>to_tcons_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapron_1_1tcons0__array.html">tcons0_array</a> abstract0::to_tcons_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapron_1_1manager.html">manager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constraint representation of (an over-approximation of) the set represented by the abstract element. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7704fa4e2822eef41be9e570cf6a21c2" name="a7704fa4e2822eef41be9e570cf6a21c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7704fa4e2822eef41be9e570cf6a21c2">&#9670;&#160;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ap_abstract0_t* apron::abstract0::a</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer managed by APRON. </p>

</div>
</div>
<a id="a5aadba4862f59ae21ffd467661f247a5" name="a5aadba4862f59ae21ffd467661f247a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aadba4862f59ae21ffd467661f247a5">&#9670;&#160;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classapron_1_1abstract0.html">abstract0</a> apron::abstract0::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NULL abstract element, to be used only as default argument in assign and substitute. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract0_8hh_source.html">apxx_abstract0.hh</a></li>
<li>/home/mine/apron/apronxx/<a class="el" href="apxx__abstract0__inline_8hh_source.html">apxx_abstract0_inline.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 29 2025 12:06:48 for APRONXX by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
