<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Functionalities of the interface at level 0 (APRON 0.9.15)</title>

<meta name="description" content="Functionalities of the interface at level 0 (APRON 0.9.15)">
<meta name="keywords" content="Functionalities of the interface at level 0 (APRON 0.9.15)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="APRON-Rationale-and-Functionalities.html" rel="up" title="APRON Rationale and Functionalities">
<link href="Functionalities-of-the-interface-at-level-1.html#Functionalities-of-the-interface-at-level-1" rel="next" title="Functionalities of the interface at level 1">
<link href="General-choices.html#General-choices" rel="prev" title="General choices">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Functionalities-of-the-interface-at-level-0">
<div class="nav-panel">
<p>
Next: <a href="Functionalities-of-the-interface-at-level-1.html#Functionalities-of-the-interface-at-level-1" accesskey="n" rel="next">Functionalities of the interface at level 1</a>, Previous: <a href="General-choices.html#General-choices" accesskey="p" rel="prev">General choices</a>, Up: <a href="APRON-Rationale-and-Functionalities.html" accesskey="u" rel="up">APRON Rationale and Functionalities</a> &nbsp; </p>
</div>
<h3 class="section" id="Functionalities-of-the-interface-at-level-0-1"><span>Functionalities of the interface at level 0<a class="copiable-link" href="#Functionalities-of-the-interface-at-level-0-1"> &para;</a></span></h3>



<hr>
<a class="node" id="Representation-of-an-abstract-value"></a><div class="nav-panel">
<p>
Next: <a href="#Semantics-of-an-abstract-value" accesskey="n" rel="next">Semantics of an abstract value</a>, Previous: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="p" rel="prev">Functionalities of the interface at level 0</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Representation-of-an-abstract-value-1"><span>Representation of an abstract value<a class="copiable-link" href="#Representation-of-an-abstract-value-1"> &para;</a></span></h4>

<p>At the level 0 of the interface, an abstract value is a structure
</p><pre class="verbatim">struct ap_abstract0_t {
  ap_manager_t *manager; /* Explicit context */
  void         *value;   /* Abstract value representation
			    (only known by the underlying library) */
}
</pre><p>The context is allocated by the underlying library, and contains an
array of function pointers pointing to the function of the underlying
library. Hence, it indicates the effective type of an abstract value.
</p>
<p>The validity of the arguments of the functions called through the
interface is checked before the call to effective functions. In case
of problem, an <code class="code">invalid_argument</code> exception is raised.
</p>
<hr>
<a class="node" id="Semantics-of-an-abstract-value"></a><div class="nav-panel">
<p>
Next: <a href="#Dimensions" accesskey="n" rel="next">Dimensions</a>, Previous: <a href="#Representation-of-an-abstract-value" accesskey="p" rel="prev">Representation of an abstract value</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Semantics-of-an-abstract-value-1"><span>Semantics of an abstract value<a class="copiable-link" href="#Semantics-of-an-abstract-value-1"> &para;</a></span></h4>

<p>The semantics of an abstract value is a subset
</p><blockquote class="quotation">
<p>X of N^p x R^q
</p></blockquote>

<p>Abstract values are typed according to their dimensionality
(p,q).
</p>
<hr>
<a class="node" id="Dimensions"></a><div class="nav-panel">
<p>
Next: <a href="#Other-datatypes" accesskey="n" rel="next">Other datatypes</a>, Previous: <a href="#Semantics-of-an-abstract-value" accesskey="p" rel="prev">Semantics of an abstract value</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Dimensions-1"><span>Dimensions<a class="copiable-link" href="#Dimensions-1"> &para;</a></span></h4>
<p>Dimensions are numbered from 0 to p+q-1 and are typed either as
integer or real, depending on their rank w.r.t. the dimensionality of
the abstract value.
</p>
<blockquote class="quotation">
<p><b class="b">Note:</b> Taking into account or not the fact that some dimensions are integers
is left to underlying libraries. Treating them as real is still a
correct approximation. The behaviour of the libraries in this regard
may also depend on some options.
</p></blockquote>

<hr>
<a class="node" id="Other-datatypes"></a><div class="nav-panel">
<p>
Next: <a href="#Control-of-internal-representation" accesskey="n" rel="next">Control of internal representation</a>, Previous: <a href="#Dimensions" accesskey="p" rel="prev">Dimensions</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Other-datatypes-1"><span>Other datatypes<a class="copiable-link" href="#Other-datatypes-1"> &para;</a></span></h4>

<p>In addition to abstract values, the interface also manipulates the
following main datatypes:
</p><dl class="table">
<dt><em class="emph">scalar (number)</em></dt>
<dd><p>Either GMP multiprecision rationals or C <code class="code">double</code>.
</p></dd>
<dt><em class="emph">interval</em></dt>
<dd><p>composed of 2 scalar numbers. With rationals, plus (resp minus) infinity is represented by 1/0 (resp -1/0). With <code class="code">double</code>, the IEEE754 is assumed and the corresponding standard representation is used.
</p></dd>
<dt><em class="emph">coefficient</em></dt>
<dd><p>which is either a scalar or an interval.
</p></dd>
<dt><em class="emph">(interval) linear expression</em></dt>
<dd><p>The term linear is used even if the proper term should rather be
affine.  A linear expression is a linear expression in the common
sense, using only scalar numbers. A quasi-linear expression is a
linear expression where the constant coefficient is an interval. An
interval linear expression is a linear expression where any
coefficient may be an interval. In order to have a unique datatype for
these variations, we introduced the notion of coefficient described
above.
</p></dd>
<dt><em class="emph">&ldquo;linear&rdquo; constraints</em></dt>
<dd><p>&ldquo;Linear&rdquo; constraints includes proper linear constraints, linear
constraints in which the expression can be possibly an interval linear
expression, linear equalities modulo a number, and linear disequalities.
</p></dd>
<dt><em class="emph">generators</em></dt>
<dd><p>A generator system for a subset of <em class="math">X\subseteq R^n</em> is a finite
set of vectors, among which one distinguishes <em class="emph">points</em>
<em class="math">p_0,\ldots,p_m</em> and <em class="emph">rays</em> <em class="math">r_0,\ldots,r_n</em>, that
generates <em class="math">X</em>:
</p><blockquote class="quotation">
<p>X = { lambda0 p0 +...+ lambdaM pM + mu0 r0 +...+ muN rN | lambda0 +...+ lambdaN = 1 and forall J : muJ &gt;= 0 }
</p></blockquote>
<p>The APRON datatype for generators distinguishes points (sum of
coefficients equal to one), rays (positive coefficients), lines (or
bidirectional rays, with unconstrainted coefficients), integer rays
(integer positive coefficients) and integer lines (integer
coefficients).
</p></dd>
</dl>

<hr>
<a class="node" id="Control-of-internal-representation"></a><div class="nav-panel">
<p>
Next: <a href="#Printing" accesskey="n" rel="next">Printing</a>, Previous: <a href="#Other-datatypes" accesskey="p" rel="prev">Other datatypes</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Control-of-internal-representation-1"><span>Control of internal representation<a class="copiable-link" href="#Control-of-internal-representation-1"> &para;</a></span></h4>

<p>We identified several notions:
</p>
<ul class="itemize mark-bullet">
<li>Canonical form
</li><li>Minimal form (in term of space)
</li><li>Approximation notion left to the underlying library (taking into
account integers or not, ...).
</li></ul>

<hr>
<a class="node" id="Printing"></a><div class="nav-panel">
<p>
Next: <a href="#Serializaton_002fDeserialization" accesskey="n" rel="next">Serializaton/Deserialization</a>, Previous: <a href="#Control-of-internal-representation" accesskey="p" rel="prev">Control of internal representation</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Printing-1"><span>Printing<a class="copiable-link" href="#Printing-1"> &para;</a></span></h4>

<p>There are two printing operations:
</p>
<ul class="itemize mark-bullet">
<li>Printing of an abstract value;
</li><li>Printing the difference between two abstract values.
</li></ul>

<p>The printing format is library dependent. However, the conversion of
abstract values to constraints (see below) allows a form of
standardized printing for abstract values.
</p>
<hr>
<a class="node" id="Serializaton_002fDeserialization"></a><div class="nav-panel">
<p>
Next: <a href="#Constructors" accesskey="n" rel="next">Constructors</a>, Previous: <a href="#Printing" accesskey="p" rel="prev">Printing</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Serializaton_002fDeserialization-1"><span>Serializaton/Deserialization<a class="copiable-link" href="#Serializaton_002fDeserialization-1"> &para;</a></span></h4>

<p>Serialization and deserialization of abstract values to a memory
buffer is offered. It is entirely managed by the underlying
library. In particular, it is up to it to check that a value read from
the memory buffer has the right format and has not been written by a
different library.
</p>
<p>Serialization is done to a memory buffer instead of to a file
descriptor because this mechanism is more general and is needed for
interfacing with languages like <small class="sc">OCAML</small>.
</p>
<hr>
<a class="node" id="Constructors"></a><div class="nav-panel">
<p>
Next: <a href="#Tests" accesskey="n" rel="next">Tests</a>, Previous: <a href="#Serializaton_002fDeserialization" accesskey="p" rel="prev">Serializaton/Deserialization</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Constructors-1"><span>Constructors<a class="copiable-link" href="#Constructors-1"> &para;</a></span></h4>

<p>Four basic constructors are offered:
</p>
<ul class="itemize mark-bullet">
<li>bottom (empty) and top (universe) values (with a specified dimensionality);
</li><li>abstraction of a bounding box;
</li><li>abstraction of conjunction of linear constraints (in the broad sense).
</li></ul>

<hr>
<a class="node" id="Tests"></a><div class="nav-panel">
<p>
Next: <a href="#Property-extraction" accesskey="n" rel="next">Property extraction</a>, Previous: <a href="#Constructors" accesskey="p" rel="prev">Constructors</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Tests-1"><span>Tests<a class="copiable-link" href="#Tests-1"> &para;</a></span></h4>

<p>Predicates are offered for testing
</p><ul class="itemize mark-bullet">
<li>emptiness and universality of an abstract value:
</li><li>inclusion and equality of two abstract values;
</li><li>inclusion of a dimension into an interval given an abstract value;
</li><li>satisfaction of a linear constraint by the abstract value.
</li></ul>

<hr>
<a class="node" id="Property-extraction"></a><div class="nav-panel">
<p>
Next: <a href="#Lattice-operations" accesskey="n" rel="next">Lattice operations</a>, Previous: <a href="#Tests" accesskey="p" rel="prev">Tests</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Property-extraction-1"><span>Property extraction<a class="copiable-link" href="#Property-extraction-1"> &para;</a></span></h4>

<p>Some properties may be inferred given an abstract value:
</p>
<ul class="itemize mark-bullet">
<li>Interval of variation of a dimension in an abstract value;

</li><li>Interval of variation of a linear expression in an abstract value;
</li><li>Conversion to a bounding box
</li><li>Conversion to a set of linear constraints (in the broad sense).
</li></ul>

<p>Notice that the second operation implements linear programming if it
is exact. The third operation is not minimal, as it can be implemented
using the first one, but it was convenient to include it. But the
fourth operation is minimal and cannot be implemented using the second
one, as the number of linear expression is infinite.
</p>
<hr>
<a class="node" id="Lattice-operations"></a><div class="nav-panel">
<p>
Next: <a href="#Assignement-and-Substitutions" accesskey="n" rel="next">Assignement and Substitutions</a>, Previous: <a href="#Property-extraction" accesskey="p" rel="prev">Property extraction</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Lattice-operations-1"><span>Lattice operations<a class="copiable-link" href="#Lattice-operations-1"> &para;</a></span></h4>

<ul class="itemize mark-bullet">
<li>Least upper bound and greatest lower bound of two abstract values, and of arrays of abstract values;
</li><li>Intersection with one or several linear constraints;
</li><li>Addition of rays (for instance for implement generalized time elapse
operator in linear hybrid systems).
</li></ul>

<hr>
<a class="node" id="Assignement-and-Substitutions"></a><div class="nav-panel">
<p>
Next: <a href="#Operations-on-dimensions" accesskey="n" rel="next">Operations on dimensions</a>, Previous: <a href="#Lattice-operations" accesskey="p" rel="prev">Lattice operations</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Assignement-and-Substitutions-1"><span>Assignement and Substitutions<a class="copiable-link" href="#Assignement-and-Substitutions-1"> &para;</a></span></h4>

<ul class="itemize mark-bullet">
<li>of a dimension by a (interval) linear expression
</li><li>in parallel of several dimensions by several (interval) linear expressions
</li></ul>

<p>Parallel assignement and substitution ar enot minimal operations, but
for some abstract domains implementing them directly results in more
efficient or more precise operations.
</p>
<hr>
<a class="node" id="Operations-on-dimensions"></a><div class="nav-panel">
<p>
Next: <a href="#Other-operations" accesskey="n" rel="next">Other operations</a>, Previous: <a href="#Assignement-and-Substitutions" accesskey="p" rel="prev">Assignement and Substitutions</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Operations-on-dimensions-1"><span>Operations on dimensions<a class="copiable-link" href="#Operations-on-dimensions-1"> &para;</a></span></h4>

<ul class="itemize mark-bullet">
<li>Projection/Elimination of one or several dimensions with constant
dimensionality;
</li><li>Addition/Removal/Permutation of dimensions with corresponding change
of dimensionality (with the exception of permutation). These
operations allows to resize abstract values, and reorganize
dimensions.
</li><li>Expansion and folding of dimensions. This is useful for the
abstraction of arrays, where a dimension may represent several
variables.


</li></ul>

<hr>
<a class="node" id="Other-operations"></a><div class="nav-panel">
<p>
Previous: <a href="#Operations-on-dimensions" accesskey="p" rel="prev">Operations on dimensions</a>, Up: <a href="#Functionalities-of-the-interface-at-level-0" accesskey="u" rel="up">Functionalities of the interface at level 0</a> &nbsp; </p>
</div>
<h4 class="subsubheading" id="Other-operations-1"><span>Other operations<a class="copiable-link" href="#Other-operations-1"> &para;</a></span></h4>

<p>Widening, either simple or with threshold, is offered. A generic
widening with threshold function is offered in the interface.
</p>
<p>Topological closure (i.e., relaxation of strict inequalities) is
offered.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Functionalities-of-the-interface-at-level-1.html#Functionalities-of-the-interface-at-level-1" accesskey="n" rel="next">Functionalities of the interface at level 1</a>, Previous: <a href="General-choices.html#General-choices" accesskey="p" rel="prev">General choices</a>, Up: <a href="APRON-Rationale-and-Functionalities.html" accesskey="u" rel="up">APRON Rationale and Functionalities</a> &nbsp; </p>
</div>



</body>
</html>
