<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>NewPolka (APRON 0.9.15)</title>

<meta name="description" content="NewPolka (APRON 0.9.15)">
<meta name="keywords" content="NewPolka (APRON 0.9.15)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Managers-and-Abstract-Domains.html" rel="up" title="Managers and Abstract Domains">
<link href="PPL.html#PPL" rel="next" title="PPL">
<link href="Oct.html" rel="prev" title="Oct">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="NewPolka">
<div class="nav-panel">
<p>
Next: <a href="PPL.html#PPL" accesskey="n" rel="next">PPL (<samp class="file">ap_ppl.h</samp>): convex polyhedra and linear congruences abstract domains</a>, Previous: <a href="Oct.html" accesskey="p" rel="prev">Oct: octagon abstract domain</a>, Up: <a href="Managers-and-Abstract-Domains.html" accesskey="u" rel="up">Managers and Abstract Domains</a> &nbsp; </p>
</div>
<h3 class="section" id="NewPolka-_0028pk_002eh_0029_003a-convex-polyhedra-and-linear-equalities-abstract-domains"><span>NewPolka (<samp class="file">pk.h</samp>): convex polyhedra and linear equalities abstract domains<a class="copiable-link" href="#NewPolka-_0028pk_002eh_0029_003a-convex-polyhedra-and-linear-equalities-abstract-domains"> &para;</a></span></h3>



<p>The <small class="sc">NEWPOLKA</small> convex polyhedra and linear equalities library is
aimed to be used through the APRON interface. However some specific
points should be precised.  First, <small class="sc">NEWPOLKA</small> can use several
underlying representations for numbers, which lead to several library
variants. Second, some specific functions are needed, typically to
allocate managers, and to specify special options.
</p>

<ul class="mini-toc">
<li><a href="#Use-of-NewPolka" accesskey="1">Use of NewPolka</a></li>
<li><a href="#Allocating-NewPolka-managers-and-setting-specific-options" accesskey="2">Allocating NewPolka managers and setting specific options</a></li>
<li><a href="#NewPolka-standard-options" accesskey="3">NewPolka standard options</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Use-of-NewPolka">
<div class="nav-panel">
<p>
Next: <a href="#Allocating-NewPolka-managers-and-setting-specific-options" accesskey="n" rel="next">Allocating NewPolka managers and setting specific options</a>, Up: <a href="#NewPolka" accesskey="u" rel="up">NewPolka (<samp class="file">pk.h</samp>): convex polyhedra and linear equalities abstract domains</a> &nbsp; </p>
</div>
<h4 class="subsection" id="Use-of-NewPolka-1"><span>Use of NewPolka<a class="copiable-link" href="#Use-of-NewPolka-1"> &para;</a></span></h4>

<p>To use <small class="sc">NEWPOLKA</small> in C, add
</p><div class="example">
<pre class="example-preformatted">#include &quot;pk.h&quot;
#include &quot;pkeq.h&quot;
  /* if you want linear equalities */
</pre></div>
<p>in your source file(s) and add &lsquo;<samp class="samp">-I$(APRON_PREFIX)/include</samp>&rsquo; in the
command line in your Makefile.
</p>
<p>You should also link your object files with the <small class="sc">NEWPOLKA</small> library
to produce an executable, by adding something like
&lsquo;<samp class="samp">-L$(APRON_PREFIX)/lib -lpolkag</samp>&rsquo; in the command line in your
Makefile (followed by the standard &lsquo;<samp class="samp">-lapron -litvmpq -litvdbl
-L$(MPFR_PREFIX)/lib -lmpfr -L$(GMP_PREFIX)/lib -lgmp</samp>&rsquo;).
</p>
<p>There are actually several variants of the library:
</p><dl class="table">
<dt><samp class="file">libpolkai.a</samp></dt>
<dd><p>The underlying representation for integers is <code class="code">long int</code>. This
may easily cause overflows, especially with many dimensions or
variables. Overflows are not detected but usually result in infinite
looping.
The underlying representation for integers is <code class="code">long long
int</code>. This may (less) easily cause overflows.
</p></dd>
<dt><samp class="file">libpolkag.a</samp></dt>
<dd><p>The underlying representation for integers is <code class="code">mpz_t</code>, the
multi-precision integers from the GNU GMP library. Overflows are not
possible any more, but huge numbers may appear.
</p></dd>
</dl>

<p>All scalars of type <code class="code">double</code> are converted to scalars of type
<code class="code">mpq_t</code> inside NewPolka, as NewPolka works internally with exact
rational arithmetics. So when possible it is better for the user (in
term of efficiency) to convert already <code class="code">double</code> scalars to
<code class="code">mpq_t</code> scalars.
</p>
<p>There is a way to prevent overflow and/or huge numbers, which is to
position the options <code class="code">max_coeff_size</code> and
<code class="code">approximate_max_coeff_size</code>, see
<a class="ref" href="#Allocating-NewPolka-managers-and-setting-specific-options">Allocating NewPolka managers and setting specific options</a>.
</p>
<p>Also, all library are available in debug mode
(&lsquo;<samp class="samp">libpolkai_debug.a</samp>&rsquo;, ....
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Allocating-NewPolka-managers-and-setting-specific-options">
<div class="nav-panel">
<p>
Next: <a href="#NewPolka-standard-options" accesskey="n" rel="next">NewPolka standard options</a>, Previous: <a href="#Use-of-NewPolka" accesskey="p" rel="prev">Use of NewPolka</a>, Up: <a href="#NewPolka" accesskey="u" rel="up">NewPolka (<samp class="file">pk.h</samp>): convex polyhedra and linear equalities abstract domains</a> &nbsp; </p>
</div>
<h4 class="subsection" id="Allocating-NewPolka-managers-and-setting-specific-options-1"><span>Allocating NewPolka managers and setting specific options<a class="copiable-link" href="#Allocating-NewPolka-managers-and-setting-specific-options-1"> &para;</a></span></h4>

<dl class="first-deftp def-block">
<dt class="deftp def-line" id="index-pk_005finternal_005ft"><span class="category-def">datatype: </span><span><strong class="def-name">pk_internal_t</strong><a class="copiable-link" href="#index-pk_005finternal_005ft"> &para;</a></span></dt>
<dd><p>NewPolka type for internal managers (specific to NewPolka, and
specific to each execution thread in multithreaded programs).
</p></dd></dl>

<h4 class="subheading" id="Allocating-managers"><span>Allocating managers<a class="copiable-link" href="#Allocating-managers"> &para;</a></span></h4>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn def-block">
<dt class="deftypefn deftypefun-alias-deftypefn def-line" id="index-pk_005fmanager_005falloc"><span class="category-def">Function: </span><span><code class="def-type">ap_manager_t*</code> <strong class="def-name">pk_manager_alloc</strong> <code class="def-code-arguments">(bool <var class="var">strict</var>)</code><a class="copiable-link" href="#index-pk_005fmanager_005falloc"> &para;</a></span></dt>
<dd><p>Allocate an APRON manager for convex polyhedra, linked to the NewPolka
library.
</p>
<p>The <var class="var">strict</var> option, when true, enables strict constraints in polyhedra
(like <code class="code">x&gt;0</code>). Managers in strict mode or in loose mode
(strict constraints disabled) are not compatible, and so are
corresponding abstract values.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn def-block">
<dt class="deftypefn deftypefun-alias-deftypefn def-line" id="index-pkeq_005fmanager_005falloc"><span class="category-def">Function: </span><span><code class="def-type">ap_manager_t*</code> <strong class="def-name">pkeq_manager_alloc</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-pkeq_005fmanager_005falloc"> &para;</a></span></dt>
<dd><p>Allocate an APRON manager for linear equalities, linked to the NewPolka
library.
</p>
<p>Most options which makes sense for convex polyhedra are meaningless
for linear equalities. It is better to set the standard options
associated to functions so that abstract values are in canonical form
(see <a class="pxref" href="#NewPolka-standard-options">NewPolka standard options</a>). This is the default anyway.
</p></dd></dl>

<h4 class="subheading" id="Setting-options"><span>Setting options<a class="copiable-link" href="#Setting-options"> &para;</a></span></h4>

<p>Options specific to <small class="sc">NEWPOLKA</small> are set directly on the internal
manager. It can be extracted with the <code class="code">pk_manager_get_internal</code>
function.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn def-block">
<dt class="deftypefn deftypefun-alias-deftypefn def-line" id="index-pk_005fmanager_005fget_005finternal"><span class="category-def">Function: </span><span><code class="def-type">pk_internal_t*</code> <strong class="def-name">pk_manager_get_internal</strong> <code class="def-code-arguments">(ap_manager_t* <var class="var">man</var>)</code><a class="copiable-link" href="#index-pk_005fmanager_005fget_005finternal"> &para;</a></span></dt>
<dd><p>Return the internal submanager. If <var class="var">man</var> has not been created by
<code class="code">pk_manager_alloc</code> or <code class="code">pkeq_manager_alloc</code>, return <code class="code">NULL</code>.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn def-block">
<dt class="deftypefn deftypefun-alias-deftypefn def-line" id="index-pk_005fset_005fmax_005fcoeff_005fsize"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">pk_set_max_coeff_size</strong> <code class="def-code-arguments">(pk_internal_t* <var class="var">pk</var>, size_t <var class="var">size</var>)</code><a class="copiable-link" href="#index-pk_005fset_005fmax_005fcoeff_005fsize"> &para;</a></span></dt>
<dd><p>If <var class="var">size</var> is not 0, try to raise an <code class="code">AP_EXC_OVERFLOW</code>
exception as soon as the size of an integer exceed <var class="var">size</var>.
</p>
<p>Very incomplete implementation. Currently, used only in
<samp class="file">libpolkag</samp> variant, where the size is the number of limbs as
returned by the function <code class="code">mpz_size</code> of the GMP library. This
allows to detect huge numbers.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn def-block">
<dt class="deftypefn deftypefun-alias-deftypefn def-line" id="index-pk_005fset_005fapproximate_005fmax_005fcoeff_005fsize"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">pk_set_approximate_max_coeff_size</strong> <code class="def-code-arguments">(pk_internal_t* <var class="var">pk</var>, size_t <var class="var">size</var>)</code><a class="copiable-link" href="#index-pk_005fset_005fapproximate_005fmax_005fcoeff_005fsize"> &para;</a></span></dt>
<dd><p>This is the parameter to the <code class="code">poly_approximate</code>/<code class="code">ap_abstractX_approximate</code> functions.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn def-block">
<dt class="deftypefn deftypefun-alias-deftypefn def-line" id="index-pk_005fget_005fmax_005fcoeff_005fsize"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">pk_get_max_coeff_size</strong> <code class="def-code-arguments">(pk_internal_t* <var class="var">pk</var>)</code><a class="copiable-link" href="#index-pk_005fget_005fmax_005fcoeff_005fsize"> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn def-line" id="index-pk_005fget_005fapproximate_005fmax_005fcoeff_005fsize"><span class="category-def">Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">pk_get_approximate_max_coeff_size</strong> <code class="def-code-arguments">(pk_internal_t* <var class="var">pk</var>)</code><a class="copiable-link" href="#index-pk_005fget_005fapproximate_005fmax_005fcoeff_005fsize"> &para;</a></span></dt>
<dd><p>Reading the previous parameters.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="NewPolka-standard-options">
<div class="nav-panel">
<p>
Previous: <a href="#Allocating-NewPolka-managers-and-setting-specific-options" accesskey="p" rel="prev">Allocating NewPolka managers and setting specific options</a>, Up: <a href="#NewPolka" accesskey="u" rel="up">NewPolka (<samp class="file">pk.h</samp>): convex polyhedra and linear equalities abstract domains</a> &nbsp; </p>
</div>
<h4 class="subsection" id="NewPolka-standard-options-1"><span>NewPolka standard options<a class="copiable-link" href="#NewPolka-standard-options-1"> &para;</a></span></h4>

<p>This section describes the NewPolka options which are selected using
the standard mechanism offered by APRON (see <a class="pxref" href="Managers.html#Manager-options">Manager options</a>).
</p>
<h4 class="subsubheading" id="Modes"><span>Modes<a class="copiable-link" href="#Modes"> &para;</a></span></h4>
<p>Most functions of NewPolka has two modes. In the lazy mode the
canonicalization (computation of the dual representation and
minimisation of both representations) of the argument polyhedra is
performed only when the needed representation is not available. The
resulting polyhedra is in general not in the canonical
representation. In the strict mode, argument polyhedra are
canonicalized (if they are not yet in canonical form) and the result
is (in general) in canonical form.
</p>
<p>The strict mode exploits the incremental propery of the Chernikova
algorithm and maintain in parallel the constraints and the generators
representations. The lazy mode delays computations as much as
possible.
</p>
<p>Be cautious, in the following table, canonical means minimized
constraints and generators representation, but nothing more. In
particular, the function <code class="code">canonicalize</code> performs further
normalization by normalizing strict constraints (when they exist) and
ordering constraints and generators.
</p>

<table class="multitable">
<tbody><tr><td width="20%">Function</td><td width="6%">algo</td><td width="74%">Comments</td></tr>
<tr><td width="20%">copy</td><td width="6%"></td><td width="74%">Identical representation</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">free</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">size</td><td width="6%"></td><td width="74%">Return the number of coefficients. <br>
Their size (when using multi-precision integers) is not taken into
account.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">minimize</td><td width="6%"></td><td width="74%">Require canonicalization.

<p>Keep only the smallest representation among the constraints and the
generators representation.
</p></td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">canonicalize</td><td width="6%"></td><td width="74%"></td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">approximate</td><td width="6%"></td><td width="74%">Require constraints. <br>
algo here refers to the explicit parameter of the
function. A negative number indicates a possibly smaller result, a
positive one a possibly greater one. The effects of the function may
be different for 2 identical polyhedra defined by different systems of
(non minimal) constraints.<br>
Equalities are never modified.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%"></td><td width="6%">-1</td><td width="74%">Normalize integer minimal constraints. This results in a smaller
polyhedra.</td></tr>
<tr><td width="20%"></td><td width="6%">1</td><td width="74%">Remove constraints with coefficients of size (in bits) greater than
the approximate_max_coeff_size parameter.</td></tr>
<tr><td width="20%"></td><td width="6%">2</td><td width="74%">Idem, but preserve interval constraints.</td></tr>
<tr><td width="20%"></td><td width="6%">3</td><td width="74%">Idem, but preserve octagonal constraints (+/- xi +/- xj &gt;= cst).</td></tr>
<tr><td width="20%"></td><td width="6%">10</td><td width="74%">Simplify constraints such that the coefficients size (in bits) are
less or equal than the approximate_max_coeff_size parameter. The
constant coefficients are recomputed by linear programming and are not
involved in the reduction process.</td></tr>
<tr><td width="20%"></td><td width="6%">&ndash;</td><td width="74%">Do nothing</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">fprint</td><td width="6%"></td><td width="74%">Require canonicalization.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">fprintdiff</td><td width="6%"></td><td width="74%">not implemented</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">fdump</td><td width="6%"></td><td width="74%">Print raw representations of any of the constraints, generators and
saturation matrices that are available.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">serialize_raw, deserialize_raw</td><td width="6%"></td><td width="74%">not implemented</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">bottom,top</td><td width="6%"></td><td width="74%">Return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">of_box</td><td width="6%"></td><td width="74%">Return constraints.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">of_lincons_array</td><td width="6%"></td><td width="74%">Return constraints.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Take into account interval-linear constraints, after having minimized the quasi-linear constraints</td></tr>
<tr><td width="20%"></td><td width="6%">&lt;0</td><td width="74%">Ignore interval-linear constraints</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">dimension</td><td width="6%"></td><td width="74%"></td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">is_bottom</td><td width="6%">&lt;0</td><td width="74%">If generators not available, return <code class="code">tbool_top</code></td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">If generators not available, canonicalize and return <code class="code">tbool_false</code> or <code class="code">tbool_true</code>.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">is_top</td><td width="6%">&lt;0</td><td width="74%">If not in canonical form, return <code class="code">tbool_top</code></td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">is_leq</td><td width="6%">&lt;=0</td><td width="74%">Require generators of first argument and constraints of second argument.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form for both arguments.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">is_eq</td><td width="6%"></td><td width="74%">Require canonical form for both arguments.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">is_dimension_unconstrained</td><td width="6%"></td><td width="74%">Require canonical form</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">sat_interval, sat_lincons, bound_dimension, bound_linexpr</td><td width="6%">&lt;=0</td><td width="74%">Require generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">to_box</td><td width="6%">&lt;0</td><td width="74%">Require generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">to_lincons_array,
to_generator_array</td><td width="6%"></td><td width="74%">Require canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">meet, meet_array, meet_lincons_array</td><td width="6%">&lt;0</td><td width="74%">Require constraints. <br>
Return non-minimized constraints.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form. <br>
Return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">join, join_array, add_ray_array</td><td width="6%">&lt;0</td><td width="74%">Require generators. <br>
Return non-minimized generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form. <br>
Return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">assign_linexpr</td><td width="6%"></td><td width="74%">1. If the optional argument is NULL,</td></tr>
<tr><td width="20%"></td><td width="6%">&lt;=0</td><td width="74%">If the expr. is deterministic and invertible, require any representation and return the transformed one. If in canonical form, return canonical form. <br>
If the expr. is deterministic and non-invertible, require generators and return generators <br>
If the expr. is non-deterministic, require constraints and return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form, return canonical form. <br>
If the expr. is deterministic,(and even more, invertible), the
operation is more efficient.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%"></td><td width="6%"></td><td width="74%">2. If the optional argument is not NULL,
first the assignement is performed, and then the
meet function is applied with its corresponding option.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">substitute_linexpr</td><td width="6%"></td><td width="74%">1. If the optional argument is NULL,</td></tr>
<tr><td width="20%"></td><td width="6%">&lt;=0</td><td width="74%">If the expr. is deterministic and invertible, require any representation and return the transformed one. If in canonical form, return canonical form. <br>
If the expr. is deterministic and non-invertible, require constraints and return constraints <br>
If the expr. is non-deterministic, require constraints and return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form, return canonical form. <br>
If the expr. is deterministic (and even more, invertible), the
operation is more efficient.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%"></td><td width="6%"></td><td width="74%">2. If the optional argument is not NULL,
first the substitution is performed, and then the
meet function is applied with its corresponding option.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">assign_linexpr_array</td><td width="6%"></td><td width="74%">1. If the optional argument is NULL,</td></tr>
<tr><td width="20%"></td><td width="6%">&lt;=0</td><td width="74%">If the expr. are deterministic, require generators and return generators <br>
Otherwise, require canonical form and return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%"></td><td width="6%"></td><td width="74%">2. If the optional argument is not NULL,
first the assignement is performed, and then the
meet function is applied with its corresponding option.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">substitute_linexpr_array</td><td width="6%"></td><td width="74%">1. If the optional argument is NULL,</td></tr>
<tr><td width="20%"></td><td width="6%">&lt;=0</td><td width="74%">If the expr. are deterministic, require constraints and return constraints <br>
Otherwise, require canonical form and return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%"></td><td width="6%"></td><td width="74%">2. If the optional argument is not NULL,
first the substitution is performed, and then the
meet function is applied with its corresponding option.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">forget_array</td><td width="6%">&lt;=0</td><td width="74%">Require generators and return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form and return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">add_dimensions, permute_dimensions</td><td width="6%">&lt;=0</td><td width="74%">Require any representation and return the updated one. <br>
If in canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">remove_dimensions</td><td width="6%">&lt;=0</td><td width="74%">Require generators, return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;0</td><td width="74%">Require canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">expand</td><td width="6%">&lt;0</td><td width="74%">Require constraints, return constraints.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">fold</td><td width="6%">&lt;0</td><td width="74%">Require generators, return generators.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form, return canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">widening</td><td width="6%"></td><td width="74%">Require canonical form.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%">closure</td><td width="6%"></td><td width="74%">1. If pk_manager_alloc() has been given a false Boolean (no strict constraints), same as copy.</td></tr>
<tr><td width="20%"></td></tr>
<tr><td width="20%"></td><td width="6%"></td><td width="74%">2. Otherwise,</td></tr>
<tr><td width="20%"></td><td width="6%">&lt;0</td><td width="74%">Require constraints, return constraints.</td></tr>
<tr><td width="20%"></td><td width="6%">&gt;=0</td><td width="74%">Require canonical form, return constraints.</td></tr>
</tbody>
</table>

</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="PPL.html#PPL" accesskey="n" rel="next">PPL (<samp class="file">ap_ppl.h</samp>): convex polyhedra and linear congruences abstract domains</a>, Previous: <a href="Oct.html" accesskey="p" rel="prev">Oct: octagon abstract domain</a>, Up: <a href="Managers-and-Abstract-Domains.html" accesskey="u" rel="up">Managers and Abstract Domains</a> &nbsp; </p>
</div>



</body>
</html>
