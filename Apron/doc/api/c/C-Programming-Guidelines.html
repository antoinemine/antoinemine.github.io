<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>C Programming Guidelines (APRON 0.9.15)</title>

<meta name="description" content="C Programming Guidelines (APRON 0.9.15)">
<meta name="keywords" content="C Programming Guidelines (APRON 0.9.15)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="APRON-Guidelines.html" rel="up" title="APRON Guidelines">
<link href="OCaml-Programming-Guidelines.html" rel="next" title="OCaml Programming Guidelines">
<link href="Installing-APRON.html" rel="prev" title="Installing APRON">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="C-Programming-Guidelines">
<div class="nav-panel">
<p>
Next: <a href="OCaml-Programming-Guidelines.html" accesskey="n" rel="next">OCaml Programming Guidelines</a>, Previous: <a href="Installing-APRON.html" accesskey="p" rel="prev">Installing APRON</a>, Up: <a href="APRON-Guidelines.html" accesskey="u" rel="up">APRON Guidelines</a> &nbsp; </p>
</div>
<h3 class="section" id="C-Programming-Guidelines-1"><span>C Programming Guidelines<a class="copiable-link" href="#C-Programming-Guidelines-1"> &para;</a></span></h3>



<ul class="mini-toc">
<li><a href="#C-Headers-and-Libraries" accesskey="1">C Headers and Libraries</a></li>
<li><a href="#C-Naming-conventions" accesskey="2">Naming conventions and Allocation/Deallocation schemes</a></li>
<li><a href="#Allocating-managers-and-setting-options" accesskey="3">Allocating managers and setting options</a></li>
<li><a href="#Sequel-of-the-small-example" accesskey="4">Sequel of the small example</a></li>
<li><a href="#Typing-issue-in-C" accesskey="5">Typing issue in C</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="C-Headers-and-Libraries">
<div class="nav-panel">
<p>
Next: <a href="#C-Naming-conventions" accesskey="n" rel="next">Naming conventions and Allocation/Deallocation schemes</a>, Previous: <a href="#C-Programming-Guidelines" accesskey="p" rel="prev">C Programming Guidelines</a>, Up: <a href="#C-Programming-Guidelines" accesskey="u" rel="up">C Programming Guidelines</a> &nbsp; </p>
</div>
<h4 class="subsection" id="C-Headers-and-Libraries-1"><span>C Headers and Libraries<a class="copiable-link" href="#C-Headers-and-Libraries-1"> &para;</a></span></h4>

<p>Declarations needed to use an underlying library via APRON are
collected in the C include files <samp class="file">ap_global0.h</samp> and
<samp class="file">ap_global1.h</samp>. They respectively refer to the level 0 and the
level 1 of the interface. One can also refer to single APRON modules
with their corresponding include files <samp class="file">ap_dimension.h</samp>,
<samp class="file">ap_lincons0.h</samp>, ... Header files <samp class="file">&lt;stdio.h&gt;</samp>,
<samp class="file">stdlib.h</samp> and <samp class="file">&lt;stdarg.h&gt;</samp> will be required.
</p>
<p>Then, you should also include the header files of the underlying
libraries you want to use via APRON (for instance, <samp class="file">box.h</samp>,
<samp class="file">pk.h</samp>, <samp class="file">ap_ppl.h</samp>).
</p>
<p>All programs using APRON must link against the <samp class="file">libapron</samp>,
<samp class="file">libmpfr</samp> and <samp class="file">libgmp</samp> libraries, and the underlying
libraries you want to use via APRON:
</p><ol class="enumerate">
<li> If some file <samp class="file">test.c</samp> uses the POLKA library via APRON, the
compilation command should look like &lsquo;<samp class="samp">gcc -I$ITV/include
-I$MPFR/include -I$GMP/include -I$APRON/include -L$MPFR/lib
-L$GMP/lib -L$APRON/lib -o test test.c -lpolkaMPQ -lapron -lmpfr -lgmp</samp>&rsquo;,
assuming that the POLKA library is used in
its &rsquo;MPQ&rsquo; version (internal number representation is GMP rationals) and
resides in <samp class="file">$APRON/include</samp> and <samp class="file">$APRON/lib</samp> directories.

<p>The <samp class="file">libpolkaMPQ.a</samp> library is of course needed,
<samp class="file">libapron.a</samp> contains all the code common to all APRON library
(manipulation of expressions, environments, ...), as well as ITV
functions (quasi)linearisation facilities of APRON,...), last the
libraries <code class="code">libmpfr.a</code> and <code class="code">libgmp.a</code> are required both by
<small class="sc">NEWPOLKA</small> and <small class="sc">APRON</small> .
</p></li><li> If some file <samp class="file">test.c</samp> uses the PPL library via APRON, the
compilation command should look like &lsquo;<samp class="samp">g++ -I$ITV/include
-I$MPFR/include -I$GMP/include -I$APRON/include -I$PPL/include
-L$ITV/lib -L$MPFR/lib -L$GMP/lib -L$APRON/lib -L$PPL/lib -o test
test.c -la_ppl -lppl -lgmpxx -lapron -lmpfr
-lgmp</samp>&rsquo;, assuming that PPL resides in $PPL and PPL APRON interface in
<samp class="file">$APRON/include</samp> and <samp class="file">$APRON/lib</samp> directories.

<p>Notice that the PPL library (<samp class="file">libppl.a</samp>) is a C++ library, you
need to use &lsquo;<samp class="samp">g++</samp>&rsquo; instead of &lsquo;<samp class="samp">gcc</samp>&rsquo; for linking. You also
need the C++ layer on top of GMP (<samp class="file">libgmpxx.a</samp>). The
<samp class="file">libap_ppl.a</samp> library contains the layer on top of PPL which
implements the APRON interface.
</p>
</li><li> If a C file <samp class="file">test.c</samp> uses the PPLite library via APRON,
the compilation command should look like &lsquo;<samp class="samp">g++ -I$ITV/include
-I$MPFR/include -I$GMP/include -I$APRON/include -I$PPLITE/include
-I$FLINT/include -L$ITV/lib -L$MPFR/lib -L$GMP/lib -L$APRON/lib
-L$PPLITE/lib -L$FLINT/lib -o test test.c
-lap_pplite -lpplite -lflint -lgmpxx -lapron -lmpfr -lgmp</samp>&rsquo;,
assuming that PPLite resides in $PPLITE and PPLite APRON interface in
<samp class="file">$APRON/include</samp> and <samp class="file">$APRON/lib</samp> directories.

<p>Notice that the PPLite library (<samp class="file">libpplite.a</samp>) is a C++ library,
you need to use &lsquo;<samp class="samp">g++</samp>&rsquo; instead of &lsquo;<samp class="samp">gcc</samp>&rsquo; for linking.
You also need the C++ layer on top of GMP (<samp class="file">libgmpxx.a</samp>).
The <samp class="file">libap_pplite.a</samp> library contains the layer on top of PPLite
which implements the APRON interface.
</p></li></ol>
<p>You should look at the specific documentation of the libraries for
more details.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="C-Naming-conventions">
<div class="nav-panel">
<p>
Next: <a href="#Allocating-managers-and-setting-options" accesskey="n" rel="next">Allocating managers and setting options</a>, Previous: <a href="#C-Headers-and-Libraries" accesskey="p" rel="prev">C Headers and Libraries</a>, Up: <a href="#C-Programming-Guidelines" accesskey="u" rel="up">C Programming Guidelines</a> &nbsp; </p>
</div>
<h4 class="subsection" id="Naming-conventions-and-Allocation_002fDeallocation-schemes"><span>Naming conventions and Allocation/Deallocation schemes<a class="copiable-link" href="#Naming-conventions-and-Allocation_002fDeallocation-schemes"> &para;</a></span></h4>

<p>The general rule is that all type and function names defined by the
library are prefixed with <code class="code">ap_</code>, in order to prevent name
conflicts with other libraries. Moreover, functions operating on
objects of type <code class="code">ap_typ_t</code> are usually prefixed with
<code class="code">ap_typ_op</code>.
</p>
<p>Given an object of datatype <code class="code">ap_typ_t*</code>, two kinds of allocation/deallocation pairs of functions may be defined:
</p>
<ol class="enumerate">
<li> variable declaration: <code class="code">ap_typ_t obj;</code>
<ul class="itemize mark-bullet">
<li>Initialization:
<code class="code">void typ_init(ap_typ_t* arg, ...)</code> or <code class="code">ap_typ_t ap_typ_make(...)</code>
</li><li>Finalization:
<code class="code">void ap_typ_clear(ap_typ_t* arg)</code>
</li></ul>
<p>this pair of functions follows the semantics used in the GMP
library. The first function initializes the object of type
<code class="code">ap_typ_t</code> pointed to by <var class="var">arg</var>, and fills it with a valid
content. The second function deallocates the memory possibly pointed
to by fields of the object <code class="code">*arg</code>, but do not attempt to
deallocate the memory pointed by <var class="var">arg</var>.
</p></li><li> variable declaration: <code class="code">ap_typ_t* obj;</code>
<ul class="itemize mark-bullet">
<li>Allocation
<code class="code">ap_typ_t* ap_typ_alloc(...)</code>
</li><li>Deallocation
<code class="code">void ap_typ_free(ap_typ_t* arg)</code>
</li></ul>
<p>the first function allocates an object of type <code class="code">typ_t</code> and then
calls a <code class="code">ap_typ_init</code>-like function on the result; the second
functions first call a <code class="code">ap_typ_clear</code>-like function and then
deallocate the memory pointed by <var class="var">arg</var>.
</p></li></ol>

<hr>
</div>
<div class="subsection-level-extent" id="Allocating-managers-and-setting-options">
<div class="nav-panel">
<p>
Next: <a href="#Sequel-of-the-small-example" accesskey="n" rel="next">Sequel of the small example</a>, Previous: <a href="#C-Naming-conventions" accesskey="p" rel="prev">Naming conventions and Allocation/Deallocation schemes</a>, Up: <a href="#C-Programming-Guidelines" accesskey="u" rel="up">C Programming Guidelines</a> &nbsp; </p>
</div>
<h4 class="subsection" id="Allocating-managers-and-setting-options-1"><span>Allocating managers and setting options<a class="copiable-link" href="#Allocating-managers-and-setting-options-1"> &para;</a></span></h4>

<p>From the user point of view, the benefit of using the APRON interface
is to restrict the place where the user is aware of the real library
in use to the code initializing the manager, as illustrated by the
following example:
</p><div class="example">
<pre class="example-preformatted">#include &quot;ap_global1.h&quot;
#include &quot;pk.h&quot;

/* Allocating a Polka manager, for polyhedra with strict constraints */
manager_t* man = pk_manager_alloc(true);
/* Setting options offered by the common interface,
   but with meaning possibly specific to the library */
manager_set_abort_if_exception(man,EXC_OVERFLOW,true);
{
  funopt_t funopt;
  funopt_init(&amp;funopt);
  funopt.algorithm = 1; /* default value is 0 */
  manager_set_funopt(man,fun_widening,&amp;funopt); /* Setting options for widening */
}
{
  funopt_t funopt = manager_get_funopt(man,fun_widening);
  funopt.timeout = 30;
  manager_set_funopt(man,fun_widening,&amp;funopt);
}
/* Obtaining the internal part of the manager and setting specific options */
pk_internal_t* pk = manager_get_internal(man);
pk_set_max_coeff_size(pk,size);
</pre></div>
<p>The standard operations can then be used and will have the
semantics defined in the interface. Notice however that some
generic functions are not formally generic: <code class="code">abstract_fprint</code>,
<code class="code">abstract_fdump</code>, <code class="code">abstract_approximate</code>.
At any point, options may be modified in the same way as during
the initialization.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Sequel-of-the-small-example">
<div class="nav-panel">
<p>
Next: <a href="#Typing-issue-in-C" accesskey="n" rel="next">Typing issue in C</a>, Previous: <a href="#Allocating-managers-and-setting-options" accesskey="p" rel="prev">Allocating managers and setting options</a>, Up: <a href="#C-Programming-Guidelines" accesskey="u" rel="up">C Programming Guidelines</a> &nbsp; </p>
</div>
<h4 class="subsection" id="Sequel-of-the-small-example-1"><span>Sequel of the small example<a class="copiable-link" href="#Sequel-of-the-small-example-1"> &para;</a></span></h4>
<p>An environment can be created as follows:
</p>
<div class="example smallexample">
<pre class="example-preformatted">/* Create an environment with 6 real variables */
ap_var_t name_of_dim[6] = {
  &quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;u&quot;,&quot;w&quot;,&quot;v&quot;
};
ap_environment_t* env = ap_environment_alloc(NULL,0,name_of_dim,6);
</pre></div>

<p>Then, we build an array of constraints. At level 1, an array of
constraints is an abstract datatype, which requires careful
manipulation w.r.t. memory management.
</p>
<div class="example smallexample">
<pre class="example-preformatted">/* Create an array of constraints of size 2 */
ap_lincons1_array_t array = ap_lincons1_array_make(env,2);

/* 1.a Creation of an inequality constraint */
ap_linexpr1_t expr = ap_linexpr1_make(env,AP_LINEXPR_SPARSE,1);
ap_lincons1_t cons = ap_lincons1_make(AP_CONS_SUP,&amp;expr,NULL);
    /* Now expr is memory-managed by cons */
/* 1.b Fill the constraint */
ap_lincons1_set_list(&amp;cons,
		     AP_COEFF_S_INT,&quot;x&quot;,
		     AP_CST_S_FRAC,1,2,
		     AP_END);
/* 1.c Put in the array */
ap_lincons1_array_set(&amp;array,0,&amp;cons);
    /* Now cons is memory-managed by array */

/* 2.a Creation of an inequality constraint */
expr = ap_linexpr1_make(env,AP_LINEXPR_SPARSE,2);
cons = ap_lincons1_make(AP_CONS_SUPEQ,&amp;expr,NULL);
    /* The old cons is not lost, because it is stored in the array.
       It would be an error to clear it (same for expr). */
/* 2.b Fill the constraint */
ap_lincons1_set_list(&amp;cons,
		     AP_COEFF_S_INT,1,&quot;x&quot;,
		     AP_COEFF_S_INT,1,&quot;y&quot;,
		     AP_COEFF_S_INT,1,&quot;z&quot;,
		     AP_END);
/* 2.c Put in the array */
ap_lincons1_array_set(&amp;array,1,&amp;cons);
</pre></div>

<p>Last we can build an abstract value.
</p>
<div class="example smallexample">
<pre class="example-preformatted">/* Creation of an abstract value defined by the array of constraints */
ap_abstract1_t abs = ap_abstract1_of_lincons_array(man,env,&amp;array);

fprintf(stdout,&quot;Abstract value:\n&quot;);
ap_abstract1_fprint(stdout,man,&amp;abs);
</pre></div>

<p>We  now deallocate everything:
</p>
<div class="example smallexample">
<pre class="example-preformatted">/* deallocation */
ap_lincons1_array_clear(&amp;array);
ap_abstract1_clear(&amp;abs);
ap_environment_free(env);
ap_manager_free(man);
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="Typing-issue-in-C">
<div class="nav-panel">
<p>
Previous: <a href="#Sequel-of-the-small-example" accesskey="p" rel="prev">Sequel of the small example</a>, Up: <a href="#C-Programming-Guidelines" accesskey="u" rel="up">C Programming Guidelines</a> &nbsp; </p>
</div>
<h4 class="subsection" id="Typing-issue-in-C-1"><span>Typing issue in C<a class="copiable-link" href="#Typing-issue-in-C-1"> &para;</a></span></h4>

<p>The use of several libraries at the same time via the common
interface and the managers associated to each library raises the
problem of typing. Look at the following code:
</p>
<div class="example">
<pre class="example-preformatted">ap_manager_t* manpk = pk_manager_alloc(true); /* manager for Polka */
ap_manager_t* manoct = oct_manager_alloc();    /* manager for octagon */

ap_abstract0_t* abs1 = ap_abstract_top(manpk,3,3);
ap_abstract0_t* abs2 = ap_abstract_top(manoct,3,3);
bool b = ap_abstract0_is_eq(manoct,abs1,abs2);
  /* Problem: the effective function called (octagon_is_eq) expects
     abs1 to be an octagon, and not a polyhedron ! */

ap_abstract0_t* abs3 = ap_abstract_top(manoct,3,3);
abstract0_meet_with(manpk,abs2,abs3);
  /* Problem: the effective function called (pk_meet_with) expects
     abs2 and abs3 to be polyhedra, but they are octagons */
</pre></div>

<p>There is actually no static typing, as <code class="code">abstract0_t*</code>
and <code class="code">manager_t</code> are abstract types shared by the different
libraries. Types are thus dynamically checked by the interface.
Notice that the use of <em class="emph">C++</em> and inheritance would not solve
directly the problem, if functions of the interface are methods of
the manager; one would have:
</p>
<div class="example">
<pre class="example-preformatted">ap_manager_t* manpk = pk_manager_alloc(true);
  /* manager for Polka, effective type pk_manager_t* */
ap_manager_t* manoct = oct_manager_alloc();
  /* manager for octagon, effective type oct_manager_t* */

ap_abstract0_t* abs1 = manpk-&gt;abstract_top(3,3);
  /* effective type: poly_t */
ap_abstract0_t* abs2 = manoct-&gt;abstract_top(3,3);
  /* effective type: oct_t */
bool b = manoct-&gt;abstract0_is_eq(abs1,abs2);
  /* No static typing possible:
     manpk-&gt;abstract0_is_eq and manoct-&gt;abstract0_is_eq should have the same
     signature (otherwise one cannot interchange manpk and manoct in the code),
     which means that abs1 and abs2 are supposed to be of type abstract0_t* */
*/
</pre></div>

<p>Currently, only the OCaml polymorphic type system allows to solve
elegantly this problem.
</p>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="OCaml-Programming-Guidelines.html" accesskey="n" rel="next">OCaml Programming Guidelines</a>, Previous: <a href="Installing-APRON.html" accesskey="p" rel="prev">Installing APRON</a>, Up: <a href="APRON-Guidelines.html" accesskey="u" rel="up">APRON Guidelines</a> &nbsp; </p>
</div>



</body>
</html>
